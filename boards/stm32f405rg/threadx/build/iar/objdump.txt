###############################################################################
#
# IAR ELF Dumper V9.50.2.385 for ARM                      15/Oct/2024  22:07:00
# Copyright 2007-2024 IAR Systems AB.
#
#    Input file   =
#        C:\Users\xidon\code\github\qemu-simulator\boards\stm32f405rg\threadx\build\iar\stm32-qemu.out
#    Output file  =
#        C:\Users\xidon\code\github\qemu-simulator\boards\stm32f405rg\threadx\build\iar\objdump.txt
#    Command line =
#        --source --code .\build\iar/stm32-qemu.out -o .\build\iar/objdump.txt
#
###############################################################################



Section #4 A0:

                $d:
                `.intvec7`:
                __vector_table:
  0x800'0000: 0x2000'2cd8  DC32 CSTACK$$Limit
  0x800'0004: 0x0800'4095  DC32 Reset_Handler
  0x800'0008: 0x0800'0ced  DC32 NMI_Handler
  0x800'000c: 0x0800'40c9  DC32 HardFault_Handler
  0x800'0010: 0x0800'0cf9  DC32 MemManage_Handler
  0x800'0014: 0x0800'0d05  DC32 BusFault_Handler
  0x800'0018: 0x0800'0d11  DC32 UsageFault_Handler
  0x800'001c: 0x0000'0000  DC32 0                      ; '....'
  0x800'0020: 0x0000'0000  DC32 0                      ; '....'
  0x800'0024: 0x0000'0000  DC32 0                      ; '....'
  0x800'0028: 0x0000'0000  DC32 0                      ; '....'
  0x800'002c: 0x0800'0d1d  DC32 SVC_Handler
  0x800'0030: 0x0800'0d1f  DC32 DebugMon_Handler
  0x800'0034: 0x0000'0000  DC32 0                      ; '....'
  0x800'0038: 0x0800'3a85  DC32 __tx_PendSVHandler
  0x800'003c: 0x0800'3a1f  DC32 __tx_SysTickHandler
  0x800'0040: 0x0800'40cd  DC32 WWDG_IRQHandler
  0x800'0044: 0x0800'40d1  DC32 PVD_IRQHandler
  0x800'0048: 0x0800'40d5  DC32 TAMP_STAMP_IRQHandler
  0x800'004c: 0x0800'40d9  DC32 RTC_WKUP_IRQHandler
  0x800'0050: 0x0800'40dd  DC32 FLASH_IRQHandler
  0x800'0054: 0x0800'40e1  DC32 RCC_IRQHandler
  0x800'0058: 0x0800'40e5  DC32 EXTI0_IRQHandler
  0x800'005c: 0x0800'40e9  DC32 EXTI1_IRQHandler
  0x800'0060: 0x0800'40ed  DC32 EXTI2_IRQHandler
  0x800'0064: 0x0800'40f1  DC32 EXTI3_IRQHandler
  0x800'0068: 0x0800'40f5  DC32 EXTI4_IRQHandler
  0x800'006c: 0x0800'40f9  DC32 DMA1_Stream0_IRQHandler
  0x800'0070: 0x0800'40fd  DC32 DMA1_Stream1_IRQHandler
  0x800'0074: 0x0800'4101  DC32 DMA1_Stream2_IRQHandler
  0x800'0078: 0x0800'4105  DC32 DMA1_Stream3_IRQHandler
  0x800'007c: 0x0800'4109  DC32 DMA1_Stream4_IRQHandler
  0x800'0080: 0x0800'410d  DC32 DMA1_Stream5_IRQHandler
  0x800'0084: 0x0800'4111  DC32 DMA1_Stream6_IRQHandler
  0x800'0088: 0x0800'4115  DC32 ADC_IRQHandler
  0x800'008c: 0x0800'4119  DC32 CAN1_TX_IRQHandler
  0x800'0090: 0x0800'411d  DC32 CAN1_RX0_IRQHandler
  0x800'0094: 0x0800'4121  DC32 CAN1_RX1_IRQHandler
  0x800'0098: 0x0800'4125  DC32 CAN1_SCE_IRQHandler
  0x800'009c: 0x0800'4129  DC32 EXTI9_5_IRQHandler
  0x800'00a0: 0x0800'412d  DC32 TIM1_BRK_TIM9_IRQHandler
  0x800'00a4: 0x0800'4131  DC32 TIM1_UP_TIM10_IRQHandler
  0x800'00a8: 0x0800'4135  DC32 TIM1_TRG_COM_TIM11_IRQHandler
  0x800'00ac: 0x0800'4139  DC32 TIM1_CC_IRQHandler
  0x800'00b0: 0x0800'0d21  DC32 TIM2_IRQHandler
  0x800'00b4: 0x0800'413d  DC32 TIM3_IRQHandler
  0x800'00b8: 0x0800'4141  DC32 TIM4_IRQHandler
  0x800'00bc: 0x0800'4145  DC32 I2C1_EV_IRQHandler
  0x800'00c0: 0x0800'4149  DC32 I2C1_ER_IRQHandler
  0x800'00c4: 0x0800'414d  DC32 I2C2_EV_IRQHandler
  0x800'00c8: 0x0800'4151  DC32 I2C2_ER_IRQHandler
  0x800'00cc: 0x0800'4155  DC32 SPI1_IRQHandler
  0x800'00d0: 0x0800'4159  DC32 SPI2_IRQHandler
  0x800'00d4: 0x0800'0d2f  DC32 USART1_IRQHandler
  0x800'00d8: 0x0800'415d  DC32 USART2_IRQHandler
  0x800'00dc: 0x0800'4161  DC32 USART3_IRQHandler
  0x800'00e0: 0x0800'4165  DC32 EXTI15_10_IRQHandler
  0x800'00e4: 0x0800'4169  DC32 RTC_Alarm_IRQHandler
  0x800'00e8: 0x0800'416d  DC32 OTG_FS_WKUP_IRQHandler
  0x800'00ec: 0x0800'4171  DC32 TIM8_BRK_TIM12_IRQHandler
  0x800'00f0: 0x0800'4175  DC32 TIM8_UP_TIM13_IRQHandler
  0x800'00f4: 0x0800'4179  DC32 TIM8_TRG_COM_TIM14_IRQHandler
  0x800'00f8: 0x0800'417d  DC32 TIM8_CC_IRQHandler
  0x800'00fc: 0x0800'4181  DC32 DMA1_Stream7_IRQHandler
  0x800'0100: 0x0800'4185  DC32 FSMC_IRQHandler
  0x800'0104: 0x0800'4189  DC32 SDIO_IRQHandler
  0x800'0108: 0x0800'418d  DC32 TIM5_IRQHandler
  0x800'010c: 0x0800'4191  DC32 SPI3_IRQHandler
  0x800'0110: 0x0800'4195  DC32 UART4_IRQHandler
  0x800'0114: 0x0800'4199  DC32 UART5_IRQHandler
  0x800'0118: 0x0800'419d  DC32 TIM6_DAC_IRQHandler
  0x800'011c: 0x0800'41a1  DC32 TIM7_IRQHandler
  0x800'0120: 0x0800'41a5  DC32 DMA2_Stream0_IRQHandler
  0x800'0124: 0x0800'41a9  DC32 DMA2_Stream1_IRQHandler
  0x800'0128: 0x0800'41ad  DC32 DMA2_Stream2_IRQHandler
  0x800'012c: 0x0800'41b1  DC32 DMA2_Stream3_IRQHandler
  0x800'0130: 0x0800'41b5  DC32 DMA2_Stream4_IRQHandler
  0x800'0134: 0x0000'0000  DC32 0                      ; '....'
  0x800'0138: 0x0000'0000  DC32 0                      ; '....'
  0x800'013c: 0x0800'41b9  DC32 CAN2_TX_IRQHandler
  0x800'0140: 0x0800'41bd  DC32 CAN2_RX0_IRQHandler
  0x800'0144: 0x0800'41c1  DC32 CAN2_RX1_IRQHandler
  0x800'0148: 0x0800'41c5  DC32 CAN2_SCE_IRQHandler
  0x800'014c: 0x0800'41c9  DC32 OTG_FS_IRQHandler
  0x800'0150: 0x0800'41cd  DC32 DMA2_Stream5_IRQHandler
  0x800'0154: 0x0800'41d1  DC32 DMA2_Stream6_IRQHandler
  0x800'0158: 0x0800'41d5  DC32 DMA2_Stream7_IRQHandler
  0x800'015c: 0x0800'41d9  DC32 USART6_IRQHandler
  0x800'0160: 0x0800'41dd  DC32 I2C3_EV_IRQHandler
  0x800'0164: 0x0800'41e1  DC32 I2C3_ER_IRQHandler
  0x800'0168: 0x0800'41e5  DC32 OTG_HS_EP1_OUT_IRQHandler
  0x800'016c: 0x0800'41e9  DC32 OTG_HS_EP1_IN_IRQHandler
  0x800'0170: 0x0800'41ed  DC32 OTG_HS_WKUP_IRQHandler
  0x800'0174: 0x0800'41f1  DC32 OTG_HS_IRQHandler
  0x800'0178: 0x0000'0000  DC32 0                      ; '....'
  0x800'017c: 0x0000'0000  DC32 0                      ; '....'
  0x800'0180: 0x0800'41f5  DC32 HASH_RNG_IRQHandler
  0x800'0184: 0x0800'41f9  DC32 FPU_IRQHandler
  // HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
  // {


-------------------------------------------------------------------------------
Section #5 P1:

  // HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
  // {
                $t:
                `.text8`:
                HAL_UART_Init:
  0x800'0188: 0xb510          PUSH     {R4, LR}
  0x800'018a: 0x0004          MOVS     R4, R0
  //   if (huart == NULL)
  0x800'018c: 0x2c00          CMP      R4, #0
  0x800'018e: 0xd101          BNE.N    ??HAL_UART_Init_0      ; 0x800'0194
  //     return HAL_ERROR;
  0x800'0190: 0x2001          MOVS     R0, #1
  0x800'0192: 0xe0a3          B.N      ??HAL_UART_Init_1      ; 0x800'02dc
                ??HAL_UART_Init_0:
  //   if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
  0x800'0194: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'0196: 0x2800          CMP      R0, #0
  0x800'0198: 0xd02f          BEQ.N    ??HAL_UART_Init_2      ; 0x800'01fa
  //     assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
  0x800'019a: 0x6821          LDR      R1, [R4]
  0x800'019c: 0xf8df 0x021c   LDR.W    R0, ??DataTable5       ; 0x4001'1000
  0x800'01a0: 0x4281          CMP      R1, R0
  0x800'01a2: 0xd014          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01a4: 0x6821          LDR      R1, [R4]
  0x800'01a6: 0xf8df 0x0218   LDR.W    R0, ??DataTable5_1     ; 0x4000'4400
  0x800'01aa: 0x4281          CMP      R1, R0
  0x800'01ac: 0xd00f          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01ae: 0x6821          LDR      R1, [R4]
  0x800'01b0: 0xf8df 0x0210   LDR.W    R0, ??DataTable5_2     ; 0x4000'4800
  0x800'01b4: 0x4281          CMP      R1, R0
  0x800'01b6: 0xd00a          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01b8: 0x6821          LDR      R1, [R4]
  0x800'01ba: 0xf8df 0x020c   LDR.W    R0, ??DataTable5_3     ; 0x4001'1400
  0x800'01be: 0x4281          CMP      R1, R0
  0x800'01c0: 0xd005          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01c2: 0xf240 0x1173   MOVW     R1, #371               ; 0x173
  0x800'01c6: 0xf8df 0x0204   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'01ca: 0xf000 0xfdbc   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_3:
  //     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
  0x800'01ce: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01d0: 0x2800          CMP      R0, #0
  0x800'01d2: 0xd036          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01d4: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01d6: 0xf5b0 0x7f80   CMP.W    R0, #256               ; 0x100
  0x800'01da: 0xd032          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01dc: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01de: 0xf5b0 0x7f00   CMP.W    R0, #512               ; 0x200
  0x800'01e2: 0xd02e          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01e4: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01e6: 0xf5b0 0x7f40   CMP.W    R0, #768               ; 0x300
  0x800'01ea: 0xd02a          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01ec: 0xf44f 0x71ba   MOV.W    R1, #372               ; 0x174
  0x800'01f0: 0xf8df 0x01d8   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'01f4: 0xf000 0xfda7   BL       assert_failed          ; 0x800'0d46
  0x800'01f8: 0xe023          B.N      ??HAL_UART_Init_4      ; 0x800'0242
                ??HAL_UART_Init_2:
  //     assert_param(IS_UART_INSTANCE(huart->Instance));
  0x800'01fa: 0x6821          LDR      R1, [R4]
  0x800'01fc: 0xf8df 0x01bc   LDR.W    R0, ??DataTable5       ; 0x4001'1000
  0x800'0200: 0x4281          CMP      R1, R0
  0x800'0202: 0xd01e          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0204: 0x6821          LDR      R1, [R4]
  0x800'0206: 0xf8df 0x01b8   LDR.W    R0, ??DataTable5_1     ; 0x4000'4400
  0x800'020a: 0x4281          CMP      R1, R0
  0x800'020c: 0xd019          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'020e: 0x6821          LDR      R1, [R4]
  0x800'0210: 0xf8df 0x01b0   LDR.W    R0, ??DataTable5_2     ; 0x4000'4800
  0x800'0214: 0x4281          CMP      R1, R0
  0x800'0216: 0xd014          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0218: 0x6821          LDR      R1, [R4]
  0x800'021a: 0xf8df 0x01b4   LDR.W    R0, ??DataTable5_5     ; 0x4000'4c00
  0x800'021e: 0x4281          CMP      R1, R0
  0x800'0220: 0xd00f          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0222: 0x6821          LDR      R1, [R4]
  0x800'0224: 0xf8df 0x01ac   LDR.W    R0, ??DataTable5_6     ; 0x4000'5000
  0x800'0228: 0x4281          CMP      R1, R0
  0x800'022a: 0xd00a          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'022c: 0x6821          LDR      R1, [R4]
  0x800'022e: 0xf8df 0x0198   LDR.W    R0, ??DataTable5_3     ; 0x4001'1400
  0x800'0232: 0x4281          CMP      R1, R0
  0x800'0234: 0xd005          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0236: 0xf44f 0x71bc   MOV.W    R1, #376               ; 0x178
  0x800'023a: 0xf8df 0x0190   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'023e: 0xf000 0xfd82   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_4:
  //   assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  0x800'0242: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'0244: 0x2800          CMP      R0, #0
  0x800'0246: 0xd009          BEQ.N    ??HAL_UART_Init_5      ; 0x800'025c
  0x800'0248: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'024a: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'024e: 0xd005          BEQ.N    ??HAL_UART_Init_5      ; 0x800'025c
  0x800'0250: 0xf44f 0x71bd   MOV.W    R1, #378               ; 0x17a
  0x800'0254: 0xf8df 0x0174   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'0258: 0xf000 0xfd75   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_5:
  //   assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  0x800'025c: 0x69e0          LDR      R0, [R4, #0x1c]
  0x800'025e: 0x2800          CMP      R0, #0
  0x800'0260: 0xd009          BEQ.N    ??HAL_UART_Init_6      ; 0x800'0276
  0x800'0262: 0x69e0          LDR      R0, [R4, #0x1c]
  0x800'0264: 0xf5b0 0x4f00   CMP.W    R0, #32768             ; 0x8000
  0x800'0268: 0xd005          BEQ.N    ??HAL_UART_Init_6      ; 0x800'0276
  0x800'026a: 0xf240 0x117b   MOVW     R1, #379               ; 0x17b
  0x800'026e: 0xf8df 0x015c   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'0272: 0xf000 0xfd68   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_6:
  //   if (huart->gState == HAL_UART_STATE_RESET)
  0x800'0276: 0xf894 0x0041   LDRB.W   R0, [R4, #0x41]
  0x800'027a: 0x2800          CMP      R0, #0
  0x800'027c: 0xd105          BNE.N    ??HAL_UART_Init_7      ; 0x800'028a
  //     huart->Lock = HAL_UNLOCKED;
  0x800'027e: 0x2000          MOVS     R0, #0
  0x800'0280: 0xf884 0x0040   STRB.W   R0, [R4, #0x40]
  //     HAL_UART_MspInit(huart);
  0x800'0284: 0x0020          MOVS     R0, R4
  0x800'0286: 0xf000 0xfd93   BL       HAL_UART_MspInit       ; 0x800'0db0
                ??HAL_UART_Init_7:
  //   huart->gState = HAL_UART_STATE_BUSY;
  0x800'028a: 0x2024          MOVS     R0, #36                ; 0x24
  0x800'028c: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   __HAL_UART_DISABLE(huart);
  0x800'0290: 0x6820          LDR      R0, [R4]
  0x800'0292: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'0294: 0xf431 0x5100   BICS.W   R1, R1, #8192          ; 0x2000
  0x800'0298: 0x6820          LDR      R0, [R4]
  0x800'029a: 0x60c1          STR      R1, [R0, #0xc]
  //   UART_SetConfig(huart);
  0x800'029c: 0x0020          MOVS     R0, R4
  0x800'029e: 0xf000 0xfb71   BL       UART_SetConfig         ; 0x800'0984
  //   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  0x800'02a2: 0x6820          LDR      R0, [R4]
  0x800'02a4: 0x6901          LDR      R1, [R0, #0x10]
  0x800'02a6: 0xf431 0x4190   BICS.W   R1, R1, #18432         ; 0x4800
  0x800'02aa: 0x6820          LDR      R0, [R4]
  0x800'02ac: 0x6101          STR      R1, [R0, #0x10]
  //   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
  0x800'02ae: 0x6820          LDR      R0, [R4]
  0x800'02b0: 0x6941          LDR      R1, [R0, #0x14]
  0x800'02b2: 0xf031 0x012a   BICS.W   R1, R1, #42            ; 0x2a
  0x800'02b6: 0x6820          LDR      R0, [R4]
  0x800'02b8: 0x6141          STR      R1, [R0, #0x14]
  //   __HAL_UART_ENABLE(huart);
  0x800'02ba: 0x6820          LDR      R0, [R4]
  0x800'02bc: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'02be: 0xf451 0x5100   ORRS.W   R1, R1, #8192          ; 0x2000
  0x800'02c2: 0x6820          LDR      R0, [R4]
  0x800'02c4: 0x60c1          STR      R1, [R0, #0xc]
  //   huart->ErrorCode = HAL_UART_ERROR_NONE;
  0x800'02c6: 0x2000          MOVS     R0, #0
  0x800'02c8: 0x6460          STR      R0, [R4, #0x44]
  //   huart->gState = HAL_UART_STATE_READY;
  0x800'02ca: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'02cc: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   huart->RxState = HAL_UART_STATE_READY;
  0x800'02d0: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'02d2: 0xf884 0x0042   STRB.W   R0, [R4, #0x42]
  //   huart->RxEventType = HAL_UART_RXEVENT_TC;
  0x800'02d6: 0x2000          MOVS     R0, #0
  0x800'02d8: 0x6360          STR      R0, [R4, #0x34]
  //   return HAL_OK;
  0x800'02da: 0x2000          MOVS     R0, #0
                ??HAL_UART_Init_1:
  0x800'02dc: 0xbd10          POP      {R4, PC}
                `.text_8`:
                HAL_UART_Transmit:
  // HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
  // {
  0x800'02de: 0xe92d 0x47fc   PUSH.W   {R2-R10, LR}
  0x800'02e2: 0x4681          MOV      R9, R0
  0x800'02e4: 0x000d          MOVS     R5, R1
  0x800'02e6: 0x0016          MOVS     R6, R2
  0x800'02e8: 0x001f          MOVS     R7, R3
  //   uint32_t tickstart = 0U;
  0x800'02ea: 0x2400          MOVS     R4, #0
  //   if (huart->gState == HAL_UART_STATE_READY)
  0x800'02ec: 0xf899 0x0041   LDRB.W   R0, [R9, #0x41]
  0x800'02f0: 0x2820          CMP      R0, #32                ; 0x20
  0x800'02f2: 0xd15f          BNE.N    ??HAL_UART_Transmit_0  ; 0x800'03b4
  //     if ((pData == NULL) || (Size == 0U))
  0x800'02f4: 0x2d00          CMP      R5, #0
  0x800'02f6: 0xd003          BEQ.N    ??HAL_UART_Transmit_1  ; 0x800'0300
  0x800'02f8: 0x0030          MOVS     R0, R6
  0x800'02fa: 0xb280          UXTH     R0, R0
  0x800'02fc: 0x2800          CMP      R0, #0
  0x800'02fe: 0xd101          BNE.N    ??HAL_UART_Transmit_2  ; 0x800'0304
                ??HAL_UART_Transmit_1:
  //       return  HAL_ERROR;
  0x800'0300: 0x2001          MOVS     R0, #1
  0x800'0302: 0xe058          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_2:
  //     huart->ErrorCode = HAL_UART_ERROR_NONE;
  0x800'0304: 0x2000          MOVS     R0, #0
  0x800'0306: 0xf8c9 0x0044   STR.W    R0, [R9, #0x44]
  //     huart->gState = HAL_UART_STATE_BUSY_TX;
  0x800'030a: 0x2021          MOVS     R0, #33                ; 0x21
  0x800'030c: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //     tickstart = HAL_GetTick();
  0x800'0310: 0xf000 0xfd96   BL       HAL_GetTick            ; 0x800'0e40
  0x800'0314: 0x4680          MOV      R8, R0
  //     huart->TxXferSize = Size;
  0x800'0316: 0xf8a9 0x6024   STRH.W   R6, [R9, #0x24]
  //     huart->TxXferCount = Size;
  0x800'031a: 0xf8a9 0x6026   STRH.W   R6, [R9, #0x26]
  //     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  0x800'031e: 0xf8d9 0x0008   LDR.W    R0, [R9, #0x8]
  0x800'0322: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'0326: 0xd106          BNE.N    ??HAL_UART_Transmit_4  ; 0x800'0336
  0x800'0328: 0xf8d9 0x0010   LDR.W    R0, [R9, #0x10]
  0x800'032c: 0x2800          CMP      R0, #0
  0x800'032e: 0xd102          BNE.N    ??HAL_UART_Transmit_4  ; 0x800'0336
  //       pdata8bits  = NULL;
  0x800'0330: 0x2400          MOVS     R4, #0
  //       pdata16bits = (const uint16_t *) pData;
  0x800'0332: 0x46aa          MOV      R10, R5
  0x800'0334: 0xe002          B.N      ??HAL_UART_Transmit_5  ; 0x800'033c
                ??HAL_UART_Transmit_4:
  //       pdata8bits  = pData;
  0x800'0336: 0x002c          MOVS     R4, R5
  //       pdata16bits = NULL;
  0x800'0338: 0xf05f 0x0a00   MOVS.W   R10, #0
                ??HAL_UART_Transmit_5:
  //     while (huart->TxXferCount > 0U)
  0x800'033c: 0xf8b9 0x0026   LDRH.W   R0, [R9, #0x26]
  0x800'0340: 0x2800          CMP      R0, #0
  0x800'0342: 0xd024          BEQ.N    ??HAL_UART_Transmit_6  ; 0x800'038e
  //       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
  0x800'0344: 0x9700          STR      R7, [SP]
  0x800'0346: 0x4643          MOV      R3, R8
  0x800'0348: 0x2200          MOVS     R2, #0
  0x800'034a: 0x2180          MOVS     R1, #128               ; 0x80
  0x800'034c: 0x4648          MOV      R0, R9
  0x800'034e: 0xf000 0xf9d3   BL       UART_WaitOnFlagUntilTimeout
                                                              ; 0x800'06f8
  0x800'0352: 0x2800          CMP      R0, #0
  0x800'0354: 0xd004          BEQ.N    ??HAL_UART_Transmit_7  ; 0x800'0360
  //         huart->gState = HAL_UART_STATE_READY;
  0x800'0356: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0358: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //         return HAL_TIMEOUT;
  0x800'035c: 0x2003          MOVS     R0, #3
  0x800'035e: 0xe02a          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_7:
  //       if (pdata8bits == NULL)
  0x800'0360: 0x2c00          CMP      R4, #0
  0x800'0362: 0xd109          BNE.N    ??HAL_UART_Transmit_8  ; 0x800'0378
  //         huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
  0x800'0364: 0xf8ba 0x1000   LDRH.W   R1, [R10]
  0x800'0368: 0x05c9          LSLS     R1, R1, #23
  0x800'036a: 0x0dc9          LSRS     R1, R1, #23
  0x800'036c: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'0370: 0x6041          STR      R1, [R0, #0x4]
  //         pdata16bits++;
  0x800'0372: 0xf11a 0x0a02   ADDS.W   R10, R10, #2
  0x800'0376: 0xe004          B.N      ??HAL_UART_Transmit_9  ; 0x800'0382
                ??HAL_UART_Transmit_8:
  //         huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
  0x800'0378: 0x7821          LDRB     R1, [R4]
  0x800'037a: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'037e: 0x6041          STR      R1, [R0, #0x4]
  //         pdata8bits++;
  0x800'0380: 0x1c64          ADDS     R4, R4, #1
                ??HAL_UART_Transmit_9:
  //       huart->TxXferCount--;
  0x800'0382: 0xf8b9 0x0026   LDRH.W   R0, [R9, #0x26]
  0x800'0386: 0x1e40          SUBS     R0, R0, #1
  0x800'0388: 0xf8a9 0x0026   STRH.W   R0, [R9, #0x26]
  0x800'038c: 0xe7d6          B.N      ??HAL_UART_Transmit_5  ; 0x800'033c
                ??HAL_UART_Transmit_6:
  //     if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
  0x800'038e: 0x9700          STR      R7, [SP]
  0x800'0390: 0x4643          MOV      R3, R8
  0x800'0392: 0x2200          MOVS     R2, #0
  0x800'0394: 0x2140          MOVS     R1, #64                ; 0x40
  0x800'0396: 0x4648          MOV      R0, R9
  0x800'0398: 0xf000 0xf9ae   BL       UART_WaitOnFlagUntilTimeout
                                                              ; 0x800'06f8
  0x800'039c: 0x2800          CMP      R0, #0
  0x800'039e: 0xd004          BEQ.N    ??HAL_UART_Transmit_10 ; 0x800'03aa
  //       huart->gState = HAL_UART_STATE_READY;
  0x800'03a0: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'03a2: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //       return HAL_TIMEOUT;
  0x800'03a6: 0x2003          MOVS     R0, #3
  0x800'03a8: 0xe005          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_10:
  //     huart->gState = HAL_UART_STATE_READY;
  0x800'03aa: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'03ac: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //     return HAL_OK;
  0x800'03b0: 0x2000          MOVS     R0, #0
  0x800'03b2: 0xe000          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_0:
  //     return HAL_BUSY;
  0x800'03b4: 0x2002          MOVS     R0, #2
                ??HAL_UART_Transmit_3:
  0x800'03b6: 0xe8bd 0x87f6   POP.W    {R1, R2, R4-R10, PC}
  0x800'03ba: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable5:
  0x800'03bc: 0x4001'1000     DC32     0x4001'1000            ; '...@'
                ??DataTable5_1:
  0x800'03c0: 0x4000'4400     DC32     0x4000'4400            ; '.D.@'
                ??DataTable5_2:
  0x800'03c4: 0x4000'4800     DC32     0x4000'4800            ; '.H.@'
                ??DataTable5_3:
  0x800'03c8: 0x4001'1400     DC32     0x4001'1400            ; '...@'
                ??DataTable5_4:
  0x800'03cc: 0x0800'3d94     DC32     ?_0
                ??DataTable5_5:
  0x800'03d0: 0x4000'4c00     DC32     0x4000'4c00            ; '.L.@'
                ??DataTable5_6:
  0x800'03d4: 0x4000'5000     DC32     0x4000'5000            ; '.P.@'
                $t:
                `.text_37`:
                HAL_UART_IRQHandler:
  // void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
  // {
  0x800'03d8: 0xe92d 0x47fc   PUSH.W   {R2-R10, LR}
  0x800'03dc: 0x4682          MOV      R10, R0
  //   uint32_t isrflags   = READ_REG(huart->Instance->SR);
  0x800'03de: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'03e2: 0x6806          LDR      R6, [R0]
  //   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
  0x800'03e4: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'03e8: 0x68c7          LDR      R7, [R0, #0xc]
  //   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
  0x800'03ea: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'03ee: 0xf8d0 0x8014   LDR.W    R8, [R0, #0x14]
  //   uint32_t errorflags = 0x00U;
  0x800'03f2: 0x2000          MOVS     R0, #0
  //   uint32_t dmarequest = 0x00U;
  0x800'03f4: 0x2500          MOVS     R5, #0
  //   errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  0x800'03f6: 0xf016 0x040f   ANDS.W   R4, R6, #15            ; 0xf
  //   if (errorflags == RESET)
  0x800'03fa: 0x2c00          CMP      R4, #0
  0x800'03fc: 0xd107          BNE.N    ??HAL_UART_IRQHandler_0
                                                              ; 0x800'040e
  //     if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
  0x800'03fe: 0x06b0          LSLS     R0, R6, #26
  0x800'0400: 0xd505          BPL.N    ??HAL_UART_IRQHandler_0
                                                              ; 0x800'040e
  0x800'0402: 0x06b8          LSLS     R0, R7, #26
  0x800'0404: 0xd503          BPL.N    ??HAL_UART_IRQHandler_0
                                                              ; 0x800'040e
  //       UART_Receive_IT(huart);
  0x800'0406: 0x4650          MOV      R0, R10
  0x800'0408: 0xf000 0xfa41   BL       UART_Receive_IT        ; 0x800'088e
  //       return;
  0x800'040c: 0xe172          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_0:
  //   if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
  //                                 || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
  0x800'040e: 0x2c00          CMP      R4, #0
  0x800'0410: 0xf000 0x808a   BEQ.W    ??HAL_UART_IRQHandler_2
                                                              ; 0x800'0528
  0x800'0414: 0xea5f 0x70c8   LSLS.W   R0, R8, #31
  0x800'0418: 0xd403          BMI.N    ??HAL_UART_IRQHandler_3
                                                              ; 0x800'0422
  0x800'041a: 0xf417 0x7f90   TST.W    R7, #288               ; 0x120
  0x800'041e: 0xf000 0x8083   BEQ.W    ??HAL_UART_IRQHandler_2
                                                              ; 0x800'0528
                ??HAL_UART_IRQHandler_3:
  //     if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
  0x800'0422: 0x0030          MOVS     R0, R6
  0x800'0424: 0x07c0          LSLS     R0, R0, #31
  0x800'0426: 0xd507          BPL.N    ??HAL_UART_IRQHandler_4
                                                              ; 0x800'0438
  0x800'0428: 0x05f8          LSLS     R0, R7, #23
  0x800'042a: 0xd505          BPL.N    ??HAL_UART_IRQHandler_4
                                                              ; 0x800'0438
  //       huart->ErrorCode |= HAL_UART_ERROR_PE;
  0x800'042c: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0430: 0xf050 0x0001   ORRS.W   R0, R0, #1
  0x800'0434: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_4:
  //     if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
  0x800'0438: 0x0770          LSLS     R0, R6, #29
  0x800'043a: 0xd508          BPL.N    ??HAL_UART_IRQHandler_5
                                                              ; 0x800'044e
  0x800'043c: 0x4640          MOV      R0, R8
  0x800'043e: 0x07c0          LSLS     R0, R0, #31
  0x800'0440: 0xd505          BPL.N    ??HAL_UART_IRQHandler_5
                                                              ; 0x800'044e
  //       huart->ErrorCode |= HAL_UART_ERROR_NE;
  0x800'0442: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0446: 0xf050 0x0002   ORRS.W   R0, R0, #2
  0x800'044a: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_5:
  //     if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
  0x800'044e: 0x07b0          LSLS     R0, R6, #30
  0x800'0450: 0xd508          BPL.N    ??HAL_UART_IRQHandler_6
                                                              ; 0x800'0464
  0x800'0452: 0x4640          MOV      R0, R8
  0x800'0454: 0x07c0          LSLS     R0, R0, #31
  0x800'0456: 0xd505          BPL.N    ??HAL_UART_IRQHandler_6
                                                              ; 0x800'0464
  //       huart->ErrorCode |= HAL_UART_ERROR_FE;
  0x800'0458: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'045c: 0xf050 0x0004   ORRS.W   R0, R0, #4
  0x800'0460: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_6:
  //     if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
  //                                                  || ((cr3its & USART_CR3_EIE) != RESET)))
  0x800'0464: 0x0730          LSLS     R0, R6, #28
  0x800'0466: 0xd50a          BPL.N    ??HAL_UART_IRQHandler_7
                                                              ; 0x800'047e
  0x800'0468: 0x06b8          LSLS     R0, R7, #26
  0x800'046a: 0xd402          BMI.N    ??HAL_UART_IRQHandler_8
                                                              ; 0x800'0472
  0x800'046c: 0x4640          MOV      R0, R8
  0x800'046e: 0x07c0          LSLS     R0, R0, #31
  0x800'0470: 0xd505          BPL.N    ??HAL_UART_IRQHandler_7
                                                              ; 0x800'047e
                ??HAL_UART_IRQHandler_8:
  //       huart->ErrorCode |= HAL_UART_ERROR_ORE;
  0x800'0472: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0476: 0xf050 0x0008   ORRS.W   R0, R0, #8
  0x800'047a: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_7:
  //     if (huart->ErrorCode != HAL_UART_ERROR_NONE)
  0x800'047e: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0482: 0x2800          CMP      R0, #0
  0x800'0484: 0xd04f          BEQ.N    ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
  //       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
  0x800'0486: 0x06b0          LSLS     R0, R6, #26
  0x800'0488: 0xd504          BPL.N    ??HAL_UART_IRQHandler_10
                                                              ; 0x800'0494
  0x800'048a: 0x06b8          LSLS     R0, R7, #26
  0x800'048c: 0xd502          BPL.N    ??HAL_UART_IRQHandler_10
                                                              ; 0x800'0494
  //         UART_Receive_IT(huart);
  0x800'048e: 0x4650          MOV      R0, R10
  0x800'0490: 0xf000 0xf9fd   BL       UART_Receive_IT        ; 0x800'088e
                ??HAL_UART_IRQHandler_10:
  //       dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'0494: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0498: 0x6940          LDR      R0, [R0, #0x14]
  0x800'049a: 0x0980          LSRS     R0, R0, #6
  0x800'049c: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'04a0: 0x0005          MOVS     R5, R0
  //       if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
  0x800'04a2: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'04a6: 0x0700          LSLS     R0, R0, #28
  0x800'04a8: 0xd401          BMI.N    ??HAL_UART_IRQHandler_11
                                                              ; 0x800'04ae
  0x800'04aa: 0x2d00          CMP      R5, #0
  0x800'04ac: 0xd035          BEQ.N    ??HAL_UART_IRQHandler_12
                                                              ; 0x800'051a
                ??HAL_UART_IRQHandler_11:
  //         UART_EndRxTransfer(huart);
  0x800'04ae: 0x4650          MOV      R0, R10
  0x800'04b0: 0xf000 0xf969   BL       UART_EndRxTransfer     ; 0x800'0786
  //         if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  0x800'04b4: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'04b8: 0x6940          LDR      R0, [R0, #0x14]
  0x800'04ba: 0x0640          LSLS     R0, R0, #25
  0x800'04bc: 0xd529          BPL.N    ??HAL_UART_IRQHandler_13
                                                              ; 0x800'0512
                ??HAL_UART_IRQHandler_14:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'04be: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'04c2: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'04c4: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'04c8: 0xf030 0x0040   BICS.W   R0, R0, #64            ; 0x40
  0x800'04cc: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'04ce: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'04d2: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'04d6: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'04da: 0x2800          CMP      R0, #0
  0x800'04dc: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_14
                                                              ; 0x800'04be
  //           if (huart->hdmarx != NULL)
  0x800'04de: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'04e2: 0x2800          CMP      R0, #0
  0x800'04e4: 0xd011          BEQ.N    ??HAL_UART_IRQHandler_15
                                                              ; 0x800'050a
  //             huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
  0x800'04e6: 0xf20f 0x3109   ADR.W    R1, UART_DMAAbortOnError
                                                              ; 0x800'07f1
  0x800'04ea: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'04ee: 0x6501          STR      R1, [R0, #0x50]
  //             if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
  0x800'04f0: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'04f4: 0xf000 0xfcf8   BL       HAL_DMA_Abort_IT       ; 0x800'0ee8
  0x800'04f8: 0x2800          CMP      R0, #0
  0x800'04fa: 0xd014          BEQ.N    ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
  //               huart->hdmarx->XferAbortCallback(huart->hdmarx);
  0x800'04fc: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'0500: 0xf8da 0x103c   LDR.W    R1, [R10, #0x3c]
  0x800'0504: 0x6d09          LDR      R1, [R1, #0x50]
  0x800'0506: 0x4788          BLX      R1
  0x800'0508: 0xe00d          B.N      ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
                ??HAL_UART_IRQHandler_15:
  //             HAL_UART_ErrorCallback(huart);
  0x800'050a: 0x4650          MOV      R0, R10
  0x800'050c: 0xf000 0xfd00   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  0x800'0510: 0xe009          B.N      ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
                ??HAL_UART_IRQHandler_13:
  //           HAL_UART_ErrorCallback(huart);
  0x800'0512: 0x4650          MOV      R0, R10
  0x800'0514: 0xf000 0xfcfc   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  0x800'0518: 0xe005          B.N      ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
                ??HAL_UART_IRQHandler_12:
  //         HAL_UART_ErrorCallback(huart);
  0x800'051a: 0x4650          MOV      R0, R10
  0x800'051c: 0xf000 0xfcf8   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  //         huart->ErrorCode = HAL_UART_ERROR_NONE;
  0x800'0520: 0x2000          MOVS     R0, #0
  0x800'0522: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_9:
  //     return;
  0x800'0526: 0xe0e5          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_2:
  //   if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  //       && ((isrflags & USART_SR_IDLE) != 0U)
  //       && ((cr1its & USART_SR_IDLE) != 0U))
  0x800'0528: 0xf8da 0x0030   LDR.W    R0, [R10, #0x30]
  0x800'052c: 0x2801          CMP      R0, #1
  0x800'052e: 0xf040 0x80d1   BNE.W    ??HAL_UART_IRQHandler_16
                                                              ; 0x800'06d4
  0x800'0532: 0x06f0          LSLS     R0, R6, #27
  0x800'0534: 0xf140 0x80ce   BPL.W    ??HAL_UART_IRQHandler_16
                                                              ; 0x800'06d4
  0x800'0538: 0x06f8          LSLS     R0, R7, #27
  0x800'053a: 0xf140 0x80cb   BPL.W    ??HAL_UART_IRQHandler_16
                                                              ; 0x800'06d4
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'053e: 0x2000          MOVS     R0, #0
  0x800'0540: 0x9000          STR      R0, [SP]
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0542: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0546: 0x6800          LDR      R0, [R0]
  0x800'0548: 0x9000          STR      R0, [SP]
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'054a: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'054e: 0x6840          LDR      R0, [R0, #0x4]
  0x800'0550: 0x9000          STR      R0, [SP]
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0552: 0x9800          LDR      R0, [SP]
  //     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  0x800'0554: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0558: 0x6940          LDR      R0, [R0, #0x14]
  0x800'055a: 0x0640          LSLS     R0, R0, #25
  0x800'055c: 0xd56d          BPL.N    ??HAL_UART_IRQHandler_17
                                                              ; 0x800'063a
  //       uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
  0x800'055e: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'0562: 0x6800          LDR      R0, [R0]
  0x800'0564: 0xf8d0 0x9004   LDR.W    R9, [R0, #0x4]
  //       if ((nb_remaining_rx_data > 0U)
  //           && (nb_remaining_rx_data < huart->RxXferSize))
  0x800'0568: 0x4648          MOV      R0, R9
  0x800'056a: 0xb280          UXTH     R0, R0
  0x800'056c: 0x2800          CMP      R0, #0
  0x800'056e: 0xd063          BEQ.N    ??HAL_UART_IRQHandler_18
                                                              ; 0x800'0638
  0x800'0570: 0x4649          MOV      R1, R9
  0x800'0572: 0xf8ba 0x002c   LDRH.W   R0, [R10, #0x2c]
  0x800'0576: 0xb289          UXTH     R1, R1
  0x800'0578: 0x4281          CMP      R1, R0
  0x800'057a: 0xd25d          BCS.N    ??HAL_UART_IRQHandler_18
                                                              ; 0x800'0638
  //         huart->RxXferCount = nb_remaining_rx_data;
  0x800'057c: 0xf8aa 0x902e   STRH.W   R9, [R10, #0x2e]
  //         if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
  0x800'0580: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'0584: 0x69c0          LDR      R0, [R0, #0x1c]
  0x800'0586: 0xf5b0 0x7f80   CMP.W    R0, #256               ; 0x100
  0x800'058a: 0xd049          BEQ.N    ??HAL_UART_IRQHandler_19
                                                              ; 0x800'0620
                ??HAL_UART_IRQHandler_20:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  0x800'058c: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0590: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'0592: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0596: 0xf430 0x7080   BICS.W   R0, R0, #256           ; 0x100
  0x800'059a: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  0x800'059c: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05a0: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'05a4: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'05a8: 0x2800          CMP      R0, #0
  0x800'05aa: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_20
                                                              ; 0x800'058c
                ??HAL_UART_IRQHandler_21:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'05ac: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05b0: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'05b2: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'05b6: 0x0840          LSRS     R0, R0, #1
  0x800'05b8: 0x0040          LSLS     R0, R0, #1
  0x800'05ba: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'05bc: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05c0: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'05c4: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'05c8: 0x2800          CMP      R0, #0
  0x800'05ca: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_21
                                                              ; 0x800'05ac
                ??HAL_UART_IRQHandler_22:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'05cc: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05d0: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'05d2: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'05d6: 0xf030 0x0040   BICS.W   R0, R0, #64            ; 0x40
  0x800'05da: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'05dc: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05e0: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'05e4: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'05e8: 0x2800          CMP      R0, #0
  0x800'05ea: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_22
                                                              ; 0x800'05cc
  //           huart->RxState = HAL_UART_STATE_READY;
  0x800'05ec: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'05ee: 0xf88a 0x0042   STRB.W   R0, [R10, #0x42]
  //           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'05f2: 0x2000          MOVS     R0, #0
  0x800'05f4: 0xf8ca 0x0030   STR.W    R0, [R10, #0x30]
                ??HAL_UART_IRQHandler_23:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'05f8: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05fc: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'05fe: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0602: 0xf030 0x0010   BICS.W   R0, R0, #16            ; 0x10
  0x800'0606: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'0608: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'060c: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'0610: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'0614: 0x2800          CMP      R0, #0
  0x800'0616: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_23
                                                              ; 0x800'05f8
  //           (void)HAL_DMA_Abort(huart->hdmarx);
  0x800'0618: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'061c: 0xf000 0xfc16   BL       HAL_DMA_Abort          ; 0x800'0e4c
                ??HAL_UART_IRQHandler_19:
  //         huart->RxEventType = HAL_UART_RXEVENT_IDLE;
  0x800'0620: 0x2002          MOVS     R0, #2
  0x800'0622: 0xf8ca 0x0034   STR.W    R0, [R10, #0x34]
  //         HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
  0x800'0626: 0xf8ba 0x102c   LDRH.W   R1, [R10, #0x2c]
  0x800'062a: 0xf8ba 0x002e   LDRH.W   R0, [R10, #0x2e]
  0x800'062e: 0x1a09          SUBS     R1, R1, R0
  0x800'0630: 0xb289          UXTH     R1, R1
  0x800'0632: 0x4650          MOV      R0, R10
  0x800'0634: 0xf000 0xfc6d   BL       HAL_UARTEx_RxEventCallback
                                                              ; 0x800'0f12
                ??HAL_UART_IRQHandler_18:
  //       return;
  0x800'0638: 0xe05c          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_17:
  //       uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
  0x800'063a: 0xf8ba 0x902c   LDRH.W   R9, [R10, #0x2c]
  0x800'063e: 0xf8ba 0x002e   LDRH.W   R0, [R10, #0x2e]
  0x800'0642: 0xebb9 0x0900   SUBS.W   R9, R9, R0
  //       if ((huart->RxXferCount > 0U)
  //           && (nb_rx_data > 0U))
  0x800'0646: 0xf8ba 0x002e   LDRH.W   R0, [R10, #0x2e]
  0x800'064a: 0x2800          CMP      R0, #0
  0x800'064c: 0xd041          BEQ.N    ??HAL_UART_IRQHandler_24
                                                              ; 0x800'06d2
  0x800'064e: 0x4648          MOV      R0, R9
  0x800'0650: 0xb280          UXTH     R0, R0
  0x800'0652: 0x2800          CMP      R0, #0
  0x800'0654: 0xd03d          BEQ.N    ??HAL_UART_IRQHandler_24
                                                              ; 0x800'06d2
                ??HAL_UART_IRQHandler_25:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0656: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'065a: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'065c: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0660: 0xf430 0x7090   BICS.W   R0, R0, #288           ; 0x120
  0x800'0664: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0666: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'066a: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'066e: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'0672: 0x2800          CMP      R0, #0
  0x800'0674: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_25
                                                              ; 0x800'0656
                ??HAL_UART_IRQHandler_26:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'0676: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'067a: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'067c: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0680: 0x0840          LSRS     R0, R0, #1
  0x800'0682: 0x0040          LSLS     R0, R0, #1
  0x800'0684: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'0686: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'068a: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'068e: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'0692: 0x2800          CMP      R0, #0
  0x800'0694: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_26
                                                              ; 0x800'0676
  //         huart->RxState = HAL_UART_STATE_READY;
  0x800'0696: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0698: 0xf88a 0x0042   STRB.W   R0, [R10, #0x42]
  //         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'069c: 0x2000          MOVS     R0, #0
  0x800'069e: 0xf8ca 0x0030   STR.W    R0, [R10, #0x30]
                ??HAL_UART_IRQHandler_27:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'06a2: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'06a6: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'06a8: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'06ac: 0xf030 0x0010   BICS.W   R0, R0, #16            ; 0x10
  0x800'06b0: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'06b2: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'06b6: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'06ba: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'06be: 0x2800          CMP      R0, #0
  0x800'06c0: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_27
                                                              ; 0x800'06a2
  //         huart->RxEventType = HAL_UART_RXEVENT_IDLE;
  0x800'06c2: 0x2002          MOVS     R0, #2
  0x800'06c4: 0xf8ca 0x0034   STR.W    R0, [R10, #0x34]
  //         HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
  0x800'06c8: 0x4649          MOV      R1, R9
  0x800'06ca: 0xb289          UXTH     R1, R1
  0x800'06cc: 0x4650          MOV      R0, R10
  0x800'06ce: 0xf000 0xfc20   BL       HAL_UARTEx_RxEventCallback
                                                              ; 0x800'0f12
                ??HAL_UART_IRQHandler_24:
  //       return;
  0x800'06d2: 0xe00f          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_16:
  //   if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
  0x800'06d4: 0x0630          LSLS     R0, R6, #24
  0x800'06d6: 0xd505          BPL.N    ??HAL_UART_IRQHandler_28
                                                              ; 0x800'06e4
  0x800'06d8: 0x0638          LSLS     R0, R7, #24
  0x800'06da: 0xd503          BPL.N    ??HAL_UART_IRQHandler_28
                                                              ; 0x800'06e4
  //     UART_Transmit_IT(huart);
  0x800'06dc: 0x4650          MOV      R0, R10
  0x800'06de: 0xf000 0xf893   BL       UART_Transmit_IT       ; 0x800'0808
  //     return;
  0x800'06e2: 0xe007          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_28:
  //   if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  0x800'06e4: 0x0670          LSLS     R0, R6, #25
  0x800'06e6: 0xd505          BPL.N    ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
  0x800'06e8: 0x0678          LSLS     R0, R7, #25
  0x800'06ea: 0xd503          BPL.N    ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
  //     UART_EndTransmit_IT(huart);
  0x800'06ec: 0x4650          MOV      R0, R10
  0x800'06ee: 0xf000 0xf8be   BL       UART_EndTransmit_IT    ; 0x800'086e
  //     return;
  0x800'06f2: 0xe7ff          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_1:
                ??HAL_UART_IRQHandler_29:
  // }
  0x800'06f4: 0xe8bd 0x87f3   POP.W    {R0, R1, R4-R10, PC}
                `.text_50`:
                UART_WaitOnFlagUntilTimeout:
  // static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
  //                                                      uint32_t Tickstart, uint32_t Timeout)
  // {
  0x800'06f8: 0xe92d 0x41fc   PUSH.W   {R2-R8, LR}
  0x800'06fc: 0x4680          MOV      R8, R0
  0x800'06fe: 0x000d          MOVS     R5, R1
  0x800'0700: 0x0016          MOVS     R6, R2
  0x800'0702: 0x001f          MOVS     R7, R3
  0x800'0704: 0x9c08          LDR      R4, [SP, #0x20]
                ??UART_WaitOnFlagUntilTimeout_0:
  //   while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  0x800'0706: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'070a: 0x6800          LDR      R0, [R0]
  0x800'070c: 0x4028          ANDS     R0, R0, R5
  0x800'070e: 0x42a8          CMP      R0, R5
  0x800'0710: 0xd101          BNE.N    ??UART_WaitOnFlagUntilTimeout_1
                                                              ; 0x800'0716
  0x800'0712: 0x2101          MOVS     R1, #1
  0x800'0714: 0xe000          B.N      ??UART_WaitOnFlagUntilTimeout_2
                                                              ; 0x800'0718
                ??UART_WaitOnFlagUntilTimeout_1:
  0x800'0716: 0x2100          MOVS     R1, #0
                ??UART_WaitOnFlagUntilTimeout_2:
  0x800'0718: 0x0030          MOVS     R0, R6
  0x800'071a: 0xb2c0          UXTB     R0, R0
  0x800'071c: 0x4281          CMP      R1, R0
  0x800'071e: 0xd12f          BNE.N    ??UART_WaitOnFlagUntilTimeout_3
                                                              ; 0x800'0780
  //     if (Timeout != HAL_MAX_DELAY)
  0x800'0720: 0xf114 0x0f01   CMN.W    R4, #1
  0x800'0724: 0xd0ef          BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  //       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
  0x800'0726: 0xf000 0xfb8b   BL       HAL_GetTick            ; 0x800'0e40
  0x800'072a: 0x1bc0          SUBS     R0, R0, R7
  0x800'072c: 0x4284          CMP      R4, R0
  0x800'072e: 0xd301          BCC.N    ??UART_WaitOnFlagUntilTimeout_4
                                                              ; 0x800'0734
  0x800'0730: 0x2c00          CMP      R4, #0
  0x800'0732: 0xd101          BNE.N    ??UART_WaitOnFlagUntilTimeout_5
                                                              ; 0x800'0738
                ??UART_WaitOnFlagUntilTimeout_4:
  //         return HAL_TIMEOUT;
  0x800'0734: 0x2003          MOVS     R0, #3
  0x800'0736: 0xe024          B.N      ??UART_WaitOnFlagUntilTimeout_6
                                                              ; 0x800'0782
                ??UART_WaitOnFlagUntilTimeout_5:
  //       if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
  0x800'0738: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'073c: 0x68c0          LDR      R0, [R0, #0xc]
  0x800'073e: 0x0740          LSLS     R0, R0, #29
  0x800'0740: 0xd5e1          BPL.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  0x800'0742: 0x2d80          CMP      R5, #128               ; 0x80
  0x800'0744: 0xd0df          BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  0x800'0746: 0x2d40          CMP      R5, #64                ; 0x40
  0x800'0748: 0xd0dd          BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  //         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
  0x800'074a: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'074e: 0x6800          LDR      R0, [R0]
  0x800'0750: 0x0700          LSLS     R0, R0, #28
  0x800'0752: 0xd5d8          BPL.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0754: 0x2000          MOVS     R0, #0
  0x800'0756: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0758: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'075c: 0x6800          LDR      R0, [R0]
  0x800'075e: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0760: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'0764: 0x6840          LDR      R0, [R0, #0x4]
  0x800'0766: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0768: 0x9800          LDR      R0, [SP]
  //           UART_EndRxTransfer(huart);
  0x800'076a: 0x4640          MOV      R0, R8
  0x800'076c: 0xf000 0xf80b   BL       UART_EndRxTransfer     ; 0x800'0786
  //           huart->ErrorCode = HAL_UART_ERROR_ORE;
  0x800'0770: 0x2008          MOVS     R0, #8
  0x800'0772: 0xf8c8 0x0044   STR.W    R0, [R8, #0x44]
  //           __HAL_UNLOCK(huart);
  0x800'0776: 0x2000          MOVS     R0, #0
  0x800'0778: 0xf888 0x0040   STRB.W   R0, [R8, #0x40]
  //           return HAL_ERROR;
  0x800'077c: 0x2001          MOVS     R0, #1
  0x800'077e: 0xe000          B.N      ??UART_WaitOnFlagUntilTimeout_6
                                                              ; 0x800'0782
                ??UART_WaitOnFlagUntilTimeout_3:
  //   return HAL_OK;
  0x800'0780: 0x2000          MOVS     R0, #0
                ??UART_WaitOnFlagUntilTimeout_6:
  0x800'0782: 0xe8bd 0x81f6   POP.W    {R1, R2, R4-R8, PC}
                `.text_54`:
                ??UART_EndRxTransfer_0:
                UART_EndRxTransfer:
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0786: 0x6801          LDR      R1, [R0]
  0x800'0788: 0x310c          ADDS     R1, R1, #12            ; 0xc
  0x800'078a: 0xe851 0x1f00   LDREX    R1, [R1]
  0x800'078e: 0xf431 0x7190   BICS.W   R1, R1, #288           ; 0x120
  0x800'0792: 0x000a          MOVS     R2, R1
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0794: 0x6801          LDR      R1, [R0]
  0x800'0796: 0xf111 0x030c   ADDS.W   R3, R1, #12            ; 0xc
  0x800'079a: 0xe843 0x2100   STREX    R1, R2, [R3]
  0x800'079e: 0x2900          CMP      R1, #0
  0x800'07a0: 0xd1f1          BNE.N    UART_EndRxTransfer     ; 0x800'0786
                ??UART_EndRxTransfer_1:
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'07a2: 0x6801          LDR      R1, [R0]
  0x800'07a4: 0x3114          ADDS     R1, R1, #20            ; 0x14
  0x800'07a6: 0xe851 0x1f00   LDREX    R1, [R1]
  0x800'07aa: 0x0849          LSRS     R1, R1, #1
  0x800'07ac: 0x0049          LSLS     R1, R1, #1
  0x800'07ae: 0x000a          MOVS     R2, R1
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'07b0: 0x6801          LDR      R1, [R0]
  0x800'07b2: 0xf111 0x0314   ADDS.W   R3, R1, #20            ; 0x14
  0x800'07b6: 0xe843 0x2100   STREX    R1, R2, [R3]
  0x800'07ba: 0x2900          CMP      R1, #0
  0x800'07bc: 0xd1f1          BNE.N    ??UART_EndRxTransfer_1 ; 0x800'07a2
  //   if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  0x800'07be: 0x6b01          LDR      R1, [R0, #0x30]
  0x800'07c0: 0x2901          CMP      R1, #1
  0x800'07c2: 0xd10d          BNE.N    ??UART_EndRxTransfer_2 ; 0x800'07e0
                ??UART_EndRxTransfer_3:
  //     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'07c4: 0x6801          LDR      R1, [R0]
  0x800'07c6: 0x310c          ADDS     R1, R1, #12            ; 0xc
  0x800'07c8: 0xe851 0x1f00   LDREX    R1, [R1]
  0x800'07cc: 0xf031 0x0110   BICS.W   R1, R1, #16            ; 0x10
  0x800'07d0: 0x000a          MOVS     R2, R1
  //     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'07d2: 0x6801          LDR      R1, [R0]
  0x800'07d4: 0xf111 0x030c   ADDS.W   R3, R1, #12            ; 0xc
  0x800'07d8: 0xe843 0x2100   STREX    R1, R2, [R3]
  0x800'07dc: 0x2900          CMP      R1, #0
  0x800'07de: 0xd1f1          BNE.N    ??UART_EndRxTransfer_3 ; 0x800'07c4
                ??UART_EndRxTransfer_2:
  //   huart->RxState = HAL_UART_STATE_READY;
  0x800'07e0: 0x2120          MOVS     R1, #32                ; 0x20
  0x800'07e2: 0xf880 0x1042   STRB.W   R1, [R0, #0x42]
  //   huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'07e6: 0x2100          MOVS     R1, #0
  0x800'07e8: 0x6301          STR      R1, [R0, #0x30]
  // }
  0x800'07ea: 0x4770          BX       LR
  0x800'07ec: 0x0000          MOVS     R0, R0
  0x800'07ee: 0x0000          MOVS     R0, R0
                `.text_55`:
                UART_DMAAbortOnError:
  // static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
  // {
  0x800'07f0: 0xb538          PUSH     {R3-R5, LR}
  0x800'07f2: 0x0004          MOVS     R4, R0
  //   UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
  0x800'07f4: 0x6ba5          LDR      R5, [R4, #0x38]
  //   huart->RxXferCount = 0x00U;
  0x800'07f6: 0x2000          MOVS     R0, #0
  0x800'07f8: 0x85e8          STRH     R0, [R5, #0x2e]
  //   huart->TxXferCount = 0x00U;
  0x800'07fa: 0x2000          MOVS     R0, #0
  0x800'07fc: 0x84e8          STRH     R0, [R5, #0x26]
  //   HAL_UART_ErrorCallback(huart);
  0x800'07fe: 0x0028          MOVS     R0, R5
  0x800'0800: 0xf000 0xfb86   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  // }
  0x800'0804: 0xbd31          POP      {R0, R4, R5, PC}
  0x800'0806: 0x0000          MOVS     R0, R0
                `.text_60`:
                UART_Transmit_IT:
  // static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
  // {
  0x800'0808: 0x0001          MOVS     R1, R0
  //   if (huart->gState == HAL_UART_STATE_BUSY_TX)
  0x800'080a: 0xf891 0x0041   LDRB.W   R0, [R1, #0x41]
  0x800'080e: 0x2821          CMP      R0, #33                ; 0x21
  0x800'0810: 0xd12b          BNE.N    ??UART_Transmit_IT_0   ; 0x800'086a
  //     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  0x800'0812: 0x6888          LDR      R0, [R1, #0x8]
  0x800'0814: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'0818: 0xd10d          BNE.N    ??UART_Transmit_IT_1   ; 0x800'0836
  0x800'081a: 0x6908          LDR      R0, [R1, #0x10]
  0x800'081c: 0x2800          CMP      R0, #0
  0x800'081e: 0xd10a          BNE.N    ??UART_Transmit_IT_1   ; 0x800'0836
  //       tmp = (const uint16_t *) huart->pTxBuffPtr;
  0x800'0820: 0x6a08          LDR      R0, [R1, #0x20]
  0x800'0822: 0x0002          MOVS     R2, R0
  //       huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
  0x800'0824: 0x8813          LDRH     R3, [R2]
  0x800'0826: 0x05db          LSLS     R3, R3, #23
  0x800'0828: 0x0ddb          LSRS     R3, R3, #23
  0x800'082a: 0x6808          LDR      R0, [R1]
  0x800'082c: 0x6043          STR      R3, [R0, #0x4]
  //       huart->pTxBuffPtr += 2U;
  0x800'082e: 0x6a08          LDR      R0, [R1, #0x20]
  0x800'0830: 0x1c80          ADDS     R0, R0, #2
  0x800'0832: 0x6208          STR      R0, [R1, #0x20]
  0x800'0834: 0xe005          B.N      ??UART_Transmit_IT_2   ; 0x800'0842
                ??UART_Transmit_IT_1:
  //       huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
  0x800'0836: 0x6a0b          LDR      R3, [R1, #0x20]
  0x800'0838: 0x1c58          ADDS     R0, R3, #1
  0x800'083a: 0x6208          STR      R0, [R1, #0x20]
  0x800'083c: 0x781b          LDRB     R3, [R3]
  0x800'083e: 0x6808          LDR      R0, [R1]
  0x800'0840: 0x6043          STR      R3, [R0, #0x4]
                ??UART_Transmit_IT_2:
  //     if (--huart->TxXferCount == 0U)
  0x800'0842: 0x8cc8          LDRH     R0, [R1, #0x26]
  0x800'0844: 0x1e40          SUBS     R0, R0, #1
  0x800'0846: 0x84c8          STRH     R0, [R1, #0x26]
  0x800'0848: 0xb280          UXTH     R0, R0
  0x800'084a: 0x2800          CMP      R0, #0
  0x800'084c: 0xd10b          BNE.N    ??UART_Transmit_IT_3   ; 0x800'0866
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
  0x800'084e: 0x6808          LDR      R0, [R1]
  0x800'0850: 0x68c3          LDR      R3, [R0, #0xc]
  0x800'0852: 0xf033 0x0380   BICS.W   R3, R3, #128           ; 0x80
  0x800'0856: 0x6808          LDR      R0, [R1]
  0x800'0858: 0x60c3          STR      R3, [R0, #0xc]
  //       __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
  0x800'085a: 0x6808          LDR      R0, [R1]
  0x800'085c: 0x68c3          LDR      R3, [R0, #0xc]
  0x800'085e: 0xf053 0x0340   ORRS.W   R3, R3, #64            ; 0x40
  0x800'0862: 0x6808          LDR      R0, [R1]
  0x800'0864: 0x60c3          STR      R3, [R0, #0xc]
                ??UART_Transmit_IT_3:
  //     return HAL_OK;
  0x800'0866: 0x2000          MOVS     R0, #0
  0x800'0868: 0xe000          B.N      ??UART_Transmit_IT_4   ; 0x800'086c
                ??UART_Transmit_IT_0:
  //     return HAL_BUSY;
  0x800'086a: 0x2002          MOVS     R0, #2
                ??UART_Transmit_IT_4:
  0x800'086c: 0x4770          BX       LR
                `.text_61`:
                UART_EndTransmit_IT:
  // static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
  // {
  0x800'086e: 0xb510          PUSH     {R4, LR}
  0x800'0870: 0x0004          MOVS     R4, R0
  //   __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
  0x800'0872: 0x6820          LDR      R0, [R4]
  0x800'0874: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'0876: 0xf031 0x0140   BICS.W   R1, R1, #64            ; 0x40
  0x800'087a: 0x6820          LDR      R0, [R4]
  0x800'087c: 0x60c1          STR      R1, [R0, #0xc]
  //   huart->gState = HAL_UART_STATE_READY;
  0x800'087e: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0880: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   HAL_UART_TxCpltCallback(huart);
  0x800'0884: 0x0020          MOVS     R0, R4
  0x800'0886: 0xf000 0xfb45   BL       HAL_UART_TxCpltCallback
                                                              ; 0x800'0f14
  //   return HAL_OK;
  0x800'088a: 0x2000          MOVS     R0, #0
  0x800'088c: 0xbd10          POP      {R4, PC}
                `.text_62`:
                UART_Receive_IT:
  // static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
  // {
  0x800'088e: 0xb57c          PUSH     {R2-R6, LR}
  0x800'0890: 0x0004          MOVS     R4, R0
  //   if (huart->RxState == HAL_UART_STATE_BUSY_RX)
  0x800'0892: 0xf894 0x0042   LDRB.W   R0, [R4, #0x42]
  0x800'0896: 0x2822          CMP      R0, #34                ; 0x22
  0x800'0898: 0xd172          BNE.N    ??UART_Receive_IT_0    ; 0x800'0980
  //     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  0x800'089a: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'089c: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'08a0: 0xd10d          BNE.N    ??UART_Receive_IT_1    ; 0x800'08be
  0x800'08a2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'08a4: 0x2800          CMP      R0, #0
  0x800'08a6: 0xd10a          BNE.N    ??UART_Receive_IT_1    ; 0x800'08be
  //       pdata8bits  = NULL;
  0x800'08a8: 0x2600          MOVS     R6, #0
  //       pdata16bits = (uint16_t *) huart->pRxBuffPtr;
  0x800'08aa: 0x6aa5          LDR      R5, [R4, #0x28]
  //       *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
  0x800'08ac: 0x6820          LDR      R0, [R4]
  0x800'08ae: 0x6840          LDR      R0, [R0, #0x4]
  0x800'08b0: 0x05c0          LSLS     R0, R0, #23
  0x800'08b2: 0x0dc0          LSRS     R0, R0, #23
  0x800'08b4: 0x8028          STRH     R0, [R5]
  //       huart->pRxBuffPtr += 2U;
  0x800'08b6: 0x6aa0          LDR      R0, [R4, #0x28]
  0x800'08b8: 0x1c80          ADDS     R0, R0, #2
  0x800'08ba: 0x62a0          STR      R0, [R4, #0x28]
  0x800'08bc: 0xe017          B.N      ??UART_Receive_IT_2    ; 0x800'08ee
                ??UART_Receive_IT_1:
  //       pdata8bits = (uint8_t *) huart->pRxBuffPtr;
  0x800'08be: 0x6aa6          LDR      R6, [R4, #0x28]
  //       pdata16bits  = NULL;
  0x800'08c0: 0x2500          MOVS     R5, #0
  //       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
  0x800'08c2: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'08c4: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'08c8: 0xd005          BEQ.N    ??UART_Receive_IT_3    ; 0x800'08d6
  0x800'08ca: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'08cc: 0x2800          CMP      R0, #0
  0x800'08ce: 0xd106          BNE.N    ??UART_Receive_IT_4    ; 0x800'08de
  0x800'08d0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'08d2: 0x2800          CMP      R0, #0
  0x800'08d4: 0xd103          BNE.N    ??UART_Receive_IT_4    ; 0x800'08de
                ??UART_Receive_IT_3:
  //         *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
  0x800'08d6: 0x6820          LDR      R0, [R4]
  0x800'08d8: 0x6840          LDR      R0, [R0, #0x4]
  0x800'08da: 0x7030          STRB     R0, [R6]
  0x800'08dc: 0xe004          B.N      ??UART_Receive_IT_5    ; 0x800'08e8
                ??UART_Receive_IT_4:
  //         *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
  0x800'08de: 0x6820          LDR      R0, [R4]
  0x800'08e0: 0x6840          LDR      R0, [R0, #0x4]
  0x800'08e2: 0xf010 0x007f   ANDS.W   R0, R0, #127           ; 0x7f
  0x800'08e6: 0x7030          STRB     R0, [R6]
                ??UART_Receive_IT_5:
  //       huart->pRxBuffPtr += 1U;
  0x800'08e8: 0x6aa0          LDR      R0, [R4, #0x28]
  0x800'08ea: 0x1c40          ADDS     R0, R0, #1
  0x800'08ec: 0x62a0          STR      R0, [R4, #0x28]
                ??UART_Receive_IT_2:
  //     if (--huart->RxXferCount == 0U)
  0x800'08ee: 0x8de0          LDRH     R0, [R4, #0x2e]
  0x800'08f0: 0x1e40          SUBS     R0, R0, #1
  0x800'08f2: 0x85e0          STRH     R0, [R4, #0x2e]
  0x800'08f4: 0xb280          UXTH     R0, R0
  0x800'08f6: 0x2800          CMP      R0, #0
  0x800'08f8: 0xd140          BNE.N    ??UART_Receive_IT_6    ; 0x800'097c
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
  0x800'08fa: 0x6820          LDR      R0, [R4]
  0x800'08fc: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'08fe: 0xf031 0x0120   BICS.W   R1, R1, #32            ; 0x20
  0x800'0902: 0x6820          LDR      R0, [R4]
  0x800'0904: 0x60c1          STR      R1, [R0, #0xc]
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
  0x800'0906: 0x6820          LDR      R0, [R4]
  0x800'0908: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'090a: 0xf431 0x7180   BICS.W   R1, R1, #256           ; 0x100
  0x800'090e: 0x6820          LDR      R0, [R4]
  0x800'0910: 0x60c1          STR      R1, [R0, #0xc]
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
  0x800'0912: 0x6820          LDR      R0, [R4]
  0x800'0914: 0x6940          LDR      R0, [R0, #0x14]
  0x800'0916: 0x0840          LSRS     R0, R0, #1
  0x800'0918: 0x0040          LSLS     R0, R0, #1
  0x800'091a: 0x6821          LDR      R1, [R4]
  0x800'091c: 0x6148          STR      R0, [R1, #0x14]
  //       huart->RxState = HAL_UART_STATE_READY;
  0x800'091e: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0920: 0xf884 0x0042   STRB.W   R0, [R4, #0x42]
  //       huart->RxEventType = HAL_UART_RXEVENT_TC;
  0x800'0924: 0x2000          MOVS     R0, #0
  0x800'0926: 0x6360          STR      R0, [R4, #0x34]
  //       if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  0x800'0928: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'092a: 0x2801          CMP      R0, #1
  0x800'092c: 0xd121          BNE.N    ??UART_Receive_IT_7    ; 0x800'0972
  //         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'092e: 0x2000          MOVS     R0, #0
  0x800'0930: 0x6320          STR      R0, [R4, #0x30]
                ??UART_Receive_IT_8:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'0932: 0x6820          LDR      R0, [R4]
  0x800'0934: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'0936: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'093a: 0xf030 0x0010   BICS.W   R0, R0, #16            ; 0x10
  0x800'093e: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'0940: 0x6820          LDR      R0, [R4]
  0x800'0942: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'0946: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'094a: 0x2800          CMP      R0, #0
  0x800'094c: 0xd1f1          BNE.N    ??UART_Receive_IT_8    ; 0x800'0932
  //         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
  0x800'094e: 0x6820          LDR      R0, [R4]
  0x800'0950: 0x6800          LDR      R0, [R0]
  0x800'0952: 0x06c0          LSLS     R0, R0, #27
  0x800'0954: 0xd508          BPL.N    ??UART_Receive_IT_9    ; 0x800'0968
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0956: 0x2000          MOVS     R0, #0
  0x800'0958: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'095a: 0x6820          LDR      R0, [R4]
  0x800'095c: 0x6800          LDR      R0, [R0]
  0x800'095e: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0960: 0x6820          LDR      R0, [R4]
  0x800'0962: 0x6840          LDR      R0, [R0, #0x4]
  0x800'0964: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0966: 0x9800          LDR      R0, [SP]
                ??UART_Receive_IT_9:
  //         HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
  0x800'0968: 0x8da1          LDRH     R1, [R4, #0x2c]
  0x800'096a: 0x0020          MOVS     R0, R4
  0x800'096c: 0xf000 0xfad1   BL       HAL_UARTEx_RxEventCallback
                                                              ; 0x800'0f12
  0x800'0970: 0xe002          B.N      ??UART_Receive_IT_10   ; 0x800'0978
                ??UART_Receive_IT_7:
  //         HAL_UART_RxCpltCallback(huart);
  0x800'0972: 0x0020          MOVS     R0, R4
  0x800'0974: 0xf000 0xfacf   BL       HAL_UART_RxCpltCallback
                                                              ; 0x800'0f16
                ??UART_Receive_IT_10:
  //       return HAL_OK;
  0x800'0978: 0x2000          MOVS     R0, #0
  0x800'097a: 0xe002          B.N      ??UART_Receive_IT_11   ; 0x800'0982
                ??UART_Receive_IT_6:
  //     return HAL_OK;
  0x800'097c: 0x2000          MOVS     R0, #0
  0x800'097e: 0xe000          B.N      ??UART_Receive_IT_11   ; 0x800'0982
                ??UART_Receive_IT_0:
  //     return HAL_BUSY;
  0x800'0980: 0x2002          MOVS     R0, #2
                ??UART_Receive_IT_11:
  0x800'0982: 0xbd76          POP      {R1, R2, R4-R6, PC}
                `.text_63`:
                UART_SetConfig:
  // static void UART_SetConfig(UART_HandleTypeDef *huart)
  // {
  0x800'0984: 0xe92d 0x4ff8   PUSH.W   {R3-R11, LR}
  0x800'0988: 0xb084          SUB      SP, SP, #0x10
  0x800'098a: 0x0005          MOVS     R5, R0
  //   assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  0x800'098c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'098e: 0x49d5          LDR.N    R1, ??DataTable10_10   ; 0xa0'37a1
  0x800'0990: 0x4288          CMP      R0, R1
  0x800'0992: 0xd304          BCC.N    ??UART_SetConfig_0     ; 0x800'099e
  0x800'0994: 0xf640 0x6175   MOVW     R1, #3701              ; 0xe75
  0x800'0998: 0x48d1          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'099a: 0xf000 0xf9d4   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_0:
  //   assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  0x800'099e: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'09a0: 0x2800          CMP      R0, #0
  0x800'09a2: 0xd008          BEQ.N    ??UART_SetConfig_1     ; 0x800'09b6
  0x800'09a4: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'09a6: 0xf5b0 0x5f00   CMP.W    R0, #8192              ; 0x2000
  0x800'09aa: 0xd004          BEQ.N    ??UART_SetConfig_1     ; 0x800'09b6
  0x800'09ac: 0xf640 0x6176   MOVW     R1, #3702              ; 0xe76
  0x800'09b0: 0x48cb          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'09b2: 0xf000 0xf9c8   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_1:
  //   assert_param(IS_UART_PARITY(huart->Init.Parity));
  0x800'09b6: 0x6928          LDR      R0, [R5, #0x10]
  0x800'09b8: 0x2800          CMP      R0, #0
  0x800'09ba: 0xd00c          BEQ.N    ??UART_SetConfig_2     ; 0x800'09d6
  0x800'09bc: 0x6928          LDR      R0, [R5, #0x10]
  0x800'09be: 0xf5b0 0x6f80   CMP.W    R0, #1024              ; 0x400
  0x800'09c2: 0xd008          BEQ.N    ??UART_SetConfig_2     ; 0x800'09d6
  0x800'09c4: 0x6928          LDR      R0, [R5, #0x10]
  0x800'09c6: 0xf5b0 0x6fc0   CMP.W    R0, #1536              ; 0x600
  0x800'09ca: 0xd004          BEQ.N    ??UART_SetConfig_2     ; 0x800'09d6
  0x800'09cc: 0xf640 0x6177   MOVW     R1, #3703              ; 0xe77
  0x800'09d0: 0x48c3          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'09d2: 0xf000 0xf9b8   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_2:
  //   assert_param(IS_UART_MODE(huart->Init.Mode));
  0x800'09d6: 0x6969          LDR      R1, [R5, #0x14]
  0x800'09d8: 0xf64f 0x70f3   MOVW     R0, #65523             ; 0xfff3
  0x800'09dc: 0x4201          TST      R1, R0
  0x800'09de: 0xd102          BNE.N    ??UART_SetConfig_3     ; 0x800'09e6
  0x800'09e0: 0x6968          LDR      R0, [R5, #0x14]
  0x800'09e2: 0x2800          CMP      R0, #0
  0x800'09e4: 0xd104          BNE.N    ??UART_SetConfig_4     ; 0x800'09f0
                ??UART_SetConfig_3:
  0x800'09e6: 0xf640 0x6178   MOVW     R1, #3704              ; 0xe78
  0x800'09ea: 0x48bd          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'09ec: 0xf000 0xf9ab   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_4:
  //   MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
  0x800'09f0: 0x6828          LDR      R0, [R5]
  0x800'09f2: 0x6901          LDR      R1, [R0, #0x10]
  0x800'09f4: 0xf431 0x5140   BICS.W   R1, R1, #12288         ; 0x3000
  0x800'09f8: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'09fa: 0x4301          ORRS     R1, R1, R0
  0x800'09fc: 0x6828          LDR      R0, [R5]
  0x800'09fe: 0x6101          STR      R1, [R0, #0x10]
  //   tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  0x800'0a00: 0x68a9          LDR      R1, [R5, #0x8]
  0x800'0a02: 0x6928          LDR      R0, [R5, #0x10]
  0x800'0a04: 0x4301          ORRS     R1, R1, R0
  0x800'0a06: 0x6968          LDR      R0, [R5, #0x14]
  0x800'0a08: 0x4301          ORRS     R1, R1, R0
  0x800'0a0a: 0x69e8          LDR      R0, [R5, #0x1c]
  0x800'0a0c: 0x4301          ORRS     R1, R1, R0
  0x800'0a0e: 0x9103          STR      R1, [SP, #0xc]
  //   MODIFY_REG(huart->Instance->CR1,
  //              (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
  //              tmpreg);
  0x800'0a10: 0x6828          LDR      R0, [R5]
  0x800'0a12: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'0a14: 0x48b4          LDR.N    R0, ??DataTable10_11   ; 0xffff'69f3
  0x800'0a16: 0x4001          ANDS     R1, R1, R0
  0x800'0a18: 0x9803          LDR      R0, [SP, #0xc]
  0x800'0a1a: 0x4301          ORRS     R1, R1, R0
  0x800'0a1c: 0x6828          LDR      R0, [R5]
  0x800'0a1e: 0x60c1          STR      R1, [R0, #0xc]
  //   MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
  0x800'0a20: 0x6828          LDR      R0, [R5]
  0x800'0a22: 0x6941          LDR      R1, [R0, #0x14]
  0x800'0a24: 0xf431 0x7140   BICS.W   R1, R1, #768           ; 0x300
  0x800'0a28: 0x69a8          LDR      R0, [R5, #0x18]
  0x800'0a2a: 0x4301          ORRS     R1, R1, R0
  0x800'0a2c: 0x6828          LDR      R0, [R5]
  0x800'0a2e: 0x6141          STR      R1, [R0, #0x14]
  //     if ((huart->Instance == USART1) || (huart->Instance == USART6))
  0x800'0a30: 0x6829          LDR      R1, [R5]
  0x800'0a32: 0x48a9          LDR.N    R0, ??DataTable10      ; 0x4001'1000
  0x800'0a34: 0x4281          CMP      R1, R0
  0x800'0a36: 0xd003          BEQ.N    ??UART_SetConfig_5     ; 0x800'0a40
  0x800'0a38: 0x6829          LDR      R1, [R5]
  0x800'0a3a: 0x48a8          LDR.N    R0, ??DataTable10_5    ; 0x4001'1400
  0x800'0a3c: 0x4281          CMP      R1, R0
  0x800'0a3e: 0xd103          BNE.N    ??UART_SetConfig_6     ; 0x800'0a48
                ??UART_SetConfig_5:
  //       pclk = HAL_RCC_GetPCLK2Freq();
  0x800'0a40: 0xf000 0xfa78   BL       HAL_RCC_GetPCLK2Freq   ; 0x800'0f34
  0x800'0a44: 0x0004          MOVS     R4, R0
  0x800'0a46: 0xe002          B.N      ??UART_SetConfig_7     ; 0x800'0a4e
                ??UART_SetConfig_6:
  //       pclk = HAL_RCC_GetPCLK1Freq();
  0x800'0a48: 0xf000 0xfa69   BL       HAL_RCC_GetPCLK1Freq   ; 0x800'0f1e
  0x800'0a4c: 0x0004          MOVS     R4, R0
                ??UART_SetConfig_7:
  //   if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  0x800'0a4e: 0x69e8          LDR      R0, [R5, #0x1c]
  0x800'0a50: 0xf5b0 0x4f00   CMP.W    R0, #32768             ; 0x8000
  0x800'0a54: 0xf040 0x809f   BNE.W    ??UART_SetConfig_8     ; 0x800'0b96
  //     huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
  0x800'0a58: 0xf07f 0x0a63   MVNS.W   R10, #99               ; 0x63
  0x800'0a5c: 0xf05f 0x0802   MOVS.W   R8, #2
  0x800'0a60: 0xf05f 0x0900   MOVS.W   R9, #0
  0x800'0a64: 0x2619          MOVS     R6, #25                ; 0x19
  0x800'0a66: 0x2700          MOVS     R7, #0
  0x800'0a68: 0x0022          MOVS     R2, R4
  0x800'0a6a: 0x2300          MOVS     R3, #0
  0x800'0a6c: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0a70: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0a74: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0a78: 0xe9cd 0x0100   STRD     R0, R1, [SP]
  0x800'0a7c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0a7e: 0x2100          MOVS     R1, #0
  0x800'0a80: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0a84: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0a88: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0a8c: 0xe9dd 0x0100   LDRD     R0, R1, [SP]
  0x800'0a90: 0xf000 0xfa7e   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0a94: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0a96: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0a9a: 0x9000          STR      R0, [SP]
  0x800'0a9c: 0x0022          MOVS     R2, R4
  0x800'0a9e: 0x2300          MOVS     R3, #0
  0x800'0aa0: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0aa4: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0aa8: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0aac: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0ab0: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0ab2: 0x2100          MOVS     R1, #0
  0x800'0ab4: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0ab8: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0abc: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0ac0: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0ac4: 0xf000 0xfa64   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0ac8: 0x4683          MOV      R11, R0
  0x800'0aca: 0x0022          MOVS     R2, R4
  0x800'0acc: 0x2300          MOVS     R3, #0
  0x800'0ace: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0ad2: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0ad6: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0ada: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0ade: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0ae0: 0x2100          MOVS     R1, #0
  0x800'0ae2: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0ae6: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0aea: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0aee: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0af2: 0xf000 0xfa4d   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0af6: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0af8: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0afc: 0xfb0a 0xb000   MLA      R0, R10, R0, R11
  0x800'0b00: 0x00c0          LSLS     R0, R0, #3
  0x800'0b02: 0x3032          ADDS     R0, R0, #50            ; 0x32
  0x800'0b04: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0b06: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0b0a: 0x0040          LSLS     R0, R0, #1
  0x800'0b0c: 0xf410 0x70f8   ANDS.W   R0, R0, #496           ; 0x1f0
  0x800'0b10: 0x9900          LDR      R1, [SP]
  0x800'0b12: 0xeb10 0x1001   ADDS.W   R0, R0, R1, LSL #4
  0x800'0b16: 0x9000          STR      R0, [SP]
  0x800'0b18: 0x0022          MOVS     R2, R4
  0x800'0b1a: 0x2300          MOVS     R3, #0
  0x800'0b1c: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0b20: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0b24: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0b28: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0b2c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0b2e: 0x2100          MOVS     R1, #0
  0x800'0b30: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0b34: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0b38: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0b3c: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0b40: 0xf000 0xfa26   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0b44: 0x4683          MOV      R11, R0
  0x800'0b46: 0x0022          MOVS     R2, R4
  0x800'0b48: 0x2300          MOVS     R3, #0
  0x800'0b4a: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0b4e: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0b52: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0b56: 0x0006          MOVS     R6, R0
  0x800'0b58: 0x000f          MOVS     R7, R1
  0x800'0b5a: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0b5c: 0x2100          MOVS     R1, #0
  0x800'0b5e: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0b62: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0b66: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0b6a: 0x0030          MOVS     R0, R6
  0x800'0b6c: 0x0039          MOVS     R1, R7
  0x800'0b6e: 0xf000 0xfa0f   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0b72: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0b74: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0b78: 0xfb0a 0xba00   MLA      R10, R10, R0, R11
  0x800'0b7c: 0xea5f 0x01ca   LSLS.W   R1, R10, #3
  0x800'0b80: 0x3132          ADDS     R1, R1, #50            ; 0x32
  0x800'0b82: 0x2064          MOVS     R0, #100               ; 0x64
  0x800'0b84: 0xfbb1 0xf1f0   UDIV     R1, R1, R0
  0x800'0b88: 0xf011 0x0107   ANDS.W   R1, R1, #7
  0x800'0b8c: 0x9800          LDR      R0, [SP]
  0x800'0b8e: 0x1809          ADDS     R1, R1, R0
  0x800'0b90: 0x6828          LDR      R0, [R5]
  0x800'0b92: 0x6081          STR      R1, [R0, #0x8]
  0x800'0b94: 0xe09c          B.N      ??UART_SetConfig_9     ; 0x800'0cd0
                ??UART_SetConfig_8:
  //     huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  0x800'0b96: 0xf05f 0x0804   MOVS.W   R8, #4
  0x800'0b9a: 0xf05f 0x0900   MOVS.W   R9, #0
  0x800'0b9e: 0xf07f 0x0a63   MVNS.W   R10, #99               ; 0x63
  0x800'0ba2: 0x2619          MOVS     R6, #25                ; 0x19
  0x800'0ba4: 0x2700          MOVS     R7, #0
  0x800'0ba6: 0x0022          MOVS     R2, R4
  0x800'0ba8: 0x2300          MOVS     R3, #0
  0x800'0baa: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0bae: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0bb2: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0bb6: 0xe9cd 0x0100   STRD     R0, R1, [SP]
  0x800'0bba: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0bbc: 0x2100          MOVS     R1, #0
  0x800'0bbe: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0bc2: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0bc6: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0bca: 0xe9dd 0x0100   LDRD     R0, R1, [SP]
  0x800'0bce: 0xf000 0xf9df   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0bd2: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0bd4: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0bd8: 0x9000          STR      R0, [SP]
  0x800'0bda: 0x0022          MOVS     R2, R4
  0x800'0bdc: 0x2300          MOVS     R3, #0
  0x800'0bde: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0be2: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0be6: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0bea: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0bee: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0bf0: 0x2100          MOVS     R1, #0
  0x800'0bf2: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0bf6: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0bfa: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0bfe: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0c02: 0xf000 0xf9c5   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0c06: 0x4683          MOV      R11, R0
  0x800'0c08: 0x0022          MOVS     R2, R4
  0x800'0c0a: 0x2300          MOVS     R3, #0
  0x800'0c0c: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0c10: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0c14: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0c18: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0c1c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0c1e: 0x2100          MOVS     R1, #0
  0x800'0c20: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0c24: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0c28: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0c2c: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0c30: 0xf000 0xf9ae   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0c34: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0c36: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0c3a: 0xfb0a 0xb000   MLA      R0, R10, R0, R11
  0x800'0c3e: 0x0101          LSLS     R1, R0, #4
  0x800'0c40: 0x3132          ADDS     R1, R1, #50            ; 0x32
  0x800'0c42: 0x2064          MOVS     R0, #100               ; 0x64
  0x800'0c44: 0xfbb1 0xf0f0   UDIV     R0, R1, R0
  0x800'0c48: 0xf010 0x00f0   ANDS.W   R0, R0, #240           ; 0xf0
  0x800'0c4c: 0x9900          LDR      R1, [SP]
  0x800'0c4e: 0xeb10 0x1001   ADDS.W   R0, R0, R1, LSL #4
  0x800'0c52: 0x9000          STR      R0, [SP]
  0x800'0c54: 0x0022          MOVS     R2, R4
  0x800'0c56: 0x2300          MOVS     R3, #0
  0x800'0c58: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0c5c: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0c60: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0c64: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0c68: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0c6a: 0x2100          MOVS     R1, #0
  0x800'0c6c: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0c70: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0c74: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0c78: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0c7c: 0xf000 0xf988   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0c80: 0x4683          MOV      R11, R0
  0x800'0c82: 0x0022          MOVS     R2, R4
  0x800'0c84: 0x2300          MOVS     R3, #0
  0x800'0c86: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0c8a: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0c8e: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0c92: 0x0006          MOVS     R6, R0
  0x800'0c94: 0x000f          MOVS     R7, R1
  0x800'0c96: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0c98: 0x2100          MOVS     R1, #0
  0x800'0c9a: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0c9e: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0ca2: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0ca6: 0x0030          MOVS     R0, R6
  0x800'0ca8: 0x0039          MOVS     R1, R7
  0x800'0caa: 0xf000 0xf971   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0cae: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0cb0: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0cb4: 0xfb0a 0xba00   MLA      R10, R10, R0, R11
  0x800'0cb8: 0xea5f 0x100a   LSLS.W   R0, R10, #4
  0x800'0cbc: 0x3032          ADDS     R0, R0, #50            ; 0x32
  0x800'0cbe: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0cc0: 0xfbb0 0xf1f1   UDIV     R1, R0, R1
  0x800'0cc4: 0xf011 0x010f   ANDS.W   R1, R1, #15            ; 0xf
  0x800'0cc8: 0x9800          LDR      R0, [SP]
  0x800'0cca: 0x1809          ADDS     R1, R1, R0
  0x800'0ccc: 0x6828          LDR      R0, [R5]
  0x800'0cce: 0x6081          STR      R1, [R0, #0x8]
                ??UART_SetConfig_9:
  // }
  0x800'0cd0: 0xb005          ADD      SP, SP, #0x14
  0x800'0cd2: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'0cd6: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable10:
  0x800'0cd8: 0x4001'1000     DC32     0x4001'1000            ; '...@'
                ??DataTable10_5:
  0x800'0cdc: 0x4001'1400     DC32     0x4001'1400            ; '...@'
                ??DataTable10_6:
  0x800'0ce0: 0x0800'3d94     DC32     ?_0
                ??DataTable10_10:
  0x800'0ce4: 0x00a0'37a1     DC32     0xa0'37a1              ; '.7..'
                ??DataTable10_11:
  0x800'0ce8: 0xffff'69f3     DC32     -38413                 ; '.i..'
                $t:
                `.text8`:
                NMI_Handler:
  // void NMI_Handler(void)
  // {
  0x800'0cec: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0cee: 0x491a          LDR.N    R1, ??DataTable8       ; `NMI_Handler::__func__`
  0x800'0cf0: 0x481a          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0cf2: 0xf000 0xfa65   BL       printf                 ; 0x800'11c0
                ??NMI_Handler_0:
  //   while (1)
  0x800'0cf6: 0xe7fe          B.N      ??NMI_Handler_0        ; 0x800'0cf6
                `.text_12`:
                MemManage_Handler:
  // void MemManage_Handler(void)
  // {
  0x800'0cf8: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0cfa: 0x4919          LDR.N    R1, ??DataTable8_3     ; `MemManage_Handler::__func__`
  0x800'0cfc: 0x4817          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0cfe: 0xf000 0xfa5f   BL       printf                 ; 0x800'11c0
                ??MemManage_Handler_0:
  //   while (1)
  0x800'0d02: 0xe7fe          B.N      ??MemManage_Handler_0  ; 0x800'0d02
                `.text_13`:
                BusFault_Handler:
  // void BusFault_Handler(void)
  // {
  0x800'0d04: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0d06: 0x4917          LDR.N    R1, ??DataTable8_4     ; `BusFault_Handler::__func__`
  0x800'0d08: 0x4814          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d0a: 0xf000 0xfa59   BL       printf                 ; 0x800'11c0
                ??BusFault_Handler_0:
  //   while (1)
  0x800'0d0e: 0xe7fe          B.N      ??BusFault_Handler_0   ; 0x800'0d0e
                `.text_14`:
                UsageFault_Handler:
  // void UsageFault_Handler(void)
  // {
  0x800'0d10: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0d12: 0x4915          LDR.N    R1, ??DataTable8_5     ; `UsageFault_Handler::__func__`
  0x800'0d14: 0x4811          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d16: 0xf000 0xfa53   BL       printf                 ; 0x800'11c0
                ??UsageFault_Handler_0:
  //   while (1)
  0x800'0d1a: 0xe7fe          B.N      ??UsageFault_Handler_0 ; 0x800'0d1a
                `.text_15`:
                SVC_Handler:
  // }
  0x800'0d1c: 0x4770          BX       LR
                `.text_16`:
                DebugMon_Handler:
  // }
  0x800'0d1e: 0x4770          BX       LR
                `.text_17`:
                TIM2_IRQHandler:
  // void TIM2_IRQHandler(void)
  // {
  0x800'0d20: 0xb580          PUSH     {R7, LR}
  //   HAL_IncTick();
  0x800'0d22: 0xf000 0xfa61   BL       HAL_IncTick            ; 0x800'11e8
  //   HAL_TIM_IRQHandler(&htim2);
  0x800'0d26: 0x4811          LDR.N    R0, ??DataTable8_6     ; htim2
  0x800'0d28: 0xf000 0xfbfa   BL       HAL_TIM_IRQHandler     ; 0x800'1520
  // }
  0x800'0d2c: 0xbd01          POP      {R0, PC}
                `.text_18`:
                USART1_IRQHandler:
  // void USART1_IRQHandler(void)
  // {
  0x800'0d2e: 0xb580          PUSH     {R7, LR}
  //   HAL_UART_IRQHandler(&huart1);
  0x800'0d30: 0x480f          LDR.N    R0, ??DataTable8_7     ; huart1
  0x800'0d32: 0xf7ff 0xfb51   BL       HAL_UART_IRQHandler    ; 0x800'03d8
  // }
  0x800'0d36: 0xbd01          POP      {R0, PC}
                `.text_19`:
                Error_Handler:
  // void Error_Handler(void)
  // {
  0x800'0d38: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0d3a: 0x490e          LDR.N    R1, ??DataTable8_8     ; `Error_Handler::__func__`
  0x800'0d3c: 0x4807          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d3e: 0xf000 0xfa3f   BL       printf                 ; 0x800'11c0
  //   __disable_irq();
  0x800'0d42: 0xb672          CPSID    i
                ??Error_Handler_0:
  //   while (1) {}
  0x800'0d44: 0xe7fe          B.N      ??Error_Handler_0      ; 0x800'0d44
                `.text_20`:
                assert_failed:
  // void assert_failed(uint8_t *file, uint32_t line)
  // {
  0x800'0d46: 0xb538          PUSH     {R3-R5, LR}
  0x800'0d48: 0x0005          MOVS     R5, R0
  0x800'0d4a: 0x000c          MOVS     R4, R1
  //   printf("this is %s.\r\n", __func__);
  0x800'0d4c: 0x490a          LDR.N    R1, ??DataTable8_9     ; `assert_failed::__func__`
  0x800'0d4e: 0x4803          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d50: 0xf000 0xfa36   BL       printf                 ; 0x800'11c0
  //   __disable_irq();
  0x800'0d54: 0xb672          CPSID    i
                ??assert_failed_0:
  //   while (1) {}
  0x800'0d56: 0xe7fe          B.N      ??assert_failed_0      ; 0x800'0d56
                `$d.32`:
                ??DataTable8:
  0x800'0d58: 0x0800'40a4     DC32     `NMI_Handler::__func__`
                ??DataTable8_1:
  0x800'0d5c: 0x0800'4054     DC32     ?_0
                ??DataTable8_3:
  0x800'0d60: 0x0800'3ff4     DC32     `MemManage_Handler::__func__`
                ??DataTable8_4:
  0x800'0d64: 0x0800'4008     DC32     `BusFault_Handler::__func__`
                ??DataTable8_5:
  0x800'0d68: 0x0800'401c     DC32     `UsageFault_Handler::__func__`
                ??DataTable8_6:
  0x800'0d6c: 0x2000'2394     DC32     htim2
                ??DataTable8_7:
  0x800'0d70: 0x2000'234c     DC32     huart1
                ??DataTable8_8:
  0x800'0d74: 0x0800'4064     DC32     `Error_Handler::__func__`
                ??DataTable8_9:
  0x800'0d78: 0x0800'4074     DC32     `assert_failed::__func__`
                $t:
                `.text9`:
                MX_USART1_UART_Init:
  // void MX_USART1_UART_Init(void)
  // {
  0x800'0d7c: 0xb580          PUSH     {R7, LR}
  //   huart1.Instance = USART1;
  0x800'0d7e: 0x482b          LDR.N    R0, ??DataTable2       ; huart1
  0x800'0d80: 0x492b          LDR.N    R1, ??DataTable2_1     ; 0x4001'1000
  0x800'0d82: 0x6001          STR      R1, [R0]
  //   huart1.Init.BaudRate = 115200;
  0x800'0d84: 0xf45f 0x31e1   MOVS.W   R1, #115200            ; 0x1'c200
  0x800'0d88: 0x6041          STR      R1, [R0, #0x4]
  //   huart1.Init.WordLength = UART_WORDLENGTH_8B;
  0x800'0d8a: 0x2100          MOVS     R1, #0
  0x800'0d8c: 0x6081          STR      R1, [R0, #0x8]
  //   huart1.Init.StopBits = UART_STOPBITS_1;
  0x800'0d8e: 0x2100          MOVS     R1, #0
  0x800'0d90: 0x60c1          STR      R1, [R0, #0xc]
  //   huart1.Init.Parity = UART_PARITY_NONE;
  0x800'0d92: 0x2100          MOVS     R1, #0
  0x800'0d94: 0x6101          STR      R1, [R0, #0x10]
  //   huart1.Init.Mode = UART_MODE_TX_RX;
  0x800'0d96: 0x210c          MOVS     R1, #12                ; 0xc
  0x800'0d98: 0x6141          STR      R1, [R0, #0x14]
  //   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  0x800'0d9a: 0x2100          MOVS     R1, #0
  0x800'0d9c: 0x6181          STR      R1, [R0, #0x18]
  //   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  0x800'0d9e: 0x2100          MOVS     R1, #0
  0x800'0da0: 0x61c1          STR      R1, [R0, #0x1c]
  //   if (HAL_UART_Init(&huart1) != HAL_OK)
  0x800'0da2: 0xf7ff 0xf9f1   BL       HAL_UART_Init          ; 0x800'0188
  0x800'0da6: 0x2800          CMP      R0, #0
  0x800'0da8: 0xd001          BEQ.N    ??MX_USART1_UART_Init_0
                                                              ; 0x800'0dae
  //     Error_Handler();
  0x800'0daa: 0xf7ff 0xffc5   BL       Error_Handler          ; 0x800'0d38
                ??MX_USART1_UART_Init_0:
  // }
  0x800'0dae: 0xbd01          POP      {R0, PC}
                `.text_4`:
                HAL_UART_MspInit:
  // void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
  // {
  0x800'0db0: 0xb510          PUSH     {R4, LR}
  0x800'0db2: 0xb086          SUB      SP, SP, #0x18
  0x800'0db4: 0x0004          MOVS     R4, R0
  0x800'0db6: 0x2114          MOVS     R1, #20                ; 0x14
  0x800'0db8: 0x2200          MOVS     R2, #0
  0x800'0dba: 0xa801          ADD      R0, SP, #0x4
  0x800'0dbc: 0xf000 0xfcce   BL       __aeabi_memset         ; 0x800'175c
  //   if(uartHandle->Instance==USART1)
  0x800'0dc0: 0x6821          LDR      R1, [R4]
  0x800'0dc2: 0x481b          LDR.N    R0, ??DataTable2_1     ; 0x4001'1000
  0x800'0dc4: 0x4281          CMP      R1, R0
  0x800'0dc6: 0xd12e          BNE.N    ??HAL_UART_MspInit_0   ; 0x800'0e26
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dc8: 0x2000          MOVS     R0, #0
  0x800'0dca: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dcc: 0x4919          LDR.N    R1, ??DataTable2_2     ; 0x4002'3844
  0x800'0dce: 0x6808          LDR      R0, [R1]
  0x800'0dd0: 0xf050 0x0010   ORRS.W   R0, R0, #16            ; 0x10
  0x800'0dd4: 0x6008          STR      R0, [R1]
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dd6: 0x6808          LDR      R0, [R1]
  0x800'0dd8: 0xf010 0x0010   ANDS.W   R0, R0, #16            ; 0x10
  0x800'0ddc: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dde: 0x9800          LDR      R0, [SP]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0de0: 0x2000          MOVS     R0, #0
  0x800'0de2: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0de4: 0x4914          LDR.N    R1, ??DataTable2_3     ; 0x4002'3830
  0x800'0de6: 0x6808          LDR      R0, [R1]
  0x800'0de8: 0xf050 0x0001   ORRS.W   R0, R0, #1
  0x800'0dec: 0x6008          STR      R0, [R1]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0dee: 0x6808          LDR      R0, [R1]
  0x800'0df0: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'0df4: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0df6: 0x9800          LDR      R0, [SP]
  //     GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
  0x800'0df8: 0xf44f 0x60c0   MOV.W    R0, #1536              ; 0x600
  0x800'0dfc: 0x9001          STR      R0, [SP, #0x4]
  //     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  0x800'0dfe: 0x2002          MOVS     R0, #2
  0x800'0e00: 0x9002          STR      R0, [SP, #0x8]
  //     GPIO_InitStruct.Pull = GPIO_NOPULL;
  0x800'0e02: 0x2000          MOVS     R0, #0
  0x800'0e04: 0x9003          STR      R0, [SP, #0xc]
  //     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  0x800'0e06: 0x2003          MOVS     R0, #3
  0x800'0e08: 0x9004          STR      R0, [SP, #0x10]
  //     GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
  0x800'0e0a: 0x2007          MOVS     R0, #7
  0x800'0e0c: 0x9005          STR      R0, [SP, #0x14]
  //     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  0x800'0e0e: 0xa901          ADD      R1, SP, #0x4
  0x800'0e10: 0x480a          LDR.N    R0, ??DataTable2_4     ; 0x4002'0000
  0x800'0e12: 0xf000 0xfceb   BL       HAL_GPIO_Init          ; 0x800'17ec
  //     HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
  0x800'0e16: 0x2200          MOVS     R2, #0
  0x800'0e18: 0x2100          MOVS     R1, #0
  0x800'0e1a: 0x2025          MOVS     R0, #37                ; 0x25
  0x800'0e1c: 0xf000 0xff75   BL       HAL_NVIC_SetPriority   ; 0x800'1d0a
  //     HAL_NVIC_EnableIRQ(USART1_IRQn);
  0x800'0e20: 0x2025          MOVS     R0, #37                ; 0x25
  0x800'0e22: 0xf000 0xff95   BL       HAL_NVIC_EnableIRQ     ; 0x800'1d50
                ??HAL_UART_MspInit_0:
  // }
  0x800'0e26: 0xb006          ADD      SP, SP, #0x18
  0x800'0e28: 0xbd10          POP      {R4, PC}
  0x800'0e2a: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable2:
  0x800'0e2c: 0x2000'234c     DC32     huart1
                ??DataTable2_1:
  0x800'0e30: 0x4001'1000     DC32     0x4001'1000            ; '...@'
                ??DataTable2_2:
  0x800'0e34: 0x4002'3844     DC32     0x4002'3844            ; 'D8.@'
                ??DataTable2_3:
  0x800'0e38: 0x4002'3830     DC32     0x4002'3830            ; '08.@'
                ??DataTable2_4:
  0x800'0e3c: 0x4002'0000     DC32     0x4002'0000            ; '...@'
                $t:
                `.text21`:
                HAL_GetTick:
  //   return uwTick;
  0x800'0e40: 0x4801          LDR.N    R0, ??HAL_GetTick_0    ; uwTick
  0x800'0e42: 0x6800          LDR      R0, [R0]
  0x800'0e44: 0x4770          BX       LR
  0x800'0e46: 0xbf00          NOP
                `$d.32`:
                ??HAL_GetTick_0:
  0x800'0e48: 0x2000'2440     DC32     uwTick
                $t:
                `.text_8`:
                HAL_DMA_Abort:
  // HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
  // {
  0x800'0e4c: 0xb570          PUSH     {R4-R6, LR}
  0x800'0e4e: 0x0004          MOVS     R4, R0
  //   DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  0x800'0e50: 0x6da5          LDR      R5, [R4, #0x58]
  //   uint32_t tickstart = HAL_GetTick();
  0x800'0e52: 0xf7ff 0xfff5   BL       HAL_GetTick            ; 0x800'0e40
  0x800'0e56: 0x0006          MOVS     R6, R0
  //   if(hdma->State != HAL_DMA_STATE_BUSY)
  0x800'0e58: 0xf894 0x0035   LDRB.W   R0, [R4, #0x35]
  0x800'0e5c: 0x2802          CMP      R0, #2
  0x800'0e5e: 0xd006          BEQ.N    ??HAL_DMA_Abort_0      ; 0x800'0e6e
  //     hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  0x800'0e60: 0x2080          MOVS     R0, #128               ; 0x80
  0x800'0e62: 0x6560          STR      R0, [R4, #0x54]
  //     __HAL_UNLOCK(hdma);
  0x800'0e64: 0x2000          MOVS     R0, #0
  0x800'0e66: 0xf884 0x0034   STRB.W   R0, [R4, #0x34]
  //     return HAL_ERROR;
  0x800'0e6a: 0x2001          MOVS     R0, #1
  0x800'0e6c: 0xe03b          B.N      ??HAL_DMA_Abort_1      ; 0x800'0ee6
                ??HAL_DMA_Abort_0:
  //     hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
  0x800'0e6e: 0x6820          LDR      R0, [R4]
  0x800'0e70: 0x6801          LDR      R1, [R0]
  0x800'0e72: 0xf031 0x0116   BICS.W   R1, R1, #22            ; 0x16
  0x800'0e76: 0x6820          LDR      R0, [R4]
  0x800'0e78: 0x6001          STR      R1, [R0]
  //     hdma->Instance->FCR &= ~(DMA_IT_FE);
  0x800'0e7a: 0x6820          LDR      R0, [R4]
  0x800'0e7c: 0x6941          LDR      R1, [R0, #0x14]
  0x800'0e7e: 0xf031 0x0180   BICS.W   R1, R1, #128           ; 0x80
  0x800'0e82: 0x6820          LDR      R0, [R4]
  0x800'0e84: 0x6141          STR      R1, [R0, #0x14]
  //     if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
  0x800'0e86: 0x6c20          LDR      R0, [R4, #0x40]
  0x800'0e88: 0x2800          CMP      R0, #0
  0x800'0e8a: 0xd102          BNE.N    ??HAL_DMA_Abort_2      ; 0x800'0e92
  0x800'0e8c: 0x6ca0          LDR      R0, [R4, #0x48]
  0x800'0e8e: 0x2800          CMP      R0, #0
  0x800'0e90: 0xd005          BEQ.N    ??HAL_DMA_Abort_3      ; 0x800'0e9e
                ??HAL_DMA_Abort_2:
  //       hdma->Instance->CR  &= ~(DMA_IT_HT);
  0x800'0e92: 0x6820          LDR      R0, [R4]
  0x800'0e94: 0x6801          LDR      R1, [R0]
  0x800'0e96: 0xf031 0x0108   BICS.W   R1, R1, #8
  0x800'0e9a: 0x6820          LDR      R0, [R4]
  0x800'0e9c: 0x6001          STR      R1, [R0]
                ??HAL_DMA_Abort_3:
  //     __HAL_DMA_DISABLE(hdma);
  0x800'0e9e: 0x6820          LDR      R0, [R4]
  0x800'0ea0: 0x6801          LDR      R1, [R0]
  0x800'0ea2: 0x0849          LSRS     R1, R1, #1
  0x800'0ea4: 0x0049          LSLS     R1, R1, #1
  0x800'0ea6: 0x6820          LDR      R0, [R4]
  0x800'0ea8: 0x6001          STR      R1, [R0]
                ??HAL_DMA_Abort_4:
  //     while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  0x800'0eaa: 0x6820          LDR      R0, [R4]
  0x800'0eac: 0x6800          LDR      R0, [R0]
  0x800'0eae: 0x07c0          LSLS     R0, R0, #31
  0x800'0eb0: 0xd50e          BPL.N    ??HAL_DMA_Abort_5      ; 0x800'0ed0
  //       if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
  0x800'0eb2: 0xf7ff 0xffc5   BL       HAL_GetTick            ; 0x800'0e40
  0x800'0eb6: 0x1b80          SUBS     R0, R0, R6
  0x800'0eb8: 0x2806          CMP      R0, #6
  0x800'0eba: 0xd3f6          BCC.N    ??HAL_DMA_Abort_4      ; 0x800'0eaa
  //         hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
  0x800'0ebc: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0ebe: 0x6560          STR      R0, [R4, #0x54]
  //         hdma->State = HAL_DMA_STATE_TIMEOUT;
  0x800'0ec0: 0x2003          MOVS     R0, #3
  0x800'0ec2: 0xf884 0x0035   STRB.W   R0, [R4, #0x35]
  //         __HAL_UNLOCK(hdma);
  0x800'0ec6: 0x2000          MOVS     R0, #0
  0x800'0ec8: 0xf884 0x0034   STRB.W   R0, [R4, #0x34]
  //         return HAL_TIMEOUT;
  0x800'0ecc: 0x2003          MOVS     R0, #3
  0x800'0ece: 0xe00a          B.N      ??HAL_DMA_Abort_1      ; 0x800'0ee6
                ??HAL_DMA_Abort_5:
  //     regs->IFCR = 0x3FU << hdma->StreamIndex;
  0x800'0ed0: 0x213f          MOVS     R1, #63                ; 0x3f
  0x800'0ed2: 0x6de0          LDR      R0, [R4, #0x5c]
  0x800'0ed4: 0x4081          LSLS     R1, R1, R0
  0x800'0ed6: 0x60a9          STR      R1, [R5, #0x8]
  //     hdma->State = HAL_DMA_STATE_READY;
  0x800'0ed8: 0x2001          MOVS     R0, #1
  0x800'0eda: 0xf884 0x0035   STRB.W   R0, [R4, #0x35]
  //     __HAL_UNLOCK(hdma);
  0x800'0ede: 0x2000          MOVS     R0, #0
  0x800'0ee0: 0xf884 0x0034   STRB.W   R0, [R4, #0x34]
  //   return HAL_OK;
  0x800'0ee4: 0x2000          MOVS     R0, #0
                ??HAL_DMA_Abort_1:
  0x800'0ee6: 0xbd70          POP      {R4-R6, PC}
                `.text_9`:
                HAL_DMA_Abort_IT:
  // HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
  // {
  0x800'0ee8: 0x0001          MOVS     R1, R0
  //   if(hdma->State != HAL_DMA_STATE_BUSY)
  0x800'0eea: 0xf891 0x0035   LDRB.W   R0, [R1, #0x35]
  0x800'0eee: 0x2802          CMP      R0, #2
  0x800'0ef0: 0xd003          BEQ.N    ??HAL_DMA_Abort_IT_0   ; 0x800'0efa
  //     hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  0x800'0ef2: 0x2080          MOVS     R0, #128               ; 0x80
  0x800'0ef4: 0x6548          STR      R0, [R1, #0x54]
  //     return HAL_ERROR;
  0x800'0ef6: 0x2001          MOVS     R0, #1
  0x800'0ef8: 0xe009          B.N      ??HAL_DMA_Abort_IT_1   ; 0x800'0f0e
                ??HAL_DMA_Abort_IT_0:
  //     hdma->State = HAL_DMA_STATE_ABORT;
  0x800'0efa: 0x2005          MOVS     R0, #5
  0x800'0efc: 0xf881 0x0035   STRB.W   R0, [R1, #0x35]
  //     __HAL_DMA_DISABLE(hdma);
  0x800'0f00: 0x6808          LDR      R0, [R1]
  0x800'0f02: 0x6802          LDR      R2, [R0]
  0x800'0f04: 0x0852          LSRS     R2, R2, #1
  0x800'0f06: 0x0052          LSLS     R2, R2, #1
  0x800'0f08: 0x6808          LDR      R0, [R1]
  0x800'0f0a: 0x6002          STR      R2, [R0]
  //   return HAL_OK;
  0x800'0f0c: 0x2000          MOVS     R0, #0
                ??HAL_DMA_Abort_IT_1:
  0x800'0f0e: 0x4770          BX       LR
                `.text22`:
                HAL_UART_ErrorCallback:
  // }
  0x800'0f10: 0x4770          BX       LR
                `.text30`:
                HAL_UARTEx_RxEventCallback:
  // }
  0x800'0f12: 0x4770          BX       LR
                `.text14`:
                HAL_UART_TxCpltCallback:
  // }
  0x800'0f14: 0x4770          BX       LR
                `.text18`:
                HAL_UART_RxCpltCallback:
  // }
  0x800'0f16: 0x4770          BX       LR
                `.text_9`:
                HAL_RCC_GetHCLKFreq:
  //   return SystemCoreClock;
  0x800'0f18: 0x481b          LDR.N    R0, ??DataTable8_5     ; SystemCoreClock
  0x800'0f1a: 0x6800          LDR      R0, [R0]
  0x800'0f1c: 0x4770          BX       LR
                `.text_10`:
                HAL_RCC_GetPCLK1Freq:
  // uint32_t HAL_RCC_GetPCLK1Freq(void)
  // {
  0x800'0f1e: 0xb580          PUSH     {R7, LR}
  //   return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
  0x800'0f20: 0xf7ff 0xfffa   BL       HAL_RCC_GetHCLKFreq    ; 0x800'0f18
  0x800'0f24: 0x4919          LDR.N    R1, ??DataTable8_11    ; APBPrescTable
  0x800'0f26: 0x4a17          LDR.N    R2, ??DataTable8_2     ; 0x4002'3808
  0x800'0f28: 0x6812          LDR      R2, [R2]
  0x800'0f2a: 0xf3c2 0x2282   UBFX     R2, R2, #10, #3
  0x800'0f2e: 0x5c89          LDRB     R1, [R1, R2]
  0x800'0f30: 0x40c8          LSRS     R0, R0, R1
  0x800'0f32: 0xbd02          POP      {R1, PC}
                `.text_11`:
                HAL_RCC_GetPCLK2Freq:
  // uint32_t HAL_RCC_GetPCLK2Freq(void)
  // {
  0x800'0f34: 0xb580          PUSH     {R7, LR}
  //   return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
  0x800'0f36: 0xf7ff 0xffef   BL       HAL_RCC_GetHCLKFreq    ; 0x800'0f18
  0x800'0f3a: 0x4914          LDR.N    R1, ??DataTable8_11    ; APBPrescTable
  0x800'0f3c: 0x4a11          LDR.N    R2, ??DataTable8_2     ; 0x4002'3808
  0x800'0f3e: 0x6812          LDR      R2, [R2]
  0x800'0f40: 0xf3c2 0x3242   UBFX     R2, R2, #13, #3
  0x800'0f44: 0x5c89          LDRB     R1, [R1, R2]
  0x800'0f46: 0x40c8          LSRS     R0, R0, R1
  0x800'0f48: 0xbd02          POP      {R1, PC}
                `.text_12`:
                HAL_RCC_GetClockConfig:
  //   RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  0x800'0f4a: 0x220f          MOVS     R2, #15                ; 0xf
  0x800'0f4c: 0x6002          STR      R2, [R0]
  //   RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
  0x800'0f4e: 0x4a0d          LDR.N    R2, ??DataTable8_2     ; 0x4002'3808
  0x800'0f50: 0x6813          LDR      R3, [R2]
  0x800'0f52: 0xf013 0x0303   ANDS.W   R3, R3, #3
  0x800'0f56: 0x6043          STR      R3, [R0, #0x4]
  //   RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
  0x800'0f58: 0x6813          LDR      R3, [R2]
  0x800'0f5a: 0xf013 0x03f0   ANDS.W   R3, R3, #240           ; 0xf0
  0x800'0f5e: 0x6083          STR      R3, [R0, #0x8]
  //   RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
  0x800'0f60: 0x6813          LDR      R3, [R2]
  0x800'0f62: 0xf413 0x53e0   ANDS.W   R3, R3, #7168          ; 0x1c00
  0x800'0f66: 0x60c3          STR      R3, [R0, #0xc]
  //   RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
  0x800'0f68: 0x6812          LDR      R2, [R2]
  0x800'0f6a: 0x08d2          LSRS     R2, R2, #3
  0x800'0f6c: 0xf412 0x52e0   ANDS.W   R2, R2, #7168          ; 0x1c00
  0x800'0f70: 0x6102          STR      R2, [R0, #0x10]
  //   *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
  0x800'0f72: 0x4a03          LDR.N    R2, ??DataTable8_1     ; 0x4002'3c00
  0x800'0f74: 0x6812          LDR      R2, [R2]
  0x800'0f76: 0xf012 0x0207   ANDS.W   R2, R2, #7
  0x800'0f7a: 0x600a          STR      R2, [R1]
  // }
  0x800'0f7c: 0x4770          BX       LR
  0x800'0f7e: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable8_1:
  0x800'0f80: 0x4002'3c00     DC32     0x4002'3c00            ; '.<.@'
                ??DataTable8_2:
  0x800'0f84: 0x4002'3808     DC32     0x4002'3808            ; '.8.@'
                ??DataTable8_5:
  0x800'0f88: 0x2000'0004     DC32     SystemCoreClock
                ??DataTable8_11:
  0x800'0f8c: 0x0800'40c0     DC32     APBPrescTable
                $t:
                `.text_2`:
                __aeabi_uldivmod:
  0x800'0f90: 0xbbbb          CBNZ     R3, @8001002
  0x800'0f92: 0xb1e1          CBZ      R1, @8000fce
  0x800'0f94: 0xf5b2 0x3f80   CMP.W    R2, #65536             ; 0x1'0000
  0x800'0f98: 0xf080 0x807e   BCS.W    @8001098
  0x800'0f9c: 0x2a02          CMP      R2, #2
  0x800'0f9e: 0xd91e          BLS.N    @8000fde
  0x800'0fa0: 0x468c          MOV      R12, R1
  0x800'0fa2: 0xfbb1 0xf1f2   UDIV     R1, R1, R2
  0x800'0fa6: 0xfb02 0xc311   MLS      R3, R2, R1, R12
  0x800'0faa: 0x041b          LSLS     R3, R3, #16
  0x800'0fac: 0xea43 0x4310   ORR.W    R3, R3, R0, LSR #16
  0x800'0fb0: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'0fb4: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'0fb8: 0xb280          UXTH     R0, R0
  0x800'0fba: 0xea40 0x4303   ORR.W    R3, R0, R3, LSL #16
  0x800'0fbe: 0xfbb3 0xf0f2   UDIV     R0, R3, R2
  0x800'0fc2: 0xfb02 0x3210   MLS      R2, R2, R0, R3
  0x800'0fc6: 0xea40 0x400c   ORR.W    R0, R0, R12, LSL #16
  0x800'0fca: 0x2300          MOVS     R3, #0
  0x800'0fcc: 0x4770          BX       LR
                @8000fce:
  0x800'0fce: 0x2a02          CMP      R2, #2
  0x800'0fd0: 0xd905          BLS.N    @8000fde
  0x800'0fd2: 0x4684          MOV      R12, R0
  0x800'0fd4: 0xfbb0 0xf0f2   UDIV     R0, R0, R2
  0x800'0fd8: 0xfb02 0xc210   MLS      R2, R2, R0, R12
  0x800'0fdc: 0x4770          BX       LR
                @8000fde:
  0x800'0fde: 0xb14a          CBZ      R2, @8000ff4
  0x800'0fe0: 0xd105          BNE.N    @8000fee
  0x800'0fe2: 0xf000 0x0201   AND.W    R2, R0, #1
  0x800'0fe6: 0x0849          LSRS     R1, R1, #1
  0x800'0fe8: 0xea5f 0x0030   RRXS.W   R0, R0
  0x800'0fec: 0x4770          BX       LR
                @8000fee:
  0x800'0fee: 0x2200          MOVS     R2, #0
  0x800'0ff0: 0x2300          MOVS     R3, #0
  0x800'0ff2: 0x4770          BX       LR
                @8000ff4:
  0x800'0ff4: 0xf000 0xbec8   B.W      __aeabi_ldiv0          ; 0x800'1d88
                @8000ff8:
  0x800'0ff8: 0x000b          MOVS     R3, R1
  0x800'0ffa: 0x0002          MOVS     R2, R0
  0x800'0ffc: 0x2100          MOVS     R1, #0
  0x800'0ffe: 0x2000          MOVS     R0, #0
  0x800'1000: 0x4770          BX       LR
                @8001002:
  0x800'1002: 0x4290          CMP      R0, R2
  0x800'1004: 0xeb71 0x0c03   SBCS.W   R12, R1, R3
  0x800'1008: 0xd3f6          BCC.N    @8000ff8
  0x800'100a: 0xf5b3 0x3f80   CMP.W    R3, #65536             ; 0x1'0000
  0x800'100e: 0xd22f          BCS.N    @8001070
  0x800'1010: 0xb5f0          PUSH     {R4-R7, LR}
  0x800'1012: 0xfab3 0xf783   CLZ      R7, R3
  0x800'1016: 0xfab1 0xf481   CLZ      R4, R1
  0x800'101a: 0xf1a7 0x0e0f   SUB.W    LR, R7, #15            ; 0xf
  0x800'101e: 0x1b3d          SUBS     R5, R7, R4
  0x800'1020: 0x4053          EORS     R3, R3, R2
  0x800'1022: 0xf1ce 0x0620   RSB.W    R6, LR, #32            ; 0x20
  0x800'1026: 0xfa02 0xf20e   LSL.W    R2, R2, LR
  0x800'102a: 0x41f3          RORS     R3, R3, R6
  0x800'102c: 0x4053          EORS     R3, R3, R2
  0x800'102e: 0xf1b5 0x070f   SUBS.W   R7, R5, #15            ; 0xf
  0x800'1032: 0xd846          BHI.N    @80010c2
                @8001034:
  0x800'1034: 0x3c0f          SUBS     R4, R4, #15            ; 0xf
  0x800'1036: 0x442c          ADD      R4, R4, R5
  0x800'1038: 0x4041          EORS     R1, R1, R0
  0x800'103a: 0xf1c4 0x0620   RSB.W    R6, R4, #32            ; 0x20
  0x800'103e: 0x40a0          LSLS     R0, R0, R4
  0x800'1040: 0x41f1          RORS     R1, R1, R6
  0x800'1042: 0x4041          EORS     R1, R1, R0
  0x800'1044: 0xfbb1 0xf6f3   UDIV     R6, R1, R3
  0x800'1048: 0xfb03 0x1116   MLS      R1, R3, R6, R1
  0x800'104c: 0xfba2 0x4506   UMULL    R4, R5, R2, R6
  0x800'1050: 0x1b00          SUBS     R0, R0, R4
  0x800'1052: 0x41a9          SBCS     R1, R1, R5
  0x800'1054: 0xd202          BCS.N    @800105c
  0x800'1056: 0x1e76          SUBS     R6, R6, #1
  0x800'1058: 0x1880          ADDS     R0, R0, R2
  0x800'105a: 0x4159          ADCS     R1, R1, R3
                @800105c:
  0x800'105c: 0xea80 0x0201   EOR.W    R2, R0, R1
  0x800'1060: 0xfa21 0xf30e   LSR.W    R3, R1, LR
  0x800'1064: 0xfa62 0xf20e   ROR.W    R2, R2, LR
  0x800'1068: 0x2100          MOVS     R1, #0
  0x800'106a: 0x405a          EORS     R2, R2, R3
  0x800'106c: 0x4630          MOV      R0, R6
  0x800'106e: 0xbdf0          POP      {R4-R7, PC}
                @8001070:
  0x800'1070: 0xb430          PUSH     {R4, R5}
  0x800'1072: 0xfbb1 0xfcf3   UDIV     R12, R1, R3
  0x800'1076: 0xfb03 0x111c   MLS      R1, R3, R12, R1
  0x800'107a: 0xfba2 0x450c   UMULL    R4, R5, R2, R12
  0x800'107e: 0x1b00          SUBS     R0, R0, R4
  0x800'1080: 0x41a9          SBCS     R1, R1, R5
  0x800'1082: 0xd203          BCS.N    @800108c
  0x800'1084: 0xf1ac 0x0c01   SUB.W    R12, R12, #1
  0x800'1088: 0x1880          ADDS     R0, R0, R2
  0x800'108a: 0x4159          ADCS     R1, R1, R3
                @800108c:
  0x800'108c: 0xbc30          POP      {R4, R5}
  0x800'108e: 0x4602          MOV      R2, R0
  0x800'1090: 0x460b          MOV      R3, R1
  0x800'1092: 0x4660          MOV      R0, R12
  0x800'1094: 0x2100          MOVS     R1, #0
  0x800'1096: 0x4770          BX       LR
                @8001098:
  0x800'1098: 0xf1b2 0x7f80   CMP.W    R2, #16777216          ; 0x100'0000
  0x800'109c: 0xd365          BCC.N    @800116a
  0x800'109e: 0xb5f0          PUSH     {R4-R7, LR}
  0x800'10a0: 0xfab2 0xf782   CLZ      R7, R2
  0x800'10a4: 0xfab1 0xf481   CLZ      R4, R1
  0x800'10a8: 0xf1c7 0x060f   RSB.W    R6, R7, #15            ; 0xf
  0x800'10ac: 0x1b3d          SUBS     R5, R7, R4
  0x800'10ae: 0xfa22 0xf306   LSR.W    R3, R2, R6
  0x800'10b2: 0xf107 0x0e11   ADD.W    LR, R7, #17            ; 0x11
  0x800'10b6: 0x41f2          RORS     R2, R2, R6
  0x800'10b8: 0x3520          ADDS     R5, R5, #32            ; 0x20
  0x800'10ba: 0x405a          EORS     R2, R2, R3
  0x800'10bc: 0xf1b5 0x070f   SUBS.W   R7, R5, #15            ; 0xf
  0x800'10c0: 0xd9b8          BLS.N    @8001034
                @80010c2:
  0x800'10c2: 0x4041          EORS     R1, R1, R0
  0x800'10c4: 0xf1c4 0x0620   RSB.W    R6, R4, #32            ; 0x20
  0x800'10c8: 0x40a0          LSLS     R0, R0, R4
  0x800'10ca: 0x41f1          RORS     R1, R1, R6
  0x800'10cc: 0x4041          EORS     R1, R1, R0
  0x800'10ce: 0xfbb1 0xfcf3   UDIV     R12, R1, R3
  0x800'10d2: 0xfb03 0x111c   MLS      R1, R3, R12, R1
  0x800'10d6: 0xfba2 0x450c   UMULL    R4, R5, R2, R12
  0x800'10da: 0x1b00          SUBS     R0, R0, R4
  0x800'10dc: 0x41a9          SBCS     R1, R1, R5
  0x800'10de: 0xd203          BCS.N    @80010e8
  0x800'10e0: 0xf1bc 0x0c01   SUBS.W   R12, R12, #1
  0x800'10e4: 0x1880          ADDS     R0, R0, R2
  0x800'10e6: 0x4159          ADCS     R1, R1, R3
                @80010e8:
  0x800'10e8: 0x2f0f          CMP      R7, #15                ; 0xf
  0x800'10ea: 0xd312          BCC.N    @8001112
  0x800'10ec: 0x3f0f          SUBS     R7, R7, #15            ; 0xf
  0x800'10ee: 0x03c9          LSLS     R1, R1, #15
  0x800'10f0: 0xea41 0x4150   ORR.W    R1, R1, R0, LSR #17
  0x800'10f4: 0xfbb1 0xf6f3   UDIV     R6, R1, R3
  0x800'10f8: 0xfb03 0x1116   MLS      R1, R3, R6, R1
  0x800'10fc: 0xfba2 0x4506   UMULL    R4, R5, R2, R6
  0x800'1100: 0xebd4 0x30c0   RSBS.W   R0, R4, R0, LSL #15
  0x800'1104: 0x41a9          SBCS     R1, R1, R5
  0x800'1106: 0xd202          BCS.N    @800110e
  0x800'1108: 0x1e76          SUBS     R6, R6, #1
  0x800'110a: 0x1880          ADDS     R0, R0, R2
  0x800'110c: 0x4159          ADCS     R1, R1, R3
                @800110e:
  0x800'110e: 0xea46 0x3ccc   ORR.W    R12, R6, R12, LSL #15
                @8001112:
  0x800'1112: 0xb307          CBZ      R7, @8001156
  0x800'1114: 0x4041          EORS     R1, R1, R0
  0x800'1116: 0xf1c7 0x0620   RSB.W    R6, R7, #32            ; 0x20
  0x800'111a: 0x40b8          LSLS     R0, R0, R7
  0x800'111c: 0x41f1          RORS     R1, R1, R6
  0x800'111e: 0x4041          EORS     R1, R1, R0
  0x800'1120: 0xfbb1 0xf6f3   UDIV     R6, R1, R3
  0x800'1124: 0xfb03 0x1116   MLS      R1, R3, R6, R1
  0x800'1128: 0xfba2 0x4506   UMULL    R4, R5, R2, R6
  0x800'112c: 0x1b00          SUBS     R0, R0, R4
  0x800'112e: 0x41a9          SBCS     R1, R1, R5
  0x800'1130: 0xd202          BCS.N    @8001138
  0x800'1132: 0x1e76          SUBS     R6, R6, #1
  0x800'1134: 0x1880          ADDS     R0, R0, R2
  0x800'1136: 0x4159          ADCS     R1, R1, R3
                @8001138:
  0x800'1138: 0xea80 0x0201   EOR.W    R2, R0, R1
  0x800'113c: 0xfa21 0xf30e   LSR.W    R3, R1, LR
  0x800'1140: 0xf1c7 0x0420   RSB.W    R4, R7, #32            ; 0x20
  0x800'1144: 0xfa62 0xf20e   ROR.W    R2, R2, LR
  0x800'1148: 0xfa0c 0xf007   LSL.W    R0, R12, R7
  0x800'114c: 0x405a          EORS     R2, R2, R3
  0x800'114e: 0xfa2c 0xf104   LSR.W    R1, R12, R4
  0x800'1152: 0x4330          ORRS     R0, R0, R6
  0x800'1154: 0xbdf0          POP      {R4-R7, PC}
                @8001156:
  0x800'1156: 0xea80 0x0201   EOR.W    R2, R0, R1
  0x800'115a: 0xfa21 0xf30e   LSR.W    R3, R1, LR
  0x800'115e: 0x2100          MOVS     R1, #0
  0x800'1160: 0xfa62 0xf20e   ROR.W    R2, R2, LR
  0x800'1164: 0x4660          MOV      R0, R12
  0x800'1166: 0x405a          EORS     R2, R2, R3
  0x800'1168: 0xbdf0          POP      {R4-R7, PC}
                @800116a:
  0x800'116a: 0x468c          MOV      R12, R1
  0x800'116c: 0xfbb1 0xf1f2   UDIV     R1, R1, R2
  0x800'1170: 0xfb02 0xc311   MLS      R3, R2, R1, R12
  0x800'1174: 0x021b          LSLS     R3, R3, #8
  0x800'1176: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'117a: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'117e: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'1182: 0x021b          LSLS     R3, R3, #8
  0x800'1184: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'1188: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'118c: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'1190: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'1194: 0x021b          LSLS     R3, R3, #8
  0x800'1196: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'119a: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'119e: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'11a2: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'11a6: 0x021b          LSLS     R3, R3, #8
  0x800'11a8: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'11ac: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'11b0: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'11b4: 0xfb02 0x321c   MLS      R2, R2, R12, R3
  0x800'11b8: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'11bc: 0x2300          MOVS     R3, #0
  0x800'11be: 0x4770          BX       LR
                `.text6`:
                printf:
  0x800'11c0: 0xb40e          PUSH     {R1-R3}
  0x800'11c2: 0xb51e          PUSH     {R1-R4, LR}
  0x800'11c4: 0x4602          MOV      R2, R0
  0x800'11c6: 0xa805          ADD      R0, SP, #0x14
  0x800'11c8: 0x9001          STR      R0, [SP, #0x4]
  0x800'11ca: 0x2400          MOVS     R4, #0
  0x800'11cc: 0x9400          STR      R4, [SP]
  0x800'11ce: 0xab01          ADD      R3, SP, #0x4
  0x800'11d0: 0x2101          MOVS     R1, #1
  0x800'11d2: 0x4804          LDR.N    R0, ??printf_0         ; 0x2dcd (11725)
  0x800'11d4: 0x4478          ADD      R0, R0, PC
  0x800'11d6: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'11d8: 0xf000 0xfde3   BL       _PrintfTiny            ; 0x800'1da2
  0x800'11dc: 0xb003          ADD      SP, SP, #0xc
  0x800'11de: 0xbc10          POP      {R4}
  0x800'11e0: 0xf85d 0xfb10   LDR.W    PC, [SP], #0x10
                `$d.32`:
                ??printf_0:
  0x800'11e4: 0x0000'2dcd     DC32     11725                  ; '.-..'
                $t:
                `.text19`:
                HAL_IncTick:
  //   uwTick += uwTickFreq;
  0x800'11e8: 0x4803          LDR.N    R0, ??HAL_IncTick_0    ; uwTick
  0x800'11ea: 0x6801          LDR      R1, [R0]
  0x800'11ec: 0x4a03          LDR.N    R2, [PC, #0xc]         ; uwTickFreq
  0x800'11ee: 0x7812          LDRB     R2, [R2]
  0x800'11f0: 0x1889          ADDS     R1, R1, R2
  0x800'11f2: 0x6001          STR      R1, [R0]
  // }
  0x800'11f4: 0x4770          BX       LR
  0x800'11f6: 0xbf00          NOP
                `$d.32`:
                ??HAL_IncTick_0:
  0x800'11f8: 0x2000'2440     DC32     uwTick
  0x800'11fc: 0x2000'0014     DC32     uwTickFreq
                $t:
                `.text8`:
                HAL_TIM_Base_Init:
  // HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
  // {
  0x800'1200: 0xb510          PUSH     {R4, LR}
  0x800'1202: 0x0004          MOVS     R4, R0
  //   if (htim == NULL)
  0x800'1204: 0x2c00          CMP      R4, #0
  0x800'1206: 0xd101          BNE.N    ??HAL_TIM_Base_Init_0  ; 0x800'120c
  //     return HAL_ERROR;
  0x800'1208: 0x2001          MOVS     R0, #1
  0x800'120a: 0xe0d4          B.N      ??HAL_TIM_Base_Init_1  ; 0x800'13b6
                ??HAL_TIM_Base_Init_0:
  //   assert_param(IS_TIM_INSTANCE(htim->Instance));
  0x800'120c: 0x6821          LDR      R1, [R4]
  0x800'120e: 0xf8df 0x02d8   LDR.W    R0, ??DataTable7       ; 0x4001'0000
  0x800'1212: 0x4281          CMP      R1, R0
  0x800'1214: 0xd045          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1216: 0x6820          LDR      R0, [R4]
  0x800'1218: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'121c: 0xd041          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'121e: 0x6821          LDR      R1, [R4]
  0x800'1220: 0xf8df 0x02c8   LDR.W    R0, ??DataTable7_1     ; 0x4000'0400
  0x800'1224: 0x4281          CMP      R1, R0
  0x800'1226: 0xd03c          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1228: 0x6821          LDR      R1, [R4]
  0x800'122a: 0xf8df 0x02c4   LDR.W    R0, ??DataTable7_2     ; 0x4000'0800
  0x800'122e: 0x4281          CMP      R1, R0
  0x800'1230: 0xd037          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1232: 0x6821          LDR      R1, [R4]
  0x800'1234: 0xf8df 0x02bc   LDR.W    R0, ??DataTable7_3     ; 0x4000'0c00
  0x800'1238: 0x4281          CMP      R1, R0
  0x800'123a: 0xd032          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'123c: 0x6821          LDR      R1, [R4]
  0x800'123e: 0xf8df 0x02b8   LDR.W    R0, ??DataTable7_4     ; 0x4000'1000
  0x800'1242: 0x4281          CMP      R1, R0
  0x800'1244: 0xd02d          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1246: 0x6821          LDR      R1, [R4]
  0x800'1248: 0xf8df 0x02b0   LDR.W    R0, ??DataTable7_5     ; 0x4000'1400
  0x800'124c: 0x4281          CMP      R1, R0
  0x800'124e: 0xd028          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1250: 0x6821          LDR      R1, [R4]
  0x800'1252: 0xf8df 0x02ac   LDR.W    R0, ??DataTable7_6     ; 0x4001'0400
  0x800'1256: 0x4281          CMP      R1, R0
  0x800'1258: 0xd023          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'125a: 0x6821          LDR      R1, [R4]
  0x800'125c: 0xf8df 0x02a4   LDR.W    R0, ??DataTable7_7     ; 0x4001'4000
  0x800'1260: 0x4281          CMP      R1, R0
  0x800'1262: 0xd01e          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1264: 0x6820          LDR      R0, [R4]
  0x800'1266: 0xf8df 0x12a0   LDR.W    R1, ??DataTable7_8     ; 0x4001'4400
  0x800'126a: 0x4288          CMP      R0, R1
  0x800'126c: 0xd019          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'126e: 0x6821          LDR      R1, [R4]
  0x800'1270: 0xf8df 0x0298   LDR.W    R0, ??DataTable7_9     ; 0x4001'4800
  0x800'1274: 0x4281          CMP      R1, R0
  0x800'1276: 0xd014          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1278: 0x6821          LDR      R1, [R4]
  0x800'127a: 0xf8df 0x0294   LDR.W    R0, ??DataTable7_10    ; 0x4000'1800
  0x800'127e: 0x4281          CMP      R1, R0
  0x800'1280: 0xd00f          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1282: 0x6821          LDR      R1, [R4]
  0x800'1284: 0xf8df 0x028c   LDR.W    R0, ??DataTable7_11    ; 0x4000'1c00
  0x800'1288: 0x4281          CMP      R1, R0
  0x800'128a: 0xd00a          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'128c: 0x6821          LDR      R1, [R4]
  0x800'128e: 0xf8df 0x0288   LDR.W    R0, ??DataTable7_12    ; 0x4000'2000
  0x800'1292: 0x4281          CMP      R1, R0
  0x800'1294: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1296: 0xf240 0x1113   MOVW     R1, #275               ; 0x113
  0x800'129a: 0xf8df 0x0280   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'129e: 0xf7ff 0xfd52   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_2:
  //   assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  0x800'12a2: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12a4: 0x2800          CMP      R0, #0
  0x800'12a6: 0xd011          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12a8: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12aa: 0x2810          CMP      R0, #16                ; 0x10
  0x800'12ac: 0xd00e          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12ae: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12b0: 0x2820          CMP      R0, #32                ; 0x20
  0x800'12b2: 0xd00b          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12b4: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12b6: 0x2840          CMP      R0, #64                ; 0x40
  0x800'12b8: 0xd008          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12ba: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12bc: 0x2860          CMP      R0, #96                ; 0x60
  0x800'12be: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12c0: 0xf44f 0x718a   MOV.W    R1, #276               ; 0x114
  0x800'12c4: 0xf8df 0x0254   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'12c8: 0xf7ff 0xfd3d   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_3:
  //   assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  0x800'12cc: 0x6920          LDR      R0, [R4, #0x10]
  0x800'12ce: 0x2800          CMP      R0, #0
  0x800'12d0: 0xd00d          BEQ.N    ??HAL_TIM_Base_Init_4  ; 0x800'12ee
  0x800'12d2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'12d4: 0xf5b0 0x7f80   CMP.W    R0, #256               ; 0x100
  0x800'12d8: 0xd009          BEQ.N    ??HAL_TIM_Base_Init_4  ; 0x800'12ee
  0x800'12da: 0x6920          LDR      R0, [R4, #0x10]
  0x800'12dc: 0xf5b0 0x7f00   CMP.W    R0, #512               ; 0x200
  0x800'12e0: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_4  ; 0x800'12ee
  0x800'12e2: 0xf240 0x1115   MOVW     R1, #277               ; 0x115
  0x800'12e6: 0xf8df 0x0234   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'12ea: 0xf7ff 0xfd2c   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_4:
  //   assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  0x800'12ee: 0x6820          LDR      R0, [R4]
  0x800'12f0: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'12f4: 0xd004          BEQ.N    ??HAL_TIM_Base_Init_5  ; 0x800'1300
  0x800'12f6: 0x6821          LDR      R1, [R4]
  0x800'12f8: 0xf8df 0x01f8   LDR.W    R0, ??DataTable7_3     ; 0x4000'0c00
  0x800'12fc: 0x4281          CMP      R1, R0
  0x800'12fe: 0xd101          BNE.N    ??HAL_TIM_Base_Init_6  ; 0x800'1304
                ??HAL_TIM_Base_Init_5:
  0x800'1300: 0x2001          MOVS     R0, #1
  0x800'1302: 0xe000          B.N      ??HAL_TIM_Base_Init_7  ; 0x800'1306
                ??HAL_TIM_Base_Init_6:
  0x800'1304: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Init_7:
  0x800'1306: 0xb2c0          UXTB     R0, R0
  0x800'1308: 0x2800          CMP      R0, #0
  0x800'130a: 0xd10a          BNE.N    ??HAL_TIM_Base_Init_8  ; 0x800'1322
  0x800'130c: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'130e: 0x2800          CMP      R0, #0
  0x800'1310: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_9  ; 0x800'131e
  0x800'1312: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1314: 0xf5b0 0x3f80   CMP.W    R0, #65536             ; 0x1'0000
  0x800'1318: 0xd201          BCS.N    ??HAL_TIM_Base_Init_9  ; 0x800'131e
  0x800'131a: 0x2001          MOVS     R0, #1
  0x800'131c: 0xe007          B.N      ??HAL_TIM_Base_Init_10 ; 0x800'132e
                ??HAL_TIM_Base_Init_9:
  0x800'131e: 0x2000          MOVS     R0, #0
  0x800'1320: 0xe005          B.N      ??HAL_TIM_Base_Init_10 ; 0x800'132e
                ??HAL_TIM_Base_Init_8:
  0x800'1322: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1324: 0x2800          CMP      R0, #0
  0x800'1326: 0xd001          BEQ.N    ??HAL_TIM_Base_Init_11 ; 0x800'132c
  0x800'1328: 0x2001          MOVS     R0, #1
  0x800'132a: 0xe000          B.N      ??HAL_TIM_Base_Init_10 ; 0x800'132e
                ??HAL_TIM_Base_Init_11:
  0x800'132c: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Init_10:
  0x800'132e: 0x2800          CMP      R0, #0
  0x800'1330: 0xd105          BNE.N    ??HAL_TIM_Base_Init_12 ; 0x800'133e
  0x800'1332: 0xf44f 0x718b   MOV.W    R1, #278               ; 0x116
  0x800'1336: 0xf8df 0x01e4   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'133a: 0xf7ff 0xfd04   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_12:
  //   assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
  0x800'133e: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'1340: 0x2800          CMP      R0, #0
  0x800'1342: 0xd008          BEQ.N    ??HAL_TIM_Base_Init_13 ; 0x800'1356
  0x800'1344: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'1346: 0x2880          CMP      R0, #128               ; 0x80
  0x800'1348: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_13 ; 0x800'1356
  0x800'134a: 0xf240 0x1117   MOVW     R1, #279               ; 0x117
  0x800'134e: 0xf8df 0x01cc   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'1352: 0xf7ff 0xfcf8   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_13:
  //   if (htim->State == HAL_TIM_STATE_RESET)
  0x800'1356: 0xf894 0x003d   LDRB.W   R0, [R4, #0x3d]
  0x800'135a: 0x2800          CMP      R0, #0
  0x800'135c: 0xd105          BNE.N    ??HAL_TIM_Base_Init_14 ; 0x800'136a
  //     htim->Lock = HAL_UNLOCKED;
  0x800'135e: 0x2000          MOVS     R0, #0
  0x800'1360: 0xf884 0x003c   STRB.W   R0, [R4, #0x3c]
  //     HAL_TIM_Base_MspInit(htim);
  0x800'1364: 0x0020          MOVS     R0, R4
  0x800'1366: 0xf000 0xfdac   BL       HAL_TIM_Base_MspInit   ; 0x800'1ec2
                ??HAL_TIM_Base_Init_14:
  //   htim->State = HAL_TIM_STATE_BUSY;
  0x800'136a: 0x2002          MOVS     R0, #2
  0x800'136c: 0xf884 0x003d   STRB.W   R0, [R4, #0x3d]
  //   TIM_Base_SetConfig(htim->Instance, &htim->Init);
  0x800'1370: 0x1d21          ADDS     R1, R4, #4
  0x800'1372: 0x6820          LDR      R0, [R4]
  0x800'1374: 0xf000 0xf973   BL       TIM_Base_SetConfig     ; 0x800'165e
  //   htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
  0x800'1378: 0x2001          MOVS     R0, #1
  0x800'137a: 0xf884 0x0046   STRB.W   R0, [R4, #0x46]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'137e: 0x2001          MOVS     R0, #1
  0x800'1380: 0xf884 0x003e   STRB.W   R0, [R4, #0x3e]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'1384: 0x2001          MOVS     R0, #1
  0x800'1386: 0xf884 0x003f   STRB.W   R0, [R4, #0x3f]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'138a: 0x2001          MOVS     R0, #1
  0x800'138c: 0xf884 0x0040   STRB.W   R0, [R4, #0x40]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'1390: 0x2001          MOVS     R0, #1
  0x800'1392: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'1396: 0x2001          MOVS     R0, #1
  0x800'1398: 0xf884 0x0042   STRB.W   R0, [R4, #0x42]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'139c: 0x2001          MOVS     R0, #1
  0x800'139e: 0xf884 0x0043   STRB.W   R0, [R4, #0x43]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'13a2: 0x2001          MOVS     R0, #1
  0x800'13a4: 0xf884 0x0044   STRB.W   R0, [R4, #0x44]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'13a8: 0x2001          MOVS     R0, #1
  0x800'13aa: 0xf884 0x0045   STRB.W   R0, [R4, #0x45]
  //   htim->State = HAL_TIM_STATE_READY;
  0x800'13ae: 0x2001          MOVS     R0, #1
  0x800'13b0: 0xf884 0x003d   STRB.W   R0, [R4, #0x3d]
  //   return HAL_OK;
  0x800'13b4: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Init_1:
  0x800'13b6: 0xbd10          POP      {R4, PC}
                `.text_7`:
                HAL_TIM_Base_Start_IT:
  // HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
  // {
  0x800'13b8: 0xb570          PUSH     {R4-R6, LR}
  0x800'13ba: 0x0004          MOVS     R4, R0
  //   assert_param(IS_TIM_INSTANCE(htim->Instance));
  0x800'13bc: 0xf8df 0x6128   LDR.W    R6, ??DataTable7       ; 0x4001'0000
  0x800'13c0: 0x6820          LDR      R0, [R4]
  0x800'13c2: 0x42b0          CMP      R0, R6
  0x800'13c4: 0xd045          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13c6: 0x6820          LDR      R0, [R4]
  0x800'13c8: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'13cc: 0xd041          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13ce: 0x6821          LDR      R1, [R4]
  0x800'13d0: 0xf8df 0x0118   LDR.W    R0, ??DataTable7_1     ; 0x4000'0400
  0x800'13d4: 0x4281          CMP      R1, R0
  0x800'13d6: 0xd03c          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13d8: 0x6821          LDR      R1, [R4]
  0x800'13da: 0xf8df 0x0114   LDR.W    R0, ??DataTable7_2     ; 0x4000'0800
  0x800'13de: 0x4281          CMP      R1, R0
  0x800'13e0: 0xd037          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13e2: 0x6820          LDR      R0, [R4]
  0x800'13e4: 0xf8df 0x110c   LDR.W    R1, ??DataTable7_3     ; 0x4000'0c00
  0x800'13e8: 0x4288          CMP      R0, R1
  0x800'13ea: 0xd032          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13ec: 0x6821          LDR      R1, [R4]
  0x800'13ee: 0xf8df 0x0108   LDR.W    R0, ??DataTable7_4     ; 0x4000'1000
  0x800'13f2: 0x4281          CMP      R1, R0
  0x800'13f4: 0xd02d          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13f6: 0x6821          LDR      R1, [R4]
  0x800'13f8: 0xf8df 0x0100   LDR.W    R0, ??DataTable7_5     ; 0x4000'1400
  0x800'13fc: 0x4281          CMP      R1, R0
  0x800'13fe: 0xd028          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1400: 0x6821          LDR      R1, [R4]
  0x800'1402: 0xf8df 0x00fc   LDR.W    R0, ??DataTable7_6     ; 0x4001'0400
  0x800'1406: 0x4281          CMP      R1, R0
  0x800'1408: 0xd023          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'140a: 0x6821          LDR      R1, [R4]
  0x800'140c: 0xf8df 0x00f4   LDR.W    R0, ??DataTable7_7     ; 0x4001'4000
  0x800'1410: 0x4281          CMP      R1, R0
  0x800'1412: 0xd01e          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1414: 0x6821          LDR      R1, [R4]
  0x800'1416: 0xf8df 0x00f0   LDR.W    R0, ??DataTable7_8     ; 0x4001'4400
  0x800'141a: 0x4281          CMP      R1, R0
  0x800'141c: 0xd019          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'141e: 0x6821          LDR      R1, [R4]
  0x800'1420: 0xf8df 0x00e8   LDR.W    R0, ??DataTable7_9     ; 0x4001'4800
  0x800'1424: 0x4281          CMP      R1, R0
  0x800'1426: 0xd014          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1428: 0x6821          LDR      R1, [R4]
  0x800'142a: 0xf8df 0x00e4   LDR.W    R0, ??DataTable7_10    ; 0x4000'1800
  0x800'142e: 0x4281          CMP      R1, R0
  0x800'1430: 0xd00f          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1432: 0x6821          LDR      R1, [R4]
  0x800'1434: 0xf8df 0x00dc   LDR.W    R0, ??DataTable7_11    ; 0x4000'1c00
  0x800'1438: 0x4281          CMP      R1, R0
  0x800'143a: 0xd00a          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'143c: 0x6821          LDR      R1, [R4]
  0x800'143e: 0xf8df 0x00d8   LDR.W    R0, ??DataTable7_12    ; 0x4000'2000
  0x800'1442: 0x4281          CMP      R1, R0
  0x800'1444: 0xd005          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1446: 0xf44f 0x71e8   MOV.W    R1, #464               ; 0x1d0
  0x800'144a: 0xf8df 0x00d0   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'144e: 0xf7ff 0xfc7a   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Start_IT_0:
  //   if (htim->State != HAL_TIM_STATE_READY)
  0x800'1452: 0xf894 0x003d   LDRB.W   R0, [R4, #0x3d]
  0x800'1456: 0x2801          CMP      R0, #1
  0x800'1458: 0xd001          BEQ.N    ??HAL_TIM_Base_Start_IT_1
                                                              ; 0x800'145e
  //     return HAL_ERROR;
  0x800'145a: 0x2001          MOVS     R0, #1
  0x800'145c: 0xe042          B.N      ??HAL_TIM_Base_Start_IT_2
                                                              ; 0x800'14e4
                ??HAL_TIM_Base_Start_IT_1:
  //   htim->State = HAL_TIM_STATE_BUSY;
  0x800'145e: 0x2002          MOVS     R0, #2
  0x800'1460: 0xf884 0x003d   STRB.W   R0, [R4, #0x3d]
  //   __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
  0x800'1464: 0x6820          LDR      R0, [R4]
  0x800'1466: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'1468: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'146c: 0x6820          LDR      R0, [R4]
  0x800'146e: 0x60c1          STR      R1, [R0, #0xc]
  //   if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
  0x800'1470: 0x6820          LDR      R0, [R4]
  0x800'1472: 0x42b0          CMP      R0, R6
  0x800'1474: 0xd021          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'1476: 0x6820          LDR      R0, [R4]
  0x800'1478: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'147c: 0xd01d          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'147e: 0x6821          LDR      R1, [R4]
  0x800'1480: 0xf8df 0x0068   LDR.W    R0, ??DataTable7_1     ; 0x4000'0400
  0x800'1484: 0x4281          CMP      R1, R0
  0x800'1486: 0xd018          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'1488: 0x6821          LDR      R1, [R4]
  0x800'148a: 0xf8df 0x0064   LDR.W    R0, ??DataTable7_2     ; 0x4000'0800
  0x800'148e: 0x4281          CMP      R1, R0
  0x800'1490: 0xd013          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'1492: 0x6820          LDR      R0, [R4]
  0x800'1494: 0xf8df 0x105c   LDR.W    R1, ??DataTable7_3     ; 0x4000'0c00
  0x800'1498: 0x4288          CMP      R0, R1
  0x800'149a: 0xd00e          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'149c: 0x6821          LDR      R1, [R4]
  0x800'149e: 0xf8df 0x0060   LDR.W    R0, ??DataTable7_6     ; 0x4001'0400
  0x800'14a2: 0x4281          CMP      R1, R0
  0x800'14a4: 0xd009          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'14a6: 0x6821          LDR      R1, [R4]
  0x800'14a8: 0xf8df 0x0058   LDR.W    R0, ??DataTable7_7     ; 0x4001'4000
  0x800'14ac: 0x4281          CMP      R1, R0
  0x800'14ae: 0xd004          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'14b0: 0x6821          LDR      R1, [R4]
  0x800'14b2: 0xf8df 0x005c   LDR.W    R0, ??DataTable7_10    ; 0x4000'1800
  0x800'14b6: 0x4281          CMP      R1, R0
  0x800'14b8: 0xd10d          BNE.N    ??HAL_TIM_Base_Start_IT_4
                                                              ; 0x800'14d6
                ??HAL_TIM_Base_Start_IT_3:
  //     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
  0x800'14ba: 0x6820          LDR      R0, [R4]
  0x800'14bc: 0x6880          LDR      R0, [R0, #0x8]
  0x800'14be: 0xf010 0x0007   ANDS.W   R0, R0, #7
  0x800'14c2: 0x0005          MOVS     R5, R0
  //     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  0x800'14c4: 0x2d06          CMP      R5, #6
  0x800'14c6: 0xd00c          BEQ.N    ??HAL_TIM_Base_Start_IT_5
                                                              ; 0x800'14e2
  //       __HAL_TIM_ENABLE(htim);
  0x800'14c8: 0x6820          LDR      R0, [R4]
  0x800'14ca: 0x6801          LDR      R1, [R0]
  0x800'14cc: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'14d0: 0x6820          LDR      R0, [R4]
  0x800'14d2: 0x6001          STR      R1, [R0]
  0x800'14d4: 0xe005          B.N      ??HAL_TIM_Base_Start_IT_5
                                                              ; 0x800'14e2
                ??HAL_TIM_Base_Start_IT_4:
  //     __HAL_TIM_ENABLE(htim);
  0x800'14d6: 0x6820          LDR      R0, [R4]
  0x800'14d8: 0x6801          LDR      R1, [R0]
  0x800'14da: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'14de: 0x6820          LDR      R0, [R4]
  0x800'14e0: 0x6001          STR      R1, [R0]
                ??HAL_TIM_Base_Start_IT_5:
  //   return HAL_OK;
  0x800'14e2: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Start_IT_2:
  0x800'14e4: 0xbd70          POP      {R4-R6, PC}
  0x800'14e6: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable7:
  0x800'14e8: 0x4001'0000     DC32     0x4001'0000            ; '...@'
                ??DataTable7_1:
  0x800'14ec: 0x4000'0400     DC32     0x4000'0400            ; '...@'
                ??DataTable7_2:
  0x800'14f0: 0x4000'0800     DC32     0x4000'0800            ; '...@'
                ??DataTable7_3:
  0x800'14f4: 0x4000'0c00     DC32     0x4000'0c00            ; '...@'
                ??DataTable7_4:
  0x800'14f8: 0x4000'1000     DC32     0x4000'1000            ; '...@'
                ??DataTable7_5:
  0x800'14fc: 0x4000'1400     DC32     0x4000'1400            ; '...@'
                ??DataTable7_6:
  0x800'1500: 0x4001'0400     DC32     0x4001'0400            ; '...@'
                ??DataTable7_7:
  0x800'1504: 0x4001'4000     DC32     0x4001'4000            ; '.@.@'
                ??DataTable7_8:
  0x800'1508: 0x4001'4400     DC32     0x4001'4400            ; '.D.@'
                ??DataTable7_9:
  0x800'150c: 0x4001'4800     DC32     0x4001'4800            ; '.H.@'
                ??DataTable7_10:
  0x800'1510: 0x4000'1800     DC32     0x4000'1800            ; '...@'
                ??DataTable7_11:
  0x800'1514: 0x4000'1c00     DC32     0x4000'1c00            ; '...@'
                ??DataTable7_12:
  0x800'1518: 0x4000'2000     DC32     0x4000'2000            ; '. .@'
                ??DataTable9:
  0x800'151c: 0x0800'3e48     DC32     ?_0
                $t:
                `.text_177`:
                HAL_TIM_IRQHandler:
  // void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
  // {
  0x800'1520: 0xb570          PUSH     {R4-R6, LR}
  0x800'1522: 0x0004          MOVS     R4, R0
  //   uint32_t itsource = htim->Instance->DIER;
  0x800'1524: 0x6820          LDR      R0, [R4]
  0x800'1526: 0x68c5          LDR      R5, [R0, #0xc]
  //   uint32_t itflag   = htim->Instance->SR;
  0x800'1528: 0x6820          LDR      R0, [R4]
  0x800'152a: 0x6906          LDR      R6, [R0, #0x10]
  //   if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
  0x800'152c: 0x07b0          LSLS     R0, R6, #30
  0x800'152e: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_0 ; 0x800'1562
  //     if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
  0x800'1530: 0x07a8          LSLS     R0, R5, #30
  0x800'1532: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_0 ; 0x800'1562
  //         __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
  0x800'1534: 0xf07f 0x0102   MVNS.W   R1, #2
  0x800'1538: 0x6820          LDR      R0, [R4]
  0x800'153a: 0x6101          STR      R1, [R0, #0x10]
  //         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
  0x800'153c: 0x2001          MOVS     R0, #1
  0x800'153e: 0x7720          STRB     R0, [R4, #0x1c]
  //         if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
  0x800'1540: 0x6820          LDR      R0, [R4]
  0x800'1542: 0x6980          LDR      R0, [R0, #0x18]
  0x800'1544: 0xf010 0x0f03   TST.W    R0, #3
  0x800'1548: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_1 ; 0x800'1552
  //           HAL_TIM_IC_CaptureCallback(htim);
  0x800'154a: 0x0020          MOVS     R0, R4
  0x800'154c: 0xf000 0xfcba   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'1550: 0xe005          B.N      ??HAL_TIM_IRQHandler_2 ; 0x800'155e
                ??HAL_TIM_IRQHandler_1:
  //           HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'1552: 0x0020          MOVS     R0, R4
  0x800'1554: 0xf000 0xfcb7   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //           HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'1558: 0x0020          MOVS     R0, R4
  0x800'155a: 0xf000 0xfcb5   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_2:
  //         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'155e: 0x2000          MOVS     R0, #0
  0x800'1560: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_0:
  //   if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
  0x800'1562: 0x0770          LSLS     R0, R6, #29
  0x800'1564: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_3 ; 0x800'1598
  //     if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
  0x800'1566: 0x0768          LSLS     R0, R5, #29
  0x800'1568: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_3 ; 0x800'1598
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
  0x800'156a: 0xf07f 0x0104   MVNS.W   R1, #4
  0x800'156e: 0x6820          LDR      R0, [R4]
  0x800'1570: 0x6101          STR      R1, [R0, #0x10]
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
  0x800'1572: 0x2002          MOVS     R0, #2
  0x800'1574: 0x7720          STRB     R0, [R4, #0x1c]
  //       if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
  0x800'1576: 0x6820          LDR      R0, [R4]
  0x800'1578: 0x6980          LDR      R0, [R0, #0x18]
  0x800'157a: 0xf410 0x7f40   TST.W    R0, #768               ; 0x300
  0x800'157e: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_4 ; 0x800'1588
  //         HAL_TIM_IC_CaptureCallback(htim);
  0x800'1580: 0x0020          MOVS     R0, R4
  0x800'1582: 0xf000 0xfc9f   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'1586: 0xe005          B.N      ??HAL_TIM_IRQHandler_5 ; 0x800'1594
                ??HAL_TIM_IRQHandler_4:
  //         HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'1588: 0x0020          MOVS     R0, R4
  0x800'158a: 0xf000 0xfc9c   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //         HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'158e: 0x0020          MOVS     R0, R4
  0x800'1590: 0xf000 0xfc9a   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_5:
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'1594: 0x2000          MOVS     R0, #0
  0x800'1596: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_3:
  //   if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
  0x800'1598: 0x0730          LSLS     R0, R6, #28
  0x800'159a: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_6 ; 0x800'15ce
  //     if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
  0x800'159c: 0x0728          LSLS     R0, R5, #28
  0x800'159e: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_6 ; 0x800'15ce
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
  0x800'15a0: 0xf07f 0x0108   MVNS.W   R1, #8
  0x800'15a4: 0x6820          LDR      R0, [R4]
  0x800'15a6: 0x6101          STR      R1, [R0, #0x10]
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
  0x800'15a8: 0x2004          MOVS     R0, #4
  0x800'15aa: 0x7720          STRB     R0, [R4, #0x1c]
  //       if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
  0x800'15ac: 0x6820          LDR      R0, [R4]
  0x800'15ae: 0x69c0          LDR      R0, [R0, #0x1c]
  0x800'15b0: 0xf010 0x0f03   TST.W    R0, #3
  0x800'15b4: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_7 ; 0x800'15be
  //         HAL_TIM_IC_CaptureCallback(htim);
  0x800'15b6: 0x0020          MOVS     R0, R4
  0x800'15b8: 0xf000 0xfc84   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'15bc: 0xe005          B.N      ??HAL_TIM_IRQHandler_8 ; 0x800'15ca
                ??HAL_TIM_IRQHandler_7:
  //         HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'15be: 0x0020          MOVS     R0, R4
  0x800'15c0: 0xf000 0xfc81   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //         HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'15c4: 0x0020          MOVS     R0, R4
  0x800'15c6: 0xf000 0xfc7f   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_8:
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'15ca: 0x2000          MOVS     R0, #0
  0x800'15cc: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_6:
  //   if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
  0x800'15ce: 0x06f0          LSLS     R0, R6, #27
  0x800'15d0: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_9 ; 0x800'1604
  //     if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
  0x800'15d2: 0x06e8          LSLS     R0, R5, #27
  0x800'15d4: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_9 ; 0x800'1604
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
  0x800'15d6: 0xf07f 0x0110   MVNS.W   R1, #16                ; 0x10
  0x800'15da: 0x6820          LDR      R0, [R4]
  0x800'15dc: 0x6101          STR      R1, [R0, #0x10]
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
  0x800'15de: 0x2008          MOVS     R0, #8
  0x800'15e0: 0x7720          STRB     R0, [R4, #0x1c]
  //       if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
  0x800'15e2: 0x6820          LDR      R0, [R4]
  0x800'15e4: 0x69c0          LDR      R0, [R0, #0x1c]
  0x800'15e6: 0xf410 0x7f40   TST.W    R0, #768               ; 0x300
  0x800'15ea: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_10
                                                              ; 0x800'15f4
  //         HAL_TIM_IC_CaptureCallback(htim);
  0x800'15ec: 0x0020          MOVS     R0, R4
  0x800'15ee: 0xf000 0xfc69   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'15f2: 0xe005          B.N      ??HAL_TIM_IRQHandler_11
                                                              ; 0x800'1600
                ??HAL_TIM_IRQHandler_10:
  //         HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'15f4: 0x0020          MOVS     R0, R4
  0x800'15f6: 0xf000 0xfc66   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //         HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'15fa: 0x0020          MOVS     R0, R4
  0x800'15fc: 0xf000 0xfc64   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_11:
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'1600: 0x2000          MOVS     R0, #0
  0x800'1602: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_9:
  //   if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
  0x800'1604: 0x07f0          LSLS     R0, R6, #31
  0x800'1606: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_12
                                                              ; 0x800'161a
  //     if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
  0x800'1608: 0x07e8          LSLS     R0, R5, #31
  0x800'160a: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_12
                                                              ; 0x800'161a
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
  0x800'160c: 0xf07f 0x0001   MVNS.W   R0, #1
  0x800'1610: 0x6821          LDR      R1, [R4]
  0x800'1612: 0x6108          STR      R0, [R1, #0x10]
  //       HAL_TIM_PeriodElapsedCallback(htim);
  0x800'1614: 0x0020          MOVS     R0, R4
  0x800'1616: 0xf000 0xfc58   BL       HAL_TIM_PeriodElapsedCallback
                                                              ; 0x800'1eca
                ??HAL_TIM_IRQHandler_12:
  //   if ((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK))
  0x800'161a: 0x0630          LSLS     R0, R6, #24
  0x800'161c: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_13
                                                              ; 0x800'1630
  //     if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
  0x800'161e: 0x0628          LSLS     R0, R5, #24
  0x800'1620: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_13
                                                              ; 0x800'1630
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
  0x800'1622: 0xf07f 0x0180   MVNS.W   R1, #128               ; 0x80
  0x800'1626: 0x6820          LDR      R0, [R4]
  0x800'1628: 0x6101          STR      R1, [R0, #0x10]
  //       HAL_TIMEx_BreakCallback(htim);
  0x800'162a: 0x0020          MOVS     R0, R4
  0x800'162c: 0xf000 0xfc4e   BL       HAL_TIMEx_BreakCallback
                                                              ; 0x800'1ecc
                ??HAL_TIM_IRQHandler_13:
  //   if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
  0x800'1630: 0x0670          LSLS     R0, R6, #25
  0x800'1632: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_14
                                                              ; 0x800'1646
  //     if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
  0x800'1634: 0x0668          LSLS     R0, R5, #25
  0x800'1636: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_14
                                                              ; 0x800'1646
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
  0x800'1638: 0xf07f 0x0140   MVNS.W   R1, #64                ; 0x40
  0x800'163c: 0x6820          LDR      R0, [R4]
  0x800'163e: 0x6101          STR      R1, [R0, #0x10]
  //       HAL_TIM_TriggerCallback(htim);
  0x800'1640: 0x0020          MOVS     R0, R4
  0x800'1642: 0xf000 0xfc44   BL       HAL_TIM_TriggerCallback
                                                              ; 0x800'1ece
                ??HAL_TIM_IRQHandler_14:
  //   if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
  0x800'1646: 0x06b0          LSLS     R0, R6, #26
  0x800'1648: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_15
                                                              ; 0x800'165c
  //     if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
  0x800'164a: 0x06a8          LSLS     R0, R5, #26
  0x800'164c: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_15
                                                              ; 0x800'165c
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
  0x800'164e: 0xf07f 0x0120   MVNS.W   R1, #32                ; 0x20
  0x800'1652: 0x6820          LDR      R0, [R4]
  0x800'1654: 0x6101          STR      R1, [R0, #0x10]
  //       HAL_TIMEx_CommutCallback(htim);
  0x800'1656: 0x0020          MOVS     R0, R4
  0x800'1658: 0xf000 0xfc3a   BL       HAL_TIMEx_CommutCallback
                                                              ; 0x800'1ed0
                ??HAL_TIM_IRQHandler_15:
  // }
  0x800'165c: 0xbd70          POP      {R4-R6, PC}
                `.text_262`:
                TIM_Base_SetConfig:
  // void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
  // {
  0x800'165e: 0xb410          PUSH     {R4}
  //   tmpcr1 = TIMx->CR1;
  0x800'1660: 0x6804          LDR      R4, [R0]
  //   if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  0x800'1662: 0xf8df 0x30d4   LDR.W    R3, ??DataTable67_1    ; 0x4001'0000
  0x800'1666: 0x4298          CMP      R0, R3
  0x800'1668: 0xd012          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'166a: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'166e: 0xd00f          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1670: 0xf8df 0x20c8   LDR.W    R2, ??DataTable67_2    ; 0x4000'0400
  0x800'1674: 0x4290          CMP      R0, R2
  0x800'1676: 0xd00b          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1678: 0xf8df 0x20c4   LDR.W    R2, ??DataTable67_3    ; 0x4000'0800
  0x800'167c: 0x4290          CMP      R0, R2
  0x800'167e: 0xd007          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1680: 0xf8df 0x20c0   LDR.W    R2, ??DataTable67_4    ; 0x4000'0c00
  0x800'1684: 0x4290          CMP      R0, R2
  0x800'1686: 0xd003          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1688: 0xf8df 0x20cc   LDR.W    R2, ??DataTable70      ; 0x4001'0400
  0x800'168c: 0x4290          CMP      R0, R2
  0x800'168e: 0xd104          BNE.N    ??TIM_Base_SetConfig_1 ; 0x800'169a
                ??TIM_Base_SetConfig_0:
  //     tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
  0x800'1690: 0xf034 0x0470   BICS.W   R4, R4, #112           ; 0x70
  //     tmpcr1 |= Structure->CounterMode;
  0x800'1694: 0x0022          MOVS     R2, R4
  0x800'1696: 0x684c          LDR      R4, [R1, #0x4]
  0x800'1698: 0x4314          ORRS     R4, R4, R2
                ??TIM_Base_SetConfig_1:
  //   if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  0x800'169a: 0x4298          CMP      R0, R3
  0x800'169c: 0xd027          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'169e: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'16a2: 0xd024          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16a4: 0xf8df 0x2094   LDR.W    R2, ??DataTable67_2    ; 0x4000'0400
  0x800'16a8: 0x4290          CMP      R0, R2
  0x800'16aa: 0xd020          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16ac: 0xf8df 0x2090   LDR.W    R2, ??DataTable67_3    ; 0x4000'0800
  0x800'16b0: 0x4290          CMP      R0, R2
  0x800'16b2: 0xd01c          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16b4: 0xf8df 0x208c   LDR.W    R2, ??DataTable67_4    ; 0x4000'0c00
  0x800'16b8: 0x4290          CMP      R0, R2
  0x800'16ba: 0xd018          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16bc: 0xf8df 0x2098   LDR.W    R2, ??DataTable70      ; 0x4001'0400
  0x800'16c0: 0x4290          CMP      R0, R2
  0x800'16c2: 0xd014          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16c4: 0x4a1a          LDR.N    R2, ??DataTable66      ; 0x4001'4000
  0x800'16c6: 0x4290          CMP      R0, R2
  0x800'16c8: 0xd011          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16ca: 0xf8df 0x207c   LDR.W    R2, ??DataTable67_5    ; 0x4001'4400
  0x800'16ce: 0x4290          CMP      R0, R2
  0x800'16d0: 0xd00d          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16d2: 0xf8df 0x2078   LDR.W    R2, ??DataTable67_6    ; 0x4001'4800
  0x800'16d6: 0x4290          CMP      R0, R2
  0x800'16d8: 0xd009          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16da: 0x4a16          LDR.N    R2, ??DataTable67      ; 0x4000'1800
  0x800'16dc: 0x4290          CMP      R0, R2
  0x800'16de: 0xd006          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16e0: 0xf8df 0x206c   LDR.W    R2, ??DataTable67_7    ; 0x4000'1c00
  0x800'16e4: 0x4290          CMP      R0, R2
  0x800'16e6: 0xd002          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16e8: 0x4a1a          LDR.N    R2, ??DataTable67_8    ; 0x4000'2000
  0x800'16ea: 0x4290          CMP      R0, R2
  0x800'16ec: 0xd104          BNE.N    ??TIM_Base_SetConfig_3 ; 0x800'16f8
                ??TIM_Base_SetConfig_2:
  //     tmpcr1 &= ~TIM_CR1_CKD;
  0x800'16ee: 0xf434 0x7440   BICS.W   R4, R4, #768           ; 0x300
  //     tmpcr1 |= (uint32_t)Structure->ClockDivision;
  0x800'16f2: 0x0022          MOVS     R2, R4
  0x800'16f4: 0x68cc          LDR      R4, [R1, #0xc]
  0x800'16f6: 0x4314          ORRS     R4, R4, R2
                ??TIM_Base_SetConfig_3:
  //   MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
  0x800'16f8: 0xf034 0x0480   BICS.W   R4, R4, #128           ; 0x80
  0x800'16fc: 0x694a          LDR      R2, [R1, #0x14]
  0x800'16fe: 0x4314          ORRS     R4, R4, R2
  //   TIMx->CR1 = tmpcr1;
  0x800'1700: 0x6004          STR      R4, [R0]
  //   TIMx->ARR = (uint32_t)Structure->Period ;
  0x800'1702: 0x688a          LDR      R2, [R1, #0x8]
  0x800'1704: 0x62c2          STR      R2, [R0, #0x2c]
  //   TIMx->PSC = Structure->Prescaler;
  0x800'1706: 0x680a          LDR      R2, [R1]
  0x800'1708: 0x6282          STR      R2, [R0, #0x28]
  //   if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
  0x800'170a: 0x4298          CMP      R0, R3
  0x800'170c: 0xd003          BEQ.N    ??TIM_Base_SetConfig_4 ; 0x800'1716
  0x800'170e: 0xf8df 0x2048   LDR.W    R2, ??DataTable70      ; 0x4001'0400
  0x800'1712: 0x4290          CMP      R0, R2
  0x800'1714: 0xd101          BNE.N    ??TIM_Base_SetConfig_5 ; 0x800'171a
                ??TIM_Base_SetConfig_4:
  //     TIMx->RCR = Structure->RepetitionCounter;
  0x800'1716: 0x690a          LDR      R2, [R1, #0x10]
  0x800'1718: 0x6302          STR      R2, [R0, #0x30]
                ??TIM_Base_SetConfig_5:
  //   TIMx->EGR = TIM_EGR_UG;
  0x800'171a: 0x2201          MOVS     R2, #1
  0x800'171c: 0x6142          STR      R2, [R0, #0x14]
  //   if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
  0x800'171e: 0x6902          LDR      R2, [R0, #0x10]
  0x800'1720: 0x07d2          LSLS     R2, R2, #31
  0x800'1722: 0xd503          BPL.N    ??TIM_Base_SetConfig_6 ; 0x800'172c
  //     CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
  0x800'1724: 0x6902          LDR      R2, [R0, #0x10]
  0x800'1726: 0x0852          LSRS     R2, R2, #1
  0x800'1728: 0x0052          LSLS     R2, R2, #1
  0x800'172a: 0x6102          STR      R2, [R0, #0x10]
                ??TIM_Base_SetConfig_6:
  // }
  0x800'172c: 0xbc10          POP      {R4}
  0x800'172e: 0x4770          BX       LR
                `$d.32`:
                ??DataTable66:
  0x800'1730: 0x4001'4000     DC32     0x4001'4000            ; '.@.@'
                ??DataTable67:
  0x800'1734: 0x4000'1800     DC32     0x4000'1800            ; '...@'
                ??DataTable67_1:
  0x800'1738: 0x4001'0000     DC32     0x4001'0000            ; '...@'
                ??DataTable67_2:
  0x800'173c: 0x4000'0400     DC32     0x4000'0400            ; '...@'
                ??DataTable67_3:
  0x800'1740: 0x4000'0800     DC32     0x4000'0800            ; '...@'
                ??DataTable67_4:
  0x800'1744: 0x4000'0c00     DC32     0x4000'0c00            ; '...@'
                ??DataTable67_5:
  0x800'1748: 0x4001'4400     DC32     0x4001'4400            ; '.D.@'
                ??DataTable67_6:
  0x800'174c: 0x4001'4800     DC32     0x4001'4800            ; '.H.@'
                ??DataTable67_7:
  0x800'1750: 0x4000'1c00     DC32     0x4000'1c00            ; '...@'
                ??DataTable67_8:
  0x800'1754: 0x4000'2000     DC32     0x4000'2000            ; '. .@'
                ??DataTable70:
  0x800'1758: 0x4001'0400     DC32     0x4001'0400            ; '...@'
                $t:
                `.text6`:
                __iar_Memset:
                __aeabi_memset:
  0x800'175c: 0xf362 0x220f   BFI      R2, R2, #8, #8
  0x800'1760: 0xf362 0x421f   BFI      R2, R2, #16, #16
                `.text_1`:
                __iar_Memset_word:
  0x800'1764: 0x1840          ADDS     R0, R0, R1
  0x800'1766: 0xf010 0x0303   ANDS.W   R3, R0, #3
  0x800'176a: 0xd008          BEQ.N    @800177e
  0x800'176c: 0x1ac9          SUBS     R1, R1, R3
  0x800'176e: 0xd31f          BCC.N    @80017b0
  0x800'1770: 0x07db          LSLS     R3, R3, #31
  0x800'1772: 0xbf48          IT       MI
  0x800'1774: 0xf800 0x2d01   STRBMI.W R2, [R0, #-0x1]!
  0x800'1778: 0xbf28          IT       CS
  0x800'177a: 0xf820 0x2d02   STRHCS.W R2, [R0, #-0x2]!
                @800177e:
  0x800'177e: 0x0013          MOVS     R3, R2
  0x800'1780: 0xb430          PUSH     {R4, R5}
  0x800'1782: 0x4614          MOV      R4, R2
  0x800'1784: 0x4615          MOV      R5, R2
                @8001786:
  0x800'1786: 0x3910          SUBS     R1, R1, #16            ; 0x10
  0x800'1788: 0xbf28          IT       CS
  0x800'178a: 0xe920 0x003c   STMDBCS  R0!, {R2-R5}
  0x800'178e: 0xd8fa          BHI.N    @8001786
  0x800'1790: 0x0749          LSLS     R1, R1, #29
  0x800'1792: 0xbf28          IT       CS
  0x800'1794: 0xe920 0x000c   STMDBCS  R0!, {R2, R3}
  0x800'1798: 0xbf48          IT       MI
  0x800'179a: 0xf840 0x2d04   STRMI.W  R2, [R0, #-0x4]!
  0x800'179e: 0x0089          LSLS     R1, R1, #2
  0x800'17a0: 0xbf28          IT       CS
  0x800'17a2: 0xf820 0x2d02   STRHCS.W R2, [R0, #-0x2]!
  0x800'17a6: 0xbf48          IT       MI
  0x800'17a8: 0xf800 0x2d01   STRBMI.W R2, [R0, #-0x1]!
  0x800'17ac: 0xbc30          POP      {R4, R5}
  0x800'17ae: 0x4770          BX       LR
                @80017b0:
  0x800'17b0: 0x18c9          ADDS     R1, R1, R3
  0x800'17b2: 0xbf18          IT       NE
  0x800'17b4: 0xf800 0x2d01   STRBNE.W R2, [R0, #-0x1]!
  0x800'17b8: 0x07cb          LSLS     R3, R1, #31
  0x800'17ba: 0xbf28          IT       CS
  0x800'17bc: 0xf800 0x2d01   STRBCS.W R2, [R0, #-0x1]!
  0x800'17c0: 0x4770          BX       LR
                `.text7`:
                __iar_copy_init3:
  0x800'17c2: 0xe00e          B.N      ??__iar_copy_init3_2   ; 0x800'17e2
                ??__iar_copy_init3_5:
  0x800'17c4: 0x6802          LDR      R2, [R0]
  0x800'17c6: 0x6843          LDR      R3, [R0, #0x4]
  0x800'17c8: 0x4402          ADD      R2, R2, R0
  0x800'17ca: 0x3008          ADDS     R0, R0, #8
  0x800'17cc: 0xea5f 0x7cc3   LSLS.W   R12, R3, #31
  0x800'17d0: 0xbf44          ITT      MI
  0x800'17d2: 0x444b          ADDMI    R3, R3, R9
  0x800'17d4: 0x1e5b          SUBMI    R3, R3, #1
                ??__iar_copy_init3_4:
  0x800'17d6: 0xf852 0xcb04   LDR.W    R12, [R2], #0x4
  0x800'17da: 0xf843 0xcb04   STR.W    R12, [R3], #0x4
  0x800'17de: 0x1f09          SUBS     R1, R1, #4
  0x800'17e0: 0xd1f9          BNE.N    ??__iar_copy_init3_4   ; 0x800'17d6
                ??__iar_copy_init3_2:
  0x800'17e2: 0xf850 0x1b04   LDR.W    R1, [R0], #0x4
  0x800'17e6: 0x2900          CMP      R1, #0
  0x800'17e8: 0xd1ec          BNE.N    ??__iar_copy_init3_5   ; 0x800'17c4
  0x800'17ea: 0x4770          BX       LR
                `.text8`:
                HAL_GPIO_Init:
  // void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
  // {
  0x800'17ec: 0xe92d 0x4ff8   PUSH.W   {R3-R11, LR}
  0x800'17f0: 0x4683          MOV      R11, R0
  0x800'17f2: 0x000c          MOVS     R4, R1
  //   uint32_t ioposition = 0x00U;
  0x800'17f4: 0x2500          MOVS     R5, #0
  //   uint32_t iocurrent = 0x00U;
  0x800'17f6: 0x2600          MOVS     R6, #0
  //   uint32_t temp = 0x00U;
  0x800'17f8: 0x2700          MOVS     R7, #0
  //   assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  0x800'17fa: 0xf8df 0x83e4   LDR.W    R8, ??DataTable6       ; 0x4002'0000
  0x800'17fe: 0x45c3          CMP      R11, R8
  0x800'1800: 0xd024          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1802: 0xf8df 0x03e0   LDR.W    R0, ??DataTable6_1     ; 0x4002'0400
  0x800'1806: 0x4583          CMP      R11, R0
  0x800'1808: 0xd020          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'180a: 0xf8df 0x03dc   LDR.W    R0, ??DataTable6_2     ; 0x4002'0800
  0x800'180e: 0x4583          CMP      R11, R0
  0x800'1810: 0xd01c          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1812: 0xf8df 0x03d8   LDR.W    R0, ??DataTable6_3     ; 0x4002'0c00
  0x800'1816: 0x4583          CMP      R11, R0
  0x800'1818: 0xd018          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'181a: 0xf8df 0x03d4   LDR.W    R0, ??DataTable6_4     ; 0x4002'1000
  0x800'181e: 0x4583          CMP      R11, R0
  0x800'1820: 0xd014          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1822: 0xf8df 0x03d0   LDR.W    R0, ??DataTable6_5     ; 0x4002'1400
  0x800'1826: 0x4583          CMP      R11, R0
  0x800'1828: 0xd010          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'182a: 0xf8df 0x03cc   LDR.W    R0, ??DataTable6_6     ; 0x4002'1800
  0x800'182e: 0x4583          CMP      R11, R0
  0x800'1830: 0xd00c          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1832: 0xf8df 0x03c8   LDR.W    R0, ??DataTable6_7     ; 0x4002'1c00
  0x800'1836: 0x4583          CMP      R11, R0
  0x800'1838: 0xd008          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'183a: 0xf8df 0x03c4   LDR.W    R0, ??DataTable6_8     ; 0x4002'2000
  0x800'183e: 0x4583          CMP      R11, R0
  0x800'1840: 0xd004          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1842: 0x21ac          MOVS     R1, #172               ; 0xac
  0x800'1844: 0xf8df 0x03bc   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1848: 0xf7ff 0xfa7d   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_0:
  //   assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  0x800'184c: 0x6820          LDR      R0, [R4]
  0x800'184e: 0x0400          LSLS     R0, R0, #16
  0x800'1850: 0xd004          BEQ.N    ??HAL_GPIO_Init_1      ; 0x800'185c
  0x800'1852: 0x6820          LDR      R0, [R4]
  0x800'1854: 0x0c00          LSRS     R0, R0, #16
  0x800'1856: 0x0400          LSLS     R0, R0, #16
  0x800'1858: 0x2800          CMP      R0, #0
  0x800'185a: 0xd004          BEQ.N    ??HAL_GPIO_Init_2      ; 0x800'1866
                ??HAL_GPIO_Init_1:
  0x800'185c: 0x21ad          MOVS     R1, #173               ; 0xad
  0x800'185e: 0xf8df 0x03a4   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1862: 0xf7ff 0xfa70   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_2:
  //   assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  0x800'1866: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1868: 0x2800          CMP      R0, #0
  0x800'186a: 0xd02b          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'186c: 0x6860          LDR      R0, [R4, #0x4]
  0x800'186e: 0x2801          CMP      R0, #1
  0x800'1870: 0xd028          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1872: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1874: 0x2811          CMP      R0, #17                ; 0x11
  0x800'1876: 0xd025          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1878: 0x6860          LDR      R0, [R4, #0x4]
  0x800'187a: 0x2802          CMP      R0, #2
  0x800'187c: 0xd022          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'187e: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1880: 0x2812          CMP      R0, #18                ; 0x12
  0x800'1882: 0xd01f          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1884: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1886: 0xf5b0 0x1f88   CMP.W    R0, #1114112           ; 0x11'0000
  0x800'188a: 0xd01b          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'188c: 0x6860          LDR      R0, [R4, #0x4]
  0x800'188e: 0xf5b0 0x1f04   CMP.W    R0, #2162688           ; 0x21'0000
  0x800'1892: 0xd017          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1894: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1896: 0xf5b0 0x1f44   CMP.W    R0, #3211264           ; 0x31'0000
  0x800'189a: 0xd013          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'189c: 0x6860          LDR      R0, [R4, #0x4]
  0x800'189e: 0xf5b0 0x1f90   CMP.W    R0, #1179648           ; 0x12'0000
  0x800'18a2: 0xd00f          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18a4: 0x6860          LDR      R0, [R4, #0x4]
  0x800'18a6: 0xf5b0 0x1f08   CMP.W    R0, #2228224           ; 0x22'0000
  0x800'18aa: 0xd00b          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18ac: 0x6860          LDR      R0, [R4, #0x4]
  0x800'18ae: 0xf5b0 0x1f48   CMP.W    R0, #3276800           ; 0x32'0000
  0x800'18b2: 0xd007          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18b4: 0x6860          LDR      R0, [R4, #0x4]
  0x800'18b6: 0x2803          CMP      R0, #3
  0x800'18b8: 0xd004          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18ba: 0x21ae          MOVS     R1, #174               ; 0xae
  0x800'18bc: 0xf8df 0x0344   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'18c0: 0xf7ff 0xfa41   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_3:
  //   for(position = 0U; position < GPIO_NUMBER; position++)
  0x800'18c4: 0xf05f 0x0900   MOVS.W   R9, #0
                ??HAL_GPIO_Init_4:
  //   for(position = 0U; position < GPIO_NUMBER; position++)
  0x800'18c8: 0xf1b9 0x0f10   CMP.W    R9, #16                ; 0x10
  0x800'18cc: 0xf080 0x8185   BCS.W    ??HAL_GPIO_Init_5      ; 0x800'1bda
  //     ioposition = 0x01U << position;
  0x800'18d0: 0xf05f 0x0a01   MOVS.W   R10, #1
  0x800'18d4: 0xfa1a 0xf009   LSLS.W   R0, R10, R9
  0x800'18d8: 0x0005          MOVS     R5, R0
  //     iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  0x800'18da: 0x6820          LDR      R0, [R4]
  0x800'18dc: 0x4028          ANDS     R0, R0, R5
  0x800'18de: 0x0006          MOVS     R6, R0
  //     if(iocurrent == ioposition)
  0x800'18e0: 0x42ae          CMP      R6, R5
  0x800'18e2: 0xf040 0x8177   BNE.W    ??HAL_GPIO_Init_6      ; 0x800'1bd4
  //       if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
  //           (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
  0x800'18e6: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'18e8: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'18ec: 0x2801          CMP      R0, #1
  0x800'18ee: 0xd004          BEQ.N    ??HAL_GPIO_Init_7      ; 0x800'18fa
  0x800'18f0: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'18f2: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'18f6: 0x2802          CMP      R0, #2
  0x800'18f8: 0xd12f          BNE.N    ??HAL_GPIO_Init_8      ; 0x800'195a
                ??HAL_GPIO_Init_7:
  //         assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
  0x800'18fa: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'18fc: 0x2800          CMP      R0, #0
  0x800'18fe: 0xd00d          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'1900: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1902: 0x2801          CMP      R0, #1
  0x800'1904: 0xd00a          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'1906: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1908: 0x2802          CMP      R0, #2
  0x800'190a: 0xd007          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'190c: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'190e: 0x2803          CMP      R0, #3
  0x800'1910: 0xd004          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'1912: 0x21c0          MOVS     R1, #192               ; 0xc0
  0x800'1914: 0xf8df 0x02ec   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1918: 0xf7ff 0xfa15   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_9:
  //         temp = GPIOx->OSPEEDR;
  0x800'191c: 0xf8db 0x1008   LDR.W    R1, [R11, #0x8]
  //         temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
  0x800'1920: 0x2203          MOVS     R2, #3
  0x800'1922: 0x4648          MOV      R0, R9
  0x800'1924: 0xb2c0          UXTB     R0, R0
  0x800'1926: 0x0040          LSLS     R0, R0, #1
  0x800'1928: 0x4082          LSLS     R2, R2, R0
  0x800'192a: 0x4391          BICS     R1, R1, R2
  //         temp |= (GPIO_Init->Speed << (position * 2U));
  0x800'192c: 0x68e2          LDR      R2, [R4, #0xc]
  0x800'192e: 0x4648          MOV      R0, R9
  0x800'1930: 0xb2c0          UXTB     R0, R0
  0x800'1932: 0x0040          LSLS     R0, R0, #1
  0x800'1934: 0x4082          LSLS     R2, R2, R0
  0x800'1936: 0x4311          ORRS     R1, R1, R2
  //         GPIOx->OSPEEDR = temp;
  0x800'1938: 0xf8cb 0x1008   STR.W    R1, [R11, #0x8]
  //         temp = GPIOx->OTYPER;
  0x800'193c: 0xf8db 0x0004   LDR.W    R0, [R11, #0x4]
  //         temp &= ~(GPIO_OTYPER_OT_0 << position) ;
  0x800'1940: 0xfa1a 0xfa09   LSLS.W   R10, R10, R9
  0x800'1944: 0xea30 0x000a   BICS.W   R0, R0, R10
  //         temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
  0x800'1948: 0x6862          LDR      R2, [R4, #0x4]
  0x800'194a: 0xf3c2 0x1200   UBFX     R2, R2, #4, #1
  0x800'194e: 0xfa12 0xf209   LSLS.W   R2, R2, R9
  0x800'1952: 0x4310          ORRS     R0, R0, R2
  0x800'1954: 0x0007          MOVS     R7, R0
  //         GPIOx->OTYPER = temp;
  0x800'1956: 0xf8cb 0x7004   STR.W    R7, [R11, #0x4]
                ??HAL_GPIO_Init_8:
  //       if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
  0x800'195a: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'195c: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'1960: 0x2803          CMP      R0, #3
  0x800'1962: 0xd01e          BEQ.N    ??HAL_GPIO_Init_10     ; 0x800'19a2
  //         assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  0x800'1964: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'1966: 0x2800          CMP      R0, #0
  0x800'1968: 0xd00a          BEQ.N    ??HAL_GPIO_Init_11     ; 0x800'1980
  0x800'196a: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'196c: 0x2801          CMP      R0, #1
  0x800'196e: 0xd007          BEQ.N    ??HAL_GPIO_Init_11     ; 0x800'1980
  0x800'1970: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'1972: 0x2802          CMP      R0, #2
  0x800'1974: 0xd004          BEQ.N    ??HAL_GPIO_Init_11     ; 0x800'1980
  0x800'1976: 0x21d1          MOVS     R1, #209               ; 0xd1
  0x800'1978: 0xf8df 0x0288   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'197c: 0xf7ff 0xf9e3   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_11:
  //         temp = GPIOx->PUPDR;
  0x800'1980: 0xf8db 0x100c   LDR.W    R1, [R11, #0xc]
  //         temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
  0x800'1984: 0x2203          MOVS     R2, #3
  0x800'1986: 0x4648          MOV      R0, R9
  0x800'1988: 0xb2c0          UXTB     R0, R0
  0x800'198a: 0x0040          LSLS     R0, R0, #1
  0x800'198c: 0x4082          LSLS     R2, R2, R0
  0x800'198e: 0x4391          BICS     R1, R1, R2
  //         temp |= ((GPIO_Init->Pull) << (position * 2U));
  0x800'1990: 0x68a2          LDR      R2, [R4, #0x8]
  0x800'1992: 0x4648          MOV      R0, R9
  0x800'1994: 0xb2c0          UXTB     R0, R0
  0x800'1996: 0x0040          LSLS     R0, R0, #1
  0x800'1998: 0x4082          LSLS     R2, R2, R0
  0x800'199a: 0x4311          ORRS     R1, R1, R2
  0x800'199c: 0x000f          MOVS     R7, R1
  //         GPIOx->PUPDR = temp;
  0x800'199e: 0xf8cb 0x700c   STR.W    R7, [R11, #0xc]
                ??HAL_GPIO_Init_10:
  //       if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
  0x800'19a2: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'19a4: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'19a8: 0x2802          CMP      R0, #2
  0x800'19aa: 0xf040 0x8084   BNE.W    ??HAL_GPIO_Init_12     ; 0x800'1ab6
  //         assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
  0x800'19ae: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19b0: 0x2800          CMP      R0, #0
  0x800'19b2: 0xd067          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19b4: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19b6: 0x2809          CMP      R0, #9
  0x800'19b8: 0xd064          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19ba: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19bc: 0x2800          CMP      R0, #0
  0x800'19be: 0xd061          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19c0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19c2: 0x2800          CMP      R0, #0
  0x800'19c4: 0xd05e          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19c6: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19c8: 0x2800          CMP      R0, #0
  0x800'19ca: 0xd05b          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19cc: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19ce: 0x2800          CMP      R0, #0
  0x800'19d0: 0xd058          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19d2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19d4: 0x2801          CMP      R0, #1
  0x800'19d6: 0xd055          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19d8: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19da: 0x2801          CMP      R0, #1
  0x800'19dc: 0xd052          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19de: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19e0: 0x2802          CMP      R0, #2
  0x800'19e2: 0xd04f          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19e4: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19e6: 0x2802          CMP      R0, #2
  0x800'19e8: 0xd04c          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19ea: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19ec: 0x2802          CMP      R0, #2
  0x800'19ee: 0xd049          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19f0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19f2: 0x2803          CMP      R0, #3
  0x800'19f4: 0xd046          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19f6: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19f8: 0x2804          CMP      R0, #4
  0x800'19fa: 0xd043          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19fc: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19fe: 0x2804          CMP      R0, #4
  0x800'1a00: 0xd040          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a02: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a04: 0x2804          CMP      R0, #4
  0x800'1a06: 0xd03d          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a08: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a0a: 0x2805          CMP      R0, #5
  0x800'1a0c: 0xd03a          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a0e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a10: 0x2805          CMP      R0, #5
  0x800'1a12: 0xd037          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a14: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a16: 0x2809          CMP      R0, #9
  0x800'1a18: 0xd034          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a1a: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a1c: 0x2806          CMP      R0, #6
  0x800'1a1e: 0xd031          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a20: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a22: 0x2809          CMP      R0, #9
  0x800'1a24: 0xd02e          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a26: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a28: 0x2807          CMP      R0, #7
  0x800'1a2a: 0xd02b          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a2c: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a2e: 0x2807          CMP      R0, #7
  0x800'1a30: 0xd028          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a32: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a34: 0x2807          CMP      R0, #7
  0x800'1a36: 0xd025          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a38: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a3a: 0x2808          CMP      R0, #8
  0x800'1a3c: 0xd022          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a3e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a40: 0x2808          CMP      R0, #8
  0x800'1a42: 0xd01f          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a44: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a46: 0x2808          CMP      R0, #8
  0x800'1a48: 0xd01c          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a4a: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a4c: 0x2809          CMP      R0, #9
  0x800'1a4e: 0xd019          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a50: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a52: 0x2809          CMP      R0, #9
  0x800'1a54: 0xd016          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a56: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a58: 0x280a          CMP      R0, #10                ; 0xa
  0x800'1a5a: 0xd013          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a5c: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a5e: 0x280a          CMP      R0, #10                ; 0xa
  0x800'1a60: 0xd010          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a62: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a64: 0x280c          CMP      R0, #12                ; 0xc
  0x800'1a66: 0xd00d          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a68: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a6a: 0x280c          CMP      R0, #12                ; 0xc
  0x800'1a6c: 0xd00a          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a6e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a70: 0x280c          CMP      R0, #12                ; 0xc
  0x800'1a72: 0xd007          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a74: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a76: 0x280f          CMP      R0, #15                ; 0xf
  0x800'1a78: 0xd004          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a7a: 0x21de          MOVS     R1, #222               ; 0xde
  0x800'1a7c: 0xf8df 0x0184   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1a80: 0xf7ff 0xf961   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_13:
  //         temp = GPIOx->AFR[position >> 3U];
  0x800'1a84: 0x4648          MOV      R0, R9
  0x800'1a86: 0x08c0          LSRS     R0, R0, #3
  0x800'1a88: 0xeb0b 0x0080   ADD.W    R0, R11, R0, LSL #2
  0x800'1a8c: 0x6a01          LDR      R1, [R0, #0x20]
  //         temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
  0x800'1a8e: 0x220f          MOVS     R2, #15                ; 0xf
  0x800'1a90: 0xf019 0x0007   ANDS.W   R0, R9, #7
  0x800'1a94: 0xb2c0          UXTB     R0, R0
  0x800'1a96: 0x0080          LSLS     R0, R0, #2
  0x800'1a98: 0x4082          LSLS     R2, R2, R0
  0x800'1a9a: 0x4391          BICS     R1, R1, R2
  //         temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
  0x800'1a9c: 0x6922          LDR      R2, [R4, #0x10]
  0x800'1a9e: 0xf019 0x0007   ANDS.W   R0, R9, #7
  0x800'1aa2: 0xb2c0          UXTB     R0, R0
  0x800'1aa4: 0x0080          LSLS     R0, R0, #2
  0x800'1aa6: 0x4082          LSLS     R2, R2, R0
  0x800'1aa8: 0x4311          ORRS     R1, R1, R2
  0x800'1aaa: 0x000f          MOVS     R7, R1
  //         GPIOx->AFR[position >> 3U] = temp;
  0x800'1aac: 0x4648          MOV      R0, R9
  0x800'1aae: 0x08c0          LSRS     R0, R0, #3
  0x800'1ab0: 0xeb0b 0x0080   ADD.W    R0, R11, R0, LSL #2
  0x800'1ab4: 0x6207          STR      R7, [R0, #0x20]
                ??HAL_GPIO_Init_12:
  //       temp = GPIOx->MODER;
  0x800'1ab6: 0xf8db 0x1000   LDR.W    R1, [R11]
  //       temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
  0x800'1aba: 0x2203          MOVS     R2, #3
  0x800'1abc: 0x4648          MOV      R0, R9
  0x800'1abe: 0xb2c0          UXTB     R0, R0
  0x800'1ac0: 0x0040          LSLS     R0, R0, #1
  0x800'1ac2: 0x4082          LSLS     R2, R2, R0
  0x800'1ac4: 0x4391          BICS     R1, R1, R2
  //       temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
  0x800'1ac6: 0x7922          LDRB     R2, [R4, #0x4]
  0x800'1ac8: 0xf012 0x0203   ANDS.W   R2, R2, #3
  0x800'1acc: 0x4648          MOV      R0, R9
  0x800'1ace: 0xb2c0          UXTB     R0, R0
  0x800'1ad0: 0x0040          LSLS     R0, R0, #1
  0x800'1ad2: 0x4082          LSLS     R2, R2, R0
  0x800'1ad4: 0x4311          ORRS     R1, R1, R2
  0x800'1ad6: 0x000f          MOVS     R7, R1
  //       GPIOx->MODER = temp;
  0x800'1ad8: 0xf8cb 0x7000   STR.W    R7, [R11]
  //       if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
  0x800'1adc: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1ade: 0xf410 0x3f40   TST.W    R0, #196608            ; 0x3'0000
  0x800'1ae2: 0xd077          BEQ.N    ??HAL_GPIO_Init_6      ; 0x800'1bd4
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1ae4: 0x2000          MOVS     R0, #0
  0x800'1ae6: 0x9000          STR      R0, [SP]
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1ae8: 0xf8df 0x111c   LDR.W    R1, ??DataTable6_10    ; 0x4002'3844
  0x800'1aec: 0x6808          LDR      R0, [R1]
  0x800'1aee: 0xf450 0x4080   ORRS.W   R0, R0, #16384         ; 0x4000
  0x800'1af2: 0x6008          STR      R0, [R1]
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1af4: 0x6808          LDR      R0, [R1]
  0x800'1af6: 0xf410 0x4080   ANDS.W   R0, R0, #16384         ; 0x4000
  0x800'1afa: 0x9000          STR      R0, [SP]
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1afc: 0x9800          LDR      R0, [SP]
  //         temp = SYSCFG->EXTICR[position >> 2U];
  0x800'1afe: 0xf8df 0x110c   LDR.W    R1, ??DataTable6_11    ; 0x4001'3808
  0x800'1b02: 0x4648          MOV      R0, R9
  0x800'1b04: 0x0880          LSRS     R0, R0, #2
  0x800'1b06: 0xf851 0x2020   LDR.W    R2, [R1, R0, LSL #2]
  //         temp &= ~(0x0FU << (4U * (position & 0x03U)));
  0x800'1b0a: 0x230f          MOVS     R3, #15                ; 0xf
  0x800'1b0c: 0xf019 0x0003   ANDS.W   R0, R9, #3
  0x800'1b10: 0xb2c0          UXTB     R0, R0
  0x800'1b12: 0x0080          LSLS     R0, R0, #2
  0x800'1b14: 0x4083          LSLS     R3, R3, R0
  0x800'1b16: 0x439a          BICS     R2, R2, R3
  //         temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
  0x800'1b18: 0x45c3          CMP      R11, R8
  0x800'1b1a: 0xd101          BNE.N    ??HAL_GPIO_Init_14     ; 0x800'1b20
  0x800'1b1c: 0x2300          MOVS     R3, #0
  0x800'1b1e: 0xe02a          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_14:
  0x800'1b20: 0xf8df 0x00c0   LDR.W    R0, ??DataTable6_1     ; 0x4002'0400
  0x800'1b24: 0x4583          CMP      R11, R0
  0x800'1b26: 0xd101          BNE.N    ??HAL_GPIO_Init_16     ; 0x800'1b2c
  0x800'1b28: 0x2301          MOVS     R3, #1
  0x800'1b2a: 0xe024          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_16:
  0x800'1b2c: 0xf8df 0x00b8   LDR.W    R0, ??DataTable6_2     ; 0x4002'0800
  0x800'1b30: 0x4583          CMP      R11, R0
  0x800'1b32: 0xd101          BNE.N    ??HAL_GPIO_Init_17     ; 0x800'1b38
  0x800'1b34: 0x2302          MOVS     R3, #2
  0x800'1b36: 0xe01e          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_17:
  0x800'1b38: 0xf8df 0x00b0   LDR.W    R0, ??DataTable6_3     ; 0x4002'0c00
  0x800'1b3c: 0x4583          CMP      R11, R0
  0x800'1b3e: 0xd101          BNE.N    ??HAL_GPIO_Init_19     ; 0x800'1b44
  0x800'1b40: 0x2303          MOVS     R3, #3
  0x800'1b42: 0xe018          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_19:
  0x800'1b44: 0xf8df 0x00a8   LDR.W    R0, ??DataTable6_4     ; 0x4002'1000
  0x800'1b48: 0x4583          CMP      R11, R0
  0x800'1b4a: 0xd101          BNE.N    ??HAL_GPIO_Init_20     ; 0x800'1b50
  0x800'1b4c: 0x2304          MOVS     R3, #4
  0x800'1b4e: 0xe012          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_20:
  0x800'1b50: 0xf8df 0x00a0   LDR.W    R0, ??DataTable6_5     ; 0x4002'1400
  0x800'1b54: 0x4583          CMP      R11, R0
  0x800'1b56: 0xd101          BNE.N    ??HAL_GPIO_Init_22     ; 0x800'1b5c
  0x800'1b58: 0x2305          MOVS     R3, #5
  0x800'1b5a: 0xe00c          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_22:
  0x800'1b5c: 0xf8df 0x0098   LDR.W    R0, ??DataTable6_6     ; 0x4002'1800
  0x800'1b60: 0x4583          CMP      R11, R0
  0x800'1b62: 0xd101          BNE.N    ??HAL_GPIO_Init_23     ; 0x800'1b68
  0x800'1b64: 0x2306          MOVS     R3, #6
  0x800'1b66: 0xe006          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_23:
  0x800'1b68: 0xf8df 0x0090   LDR.W    R0, ??DataTable6_7     ; 0x4002'1c00
  0x800'1b6c: 0x4583          CMP      R11, R0
  0x800'1b6e: 0xd101          BNE.N    ??HAL_GPIO_Init_25     ; 0x800'1b74
  0x800'1b70: 0x2307          MOVS     R3, #7
  0x800'1b72: 0xe000          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_25:
  0x800'1b74: 0x2308          MOVS     R3, #8
                ??HAL_GPIO_Init_15:
                ??HAL_GPIO_Init_18:
                ??HAL_GPIO_Init_21:
                ??HAL_GPIO_Init_24:
  0x800'1b76: 0xb2db          UXTB     R3, R3
  0x800'1b78: 0xf019 0x0003   ANDS.W   R0, R9, #3
  0x800'1b7c: 0xb2c0          UXTB     R0, R0
  0x800'1b7e: 0x0080          LSLS     R0, R0, #2
  0x800'1b80: 0x4083          LSLS     R3, R3, R0
  0x800'1b82: 0x431a          ORRS     R2, R2, R3
  //         SYSCFG->EXTICR[position >> 2U] = temp;
  0x800'1b84: 0x4648          MOV      R0, R9
  0x800'1b86: 0x0880          LSRS     R0, R0, #2
  0x800'1b88: 0xf841 0x2020   STR.W    R2, [R1, R0, LSL #2]
  //         temp = EXTI->RTSR;
  0x800'1b8c: 0xf8df 0x1080   LDR.W    R1, ??DataTable6_12    ; 0x4001'3c08
  0x800'1b90: 0x6808          LDR      R0, [R1]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1b92: 0x43b0          BICS     R0, R0, R6
  //         if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
  0x800'1b94: 0x6863          LDR      R3, [R4, #0x4]
  0x800'1b96: 0x02db          LSLS     R3, R3, #11
  0x800'1b98: 0xd500          BPL.N    ??HAL_GPIO_Init_26     ; 0x800'1b9c
  //           temp |= iocurrent;
  0x800'1b9a: 0x4330          ORRS     R0, R0, R6
                ??HAL_GPIO_Init_26:
  //         EXTI->RTSR = temp;
  0x800'1b9c: 0x6008          STR      R0, [R1]
  //         temp = EXTI->FTSR;
  0x800'1b9e: 0xf8df 0x1074   LDR.W    R1, ??DataTable6_13    ; 0x4001'3c0c
  0x800'1ba2: 0x680a          LDR      R2, [R1]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1ba4: 0x43b2          BICS     R2, R2, R6
  //         if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
  0x800'1ba6: 0x6863          LDR      R3, [R4, #0x4]
  0x800'1ba8: 0x029b          LSLS     R3, R3, #10
  0x800'1baa: 0xd500          BPL.N    ??HAL_GPIO_Init_27     ; 0x800'1bae
  //           temp |= iocurrent;
  0x800'1bac: 0x4332          ORRS     R2, R2, R6
                ??HAL_GPIO_Init_27:
  //         EXTI->FTSR = temp;
  0x800'1bae: 0x600a          STR      R2, [R1]
  //         temp = EXTI->EMR;
  0x800'1bb0: 0xf8df 0x0064   LDR.W    R0, ??DataTable6_14    ; 0x4001'3c04
  0x800'1bb4: 0x6801          LDR      R1, [R0]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1bb6: 0x43b1          BICS     R1, R1, R6
  //         if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
  0x800'1bb8: 0x6863          LDR      R3, [R4, #0x4]
  0x800'1bba: 0x039b          LSLS     R3, R3, #14
  0x800'1bbc: 0xd500          BPL.N    ??HAL_GPIO_Init_28     ; 0x800'1bc0
  //           temp |= iocurrent;
  0x800'1bbe: 0x4331          ORRS     R1, R1, R6
                ??HAL_GPIO_Init_28:
  //         EXTI->EMR = temp;
  0x800'1bc0: 0x6001          STR      R1, [R0]
  //         temp = EXTI->IMR;
  0x800'1bc2: 0xf8df 0x0058   LDR.W    R0, ??DataTable6_15    ; 0x4001'3c00
  0x800'1bc6: 0x6807          LDR      R7, [R0]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1bc8: 0x43b7          BICS     R7, R7, R6
  //         if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
  0x800'1bca: 0x6862          LDR      R2, [R4, #0x4]
  0x800'1bcc: 0x03d2          LSLS     R2, R2, #15
  0x800'1bce: 0xd500          BPL.N    ??HAL_GPIO_Init_29     ; 0x800'1bd2
  //           temp |= iocurrent;
  0x800'1bd0: 0x4337          ORRS     R7, R7, R6
                ??HAL_GPIO_Init_29:
  //         EXTI->IMR = temp;
  0x800'1bd2: 0x6007          STR      R7, [R0]
                ??HAL_GPIO_Init_6:
  //   for(position = 0U; position < GPIO_NUMBER; position++)
  0x800'1bd4: 0xf119 0x0901   ADDS.W   R9, R9, #1
  0x800'1bd8: 0xe676          B.N      ??HAL_GPIO_Init_4      ; 0x800'18c8
                ??HAL_GPIO_Init_5:
  // }
  0x800'1bda: 0xe8bd 0x8ff1   POP.W    {R0, R4-R11, PC}
  0x800'1bde: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable6:
  0x800'1be0: 0x4002'0000     DC32     0x4002'0000            ; '...@'
                ??DataTable6_1:
  0x800'1be4: 0x4002'0400     DC32     0x4002'0400            ; '...@'
                ??DataTable6_2:
  0x800'1be8: 0x4002'0800     DC32     0x4002'0800            ; '...@'
                ??DataTable6_3:
  0x800'1bec: 0x4002'0c00     DC32     0x4002'0c00            ; '...@'
                ??DataTable6_4:
  0x800'1bf0: 0x4002'1000     DC32     0x4002'1000            ; '...@'
                ??DataTable6_5:
  0x800'1bf4: 0x4002'1400     DC32     0x4002'1400            ; '...@'
                ??DataTable6_6:
  0x800'1bf8: 0x4002'1800     DC32     0x4002'1800            ; '...@'
                ??DataTable6_7:
  0x800'1bfc: 0x4002'1c00     DC32     0x4002'1c00            ; '...@'
                ??DataTable6_8:
  0x800'1c00: 0x4002'2000     DC32     0x4002'2000            ; '. .@'
                ??DataTable6_9:
  0x800'1c04: 0x0800'3dd0     DC32     ?_0
                ??DataTable6_10:
  0x800'1c08: 0x4002'3844     DC32     0x4002'3844            ; 'D8.@'
                ??DataTable6_11:
  0x800'1c0c: 0x4001'3808     DC32     0x4001'3808            ; '.8.@'
                ??DataTable6_12:
  0x800'1c10: 0x4001'3c08     DC32     0x4001'3c08            ; '.<.@'
                ??DataTable6_13:
  0x800'1c14: 0x4001'3c0c     DC32     0x4001'3c0c            ; '.<.@'
                ??DataTable6_14:
  0x800'1c18: 0x4001'3c04     DC32     0x4001'3c04            ; '.<.@'
                ??DataTable6_15:
  0x800'1c1c: 0x4001'3c00     DC32     0x4001'3c00            ; '.<.@'
                $t:
                `.text8`:
                __NVIC_SetPriorityGrouping:
  // __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
  // {
  0x800'1c20: 0xb410          PUSH     {R4}
  //   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
  0x800'1c22: 0xf010 0x0207   ANDS.W   R2, R0, #7
  //   reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  0x800'1c26: 0xf8df 0x3148   LDR.W    R3, ??DataTable24      ; 0xe000'ed0c
  0x800'1c2a: 0x681c          LDR      R4, [R3]
  //   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  0x800'1c2c: 0xf64f 0x01ff   MOVW     R1, #63743             ; 0xf8ff
  0x800'1c30: 0x400c          ANDS     R4, R4, R1
  //   reg_value  =  (reg_value                                   |
  //                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
  //                 (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  0x800'1c32: 0xea54 0x2402   ORRS.W   R4, R4, R2, LSL #8
  0x800'1c36: 0xf8df 0x113c   LDR.W    R1, ??DataTable24_1    ; 0x5fa'0000
  0x800'1c3a: 0x430c          ORRS     R4, R4, R1
  //   SCB->AIRCR =  reg_value;
  0x800'1c3c: 0x601c          STR      R4, [R3]
  // }
  0x800'1c3e: 0xbc10          POP      {R4}
  0x800'1c40: 0x4770          BX       LR
                `.text_4`:
                __NVIC_GetPriorityGrouping:
  //   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
  0x800'1c42: 0xf8df 0x012c   LDR.W    R0, ??DataTable24      ; 0xe000'ed0c
  0x800'1c46: 0x6800          LDR      R0, [R0]
  0x800'1c48: 0xf3c0 0x2002   UBFX     R0, R0, #8, #3
  0x800'1c4c: 0x4770          BX       LR
  0x800'1c4e: 0x0000          MOVS     R0, R0
                `.text_5`:
                __NVIC_EnableIRQ:
  //   if ((int32_t)(IRQn) >= 0)
  0x800'1c50: 0x0001          MOVS     R1, R0
  0x800'1c52: 0xb249          SXTB     R1, R1
  0x800'1c54: 0x2900          CMP      R1, #0
  0x800'1c56: 0xd40a          BMI.N    ??__NVIC_EnableIRQ_0   ; 0x800'1c6e
  //     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  0x800'1c58: 0x2201          MOVS     R2, #1
  0x800'1c5a: 0xf010 0x011f   ANDS.W   R1, R0, #31            ; 0x1f
  0x800'1c5e: 0x408a          LSLS     R2, R2, R1
  0x800'1c60: 0xf8df 0x3114   LDR.W    R3, ??DataTable24_2    ; 0xe000'e100
  0x800'1c64: 0x0001          MOVS     R1, R0
  0x800'1c66: 0xb249          SXTB     R1, R1
  0x800'1c68: 0x0949          LSRS     R1, R1, #5
  0x800'1c6a: 0xf843 0x2021   STR.W    R2, [R3, R1, LSL #2]
                ??__NVIC_EnableIRQ_0:
  // }
  0x800'1c6e: 0x4770          BX       LR
                `.text_11`:
                __NVIC_SetPriority:
  // __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
  // {
  0x800'1c70: 0xb410          PUSH     {R4}
  //   if ((int32_t)(IRQn) >= 0)
  0x800'1c72: 0x0002          MOVS     R2, R0
  0x800'1c74: 0xb252          SXTB     R2, R2
  0x800'1c76: 0x2a00          CMP      R2, #0
  0x800'1c78: 0xd406          BMI.N    ??__NVIC_SetPriority_0 ; 0x800'1c88
  //     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  0x800'1c7a: 0x010c          LSLS     R4, R1, #4
  0x800'1c7c: 0xf8df 0x30fc   LDR.W    R3, ??DataTable24_7    ; 0xe000'e400
  0x800'1c80: 0x0002          MOVS     R2, R0
  0x800'1c82: 0xb252          SXTB     R2, R2
  0x800'1c84: 0x549c          STRB     R4, [R3, R2]
  0x800'1c86: 0xe009          B.N      ??__NVIC_SetPriority_1 ; 0x800'1c9c
                ??__NVIC_SetPriority_0:
  //     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  0x800'1c88: 0x010a          LSLS     R2, R1, #4
  0x800'1c8a: 0xf8df 0x40f4   LDR.W    R4, ??DataTable24_8    ; 0xe000'ed18
  0x800'1c8e: 0x0003          MOVS     R3, R0
  0x800'1c90: 0xb25b          SXTB     R3, R3
  0x800'1c92: 0xf013 0x030f   ANDS.W   R3, R3, #15            ; 0xf
  0x800'1c96: 0x4423          ADD      R3, R3, R4
  0x800'1c98: 0xf803 0x2c04   STRB.W   R2, [R3, #-0x4]
                ??__NVIC_SetPriority_1:
  // }
  0x800'1c9c: 0xbc10          POP      {R4}
  0x800'1c9e: 0x4770          BX       LR
                `.text_13`:
                NVIC_EncodePriority:
  // __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
  // {
  0x800'1ca0: 0xb470          PUSH     {R4-R6}
  0x800'1ca2: 0x0003          MOVS     R3, R0
  //   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  0x800'1ca4: 0xf013 0x0407   ANDS.W   R4, R3, #7
  //   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  0x800'1ca8: 0xf1d4 0x0007   RSBS.W   R0, R4, #7
  0x800'1cac: 0x2805          CMP      R0, #5
  0x800'1cae: 0xd301          BCC.N    ??NVIC_EncodePriority_0
                                                              ; 0x800'1cb4
  0x800'1cb0: 0x2004          MOVS     R0, #4
  0x800'1cb2: 0xe001          B.N      ??NVIC_EncodePriority_1
                                                              ; 0x800'1cb8
                ??NVIC_EncodePriority_0:
  0x800'1cb4: 0xf1d4 0x0007   RSBS.W   R0, R4, #7
                ??NVIC_EncodePriority_1:
  //   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
  0x800'1cb8: 0x1d25          ADDS     R5, R4, #4
  0x800'1cba: 0x2d07          CMP      R5, #7
  0x800'1cbc: 0xd201          BCS.N    ??NVIC_EncodePriority_2
                                                              ; 0x800'1cc2
  0x800'1cbe: 0x2600          MOVS     R6, #0
  0x800'1cc0: 0xe000          B.N      ??NVIC_EncodePriority_3
                                                              ; 0x800'1cc4
                ??NVIC_EncodePriority_2:
  0x800'1cc2: 0x1ee6          SUBS     R6, R4, #3
                ??NVIC_EncodePriority_3:
  //   return (
  //            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  //            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
  //          );
  0x800'1cc4: 0x2501          MOVS     R5, #1
  0x800'1cc6: 0xfa15 0xf000   LSLS.W   R0, R5, R0
  0x800'1cca: 0x1e40          SUBS     R0, R0, #1
  0x800'1ccc: 0x4001          ANDS     R1, R1, R0
  0x800'1cce: 0x40b1          LSLS     R1, R1, R6
  0x800'1cd0: 0xfa15 0xf606   LSLS.W   R6, R5, R6
  0x800'1cd4: 0x1e76          SUBS     R6, R6, #1
  0x800'1cd6: 0x4032          ANDS     R2, R2, R6
  0x800'1cd8: 0x4311          ORRS     R1, R1, R2
  0x800'1cda: 0x0008          MOVS     R0, R1
  0x800'1cdc: 0xbc70          POP      {R4-R6}
  0x800'1cde: 0x4770          BX       LR
                `.text_17`:
                HAL_NVIC_SetPriorityGrouping:
  // void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
  // {
  0x800'1ce0: 0xb510          PUSH     {R4, LR}
  0x800'1ce2: 0x0004          MOVS     R4, R0
  //   assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  0x800'1ce4: 0x2c07          CMP      R4, #7
  0x800'1ce6: 0xd00c          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1ce8: 0x2c06          CMP      R4, #6
  0x800'1cea: 0xd00a          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cec: 0x2c05          CMP      R4, #5
  0x800'1cee: 0xd008          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cf0: 0x2c04          CMP      R4, #4
  0x800'1cf2: 0xd006          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cf4: 0x2c03          CMP      R4, #3
  0x800'1cf6: 0xd004          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cf8: 0x2190          MOVS     R1, #144               ; 0x90
  0x800'1cfa: 0xf8df 0x0088   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1cfe: 0xf7ff 0xf822   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_SetPriorityGrouping_0:
  //   NVIC_SetPriorityGrouping(PriorityGroup);
  0x800'1d02: 0x0020          MOVS     R0, R4
  0x800'1d04: 0xf7ff 0xff8c   BL       __NVIC_SetPriorityGrouping
                                                              ; 0x800'1c20
  // }
  0x800'1d08: 0xbd10          POP      {R4, PC}
                `.text_18`:
                HAL_NVIC_SetPriority:
  // void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
  // {
  0x800'1d0a: 0xe92d 0x41f0   PUSH.W   {R4-R8, LR}
  0x800'1d0e: 0x4680          MOV      R8, R0
  0x800'1d10: 0x000c          MOVS     R4, R1
  0x800'1d12: 0x0015          MOVS     R5, R2
  //   uint32_t prioritygroup = 0x00U;
  0x800'1d14: 0x2600          MOVS     R6, #0
  //   assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  0x800'1d16: 0x2d10          CMP      R5, #16                ; 0x10
  0x800'1d18: 0xd304          BCC.N    ??HAL_NVIC_SetPriority_0
                                                              ; 0x800'1d24
  0x800'1d1a: 0x21a8          MOVS     R1, #168               ; 0xa8
  0x800'1d1c: 0xf8df 0x0064   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1d20: 0xf7ff 0xf811   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_SetPriority_0:
  //   assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  0x800'1d24: 0x2c10          CMP      R4, #16                ; 0x10
  0x800'1d26: 0xd304          BCC.N    ??HAL_NVIC_SetPriority_1
                                                              ; 0x800'1d32
  0x800'1d28: 0x21a9          MOVS     R1, #169               ; 0xa9
  0x800'1d2a: 0xf8df 0x0058   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1d2e: 0xf7ff 0xf80a   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_SetPriority_1:
  //   prioritygroup = NVIC_GetPriorityGrouping();
  0x800'1d32: 0xf7ff 0xff86   BL       __NVIC_GetPriorityGrouping
                                                              ; 0x800'1c42
  0x800'1d36: 0x0007          MOVS     R7, R0
  //   NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
  0x800'1d38: 0x002a          MOVS     R2, R5
  0x800'1d3a: 0x0021          MOVS     R1, R4
  0x800'1d3c: 0x0038          MOVS     R0, R7
  0x800'1d3e: 0xf7ff 0xffaf   BL       NVIC_EncodePriority    ; 0x800'1ca0
  0x800'1d42: 0x0001          MOVS     R1, R0
  0x800'1d44: 0x4640          MOV      R0, R8
  0x800'1d46: 0xb240          SXTB     R0, R0
  0x800'1d48: 0xf7ff 0xff92   BL       __NVIC_SetPriority     ; 0x800'1c70
  // }
  0x800'1d4c: 0xe8bd 0x81f0   POP.W    {R4-R8, PC}
                `.text_19`:
                HAL_NVIC_EnableIRQ:
  // void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
  // {
  0x800'1d50: 0xb510          PUSH     {R4, LR}
  0x800'1d52: 0x0004          MOVS     R4, R0
  //   assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  0x800'1d54: 0x0020          MOVS     R0, R4
  0x800'1d56: 0xb240          SXTB     R0, R0
  0x800'1d58: 0x2800          CMP      R0, #0
  0x800'1d5a: 0xd504          BPL.N    ??HAL_NVIC_EnableIRQ_0 ; 0x800'1d66
  0x800'1d5c: 0x21bc          MOVS     R1, #188               ; 0xbc
  0x800'1d5e: 0xf8df 0x0024   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1d62: 0xf7fe 0xfff0   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_EnableIRQ_0:
  //   NVIC_EnableIRQ(IRQn);
  0x800'1d66: 0x0020          MOVS     R0, R4
  0x800'1d68: 0xb240          SXTB     R0, R0
  0x800'1d6a: 0xf7ff 0xff71   BL       __NVIC_EnableIRQ       ; 0x800'1c50
  // }
  0x800'1d6e: 0xbd10          POP      {R4, PC}
                `$d.32`:
                ??DataTable24:
  0x800'1d70: 0xe000'ed0c     DC32     0xe000'ed0c            ; '....'
                ??DataTable24_1:
  0x800'1d74: 0x05fa'0000     DC32     0x5fa'0000             ; '....'
                ??DataTable24_2:
  0x800'1d78: 0xe000'e100     DC32     0xe000'e100            ; '....'
                ??DataTable24_7:
  0x800'1d7c: 0xe000'e400     DC32     0xe000'e400            ; '....'
                ??DataTable24_8:
  0x800'1d80: 0xe000'ed18     DC32     0xe000'ed18            ; '....'
                ??DataTable24_13:
  0x800'1d84: 0x0800'3e0c     DC32     ?_0
                $t:
                `.text6`:
                __aeabi_ldiv0:
  0x800'1d88: 0x4770          BX       LR
                `.text6`:
                out:
  0x800'1d8a: 0xb570          PUSH     {R4-R6, LR}
  0x800'1d8c: 0x4606          MOV      R6, R0
  0x800'1d8e: 0x001c          MOVS     R4, R3
  0x800'1d90: 0x4608          MOV      R0, R1
  0x800'1d92: 0x4615          MOV      R5, R2
  0x800'1d94: 0xd004          BEQ.N    ??out_0                ; 0x800'1da0
                ??out_1:
  0x800'1d96: 0xf815 0x1b01   LDRB.W   R1, [R5], #0x1
  0x800'1d9a: 0x47b0          BLX      R6
  0x800'1d9c: 0x1e64          SUBS     R4, R4, #1
  0x800'1d9e: 0xd1fa          BNE.N    ??out_1                ; 0x800'1d96
                ??out_0:
  0x800'1da0: 0xbd70          POP      {R4-R6, PC}
                `.text_3`:
                _PrintfTiny:
  0x800'1da2: 0xe92d 0x46fc   PUSH.W   {R2-R7, R9, R10, LR}
  0x800'1da6: 0xb083          SUB      SP, SP, #0xc
  0x800'1da8: 0x4681          MOV      R9, R0
  0x800'1daa: 0x468a          MOV      R10, R1
  0x800'1dac: 0x4616          MOV      R6, R2
  0x800'1dae: 0x461f          MOV      R7, R3
  0x800'1db0: 0xe007          B.N      ??_PrintfTiny_4        ; 0x800'1dc2
                ??_PrintfTiny_6:
  0x800'1db2: 0x2301          MOVS     R3, #1
  0x800'1db4: 0x4632          MOV      R2, R6
  0x800'1db6: 0x4651          MOV      R1, R10
  0x800'1db8: 0x4648          MOV      R0, R9
  0x800'1dba: 0xf7ff 0xffe6   BL       out                    ; 0x800'1d8a
  0x800'1dbe: 0x4682          MOV      R10, R0
  0x800'1dc0: 0x1c76          ADDS     R6, R6, #1
                ??_PrintfTiny_4:
  0x800'1dc2: 0x7830          LDRB     R0, [R6]
  0x800'1dc4: 0xb1e0          CBZ      R0, ??_PrintfTiny_5    ; 0x800'1e00
  0x800'1dc6: 0x2825          CMP      R0, #37                ; 0x25
  0x800'1dc8: 0xd1f3          BNE.N    ??_PrintfTiny_6        ; 0x800'1db2
  0x800'1dca: 0x7871          LDRB     R1, [R6, #0x1]
  0x800'1dcc: 0x1cb6          ADDS     R6, R6, #2
  0x800'1dce: 0x2925          CMP      R1, #37                ; 0x25
  0x800'1dd0: 0xd012          BEQ.N    ??_PrintfTiny_7        ; 0x800'1df8
  0x800'1dd2: 0x2958          CMP      R1, #88                ; 0x58
  0x800'1dd4: 0xd05a          BEQ.N    ??_PrintfTiny_8        ; 0x800'1e8c
  0x800'1dd6: 0x2963          CMP      R1, #99                ; 0x63
  0x800'1dd8: 0xd015          BEQ.N    ??_PrintfTiny_9        ; 0x800'1e06
  0x800'1dda: 0x2964          CMP      R1, #100               ; 0x64
  0x800'1ddc: 0xbf18          IT       NE
  0x800'1dde: 0x2969          CMPNE    R1, #105               ; 0x69
  0x800'1de0: 0xd017          BEQ.N    ??_PrintfTiny_10       ; 0x800'1e12
  0x800'1de2: 0x296f          CMP      R1, #111               ; 0x6f
  0x800'1de4: 0xd052          BEQ.N    ??_PrintfTiny_8        ; 0x800'1e8c
  0x800'1de6: 0x2970          CMP      R1, #112               ; 0x70
  0x800'1de8: 0xd055          BEQ.N    ??_PrintfTiny_11       ; 0x800'1e96
  0x800'1dea: 0x2973          CMP      R1, #115               ; 0x73
  0x800'1dec: 0xd059          BEQ.N    ??_PrintfTiny_12       ; 0x800'1ea2
  0x800'1dee: 0x2975          CMP      R1, #117               ; 0x75
  0x800'1df0: 0xbf18          IT       NE
  0x800'1df2: 0x2978          CMPNE    R1, #120               ; 0x78
  0x800'1df4: 0xd04a          BEQ.N    ??_PrintfTiny_8        ; 0x800'1e8c
  0x800'1df6: 0xe7e4          B.N      ??_PrintfTiny_4        ; 0x800'1dc2
                ??_PrintfTiny_7:
  0x800'1df8: 0x4650          MOV      R0, R10
  0x800'1dfa: 0x47c8          BLX      R9
                ??_PrintfTiny_20:
  0x800'1dfc: 0x4682          MOV      R10, R0
  0x800'1dfe: 0xe7e0          B.N      ??_PrintfTiny_4        ; 0x800'1dc2
                ??_PrintfTiny_5:
  0x800'1e00: 0xb005          ADD      SP, SP, #0x14
  0x800'1e02: 0xe8bd 0x86f0   POP.W    {R4-R7, R9, R10, PC}
                ??_PrintfTiny_9:
  0x800'1e06: 0x6839          LDR      R1, [R7]
  0x800'1e08: 0xf851 0x0b04   LDR.W    R0, [R1], #0x4
  0x800'1e0c: 0x6039          STR      R1, [R7]
  0x800'1e0e: 0xb2c1          UXTB     R1, R0
  0x800'1e10: 0xe7f2          B.N      ??_PrintfTiny_7        ; 0x800'1df8
                ??_PrintfTiny_10:
  0x800'1e12: 0x6838          LDR      R0, [R7]
  0x800'1e14: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1e18: 0x6038          STR      R0, [R7]
  0x800'1e1a: 0x2d00          CMP      R5, #0
  0x800'1e1c: 0xd503          BPL.N    ??_PrintfTiny_13       ; 0x800'1e26
  0x800'1e1e: 0x212d          MOVS     R1, #45                ; 0x2d
  0x800'1e20: 0x4650          MOV      R0, R10
  0x800'1e22: 0x47c8          BLX      R9
  0x800'1e24: 0x4682          MOV      R10, R0
                ??_PrintfTiny_13:
  0x800'1e26: 0x2164          MOVS     R1, #100               ; 0x64
                ??_PrintfTiny_22:
  0x800'1e28: 0x296f          CMP      R1, #111               ; 0x6f
  0x800'1e2a: 0xbf08          IT       EQ
  0x800'1e2c: 0x2208          MOVEQ    R2, #8
  0x800'1e2e: 0xd005          BEQ.N    ??_PrintfTiny_14       ; 0x800'1e3c
  0x800'1e30: 0xf041 0x0020   ORR.W    R0, R1, #32            ; 0x20
  0x800'1e34: 0x2878          CMP      R0, #120               ; 0x78
  0x800'1e36: 0xbf14          ITE      NE
  0x800'1e38: 0x220a          MOVNE    R2, #10                ; 0xa
  0x800'1e3a: 0x2210          MOVEQ    R2, #16                ; 0x10
                ??_PrintfTiny_14:
  0x800'1e3c: 0x240b          MOVS     R4, #11                ; 0xb
  0x800'1e3e: 0x2964          CMP      R1, #100               ; 0x64
  0x800'1e40: 0x4628          MOV      R0, R5
  0x800'1e42: 0xd102          BNE.N    ??_PrintfTiny_15       ; 0x800'1e4a
  0x800'1e44: 0x2d00          CMP      R5, #0
  0x800'1e46: 0xbf48          IT       MI
  0x800'1e48: 0x4240          RSBMI    R0, R0, #0
                ??_PrintfTiny_15:
  0x800'1e4a: 0xfbb0 0xf3f2   UDIV     R3, R0, R2
  0x800'1e4e: 0xfb02 0x0013   MLS      R0, R2, R3, R0
  0x800'1e52: 0x1e64          SUBS     R4, R4, #1
  0x800'1e54: 0x3030          ADDS     R0, R0, #48            ; 0x30
  0x800'1e56: 0x283a          CMP      R0, #58                ; 0x3a
  0x800'1e58: 0xda04          BGE.N    ??_PrintfTiny_16       ; 0x800'1e64
                ??_PrintfTiny_19:
  0x800'1e5a: 0xf80d 0x0004   STRB.W   R0, [SP, R4]
  0x800'1e5e: 0x0018          MOVS     R0, R3
  0x800'1e60: 0xd103          BNE.N    ??_PrintfTiny_17       ; 0x800'1e6a
  0x800'1e62: 0xe004          B.N      ??_PrintfTiny_18       ; 0x800'1e6e
                ??_PrintfTiny_16:
  0x800'1e64: 0x1840          ADDS     R0, R0, R1
  0x800'1e66: 0x3851          SUBS     R0, R0, #81            ; 0x51
  0x800'1e68: 0xe7f7          B.N      ??_PrintfTiny_19       ; 0x800'1e5a
                ??_PrintfTiny_17:
  0x800'1e6a: 0x2c00          CMP      R4, #0
  0x800'1e6c: 0xdced          BGT.N    ??_PrintfTiny_15       ; 0x800'1e4a
                ??_PrintfTiny_18:
  0x800'1e6e: 0x4261          RSBS     R1, R4, #0
  0x800'1e70: 0xf111 0x0f0b   CMN.W    R1, #11                ; 0xb
  0x800'1e74: 0xeb0d 0x0504   ADD.W    R5, SP, R4
  0x800'1e78: 0x4650          MOV      R0, R10
  0x800'1e7a: 0xd0bf          BEQ.N    ??_PrintfTiny_20       ; 0x800'1dfc
  0x800'1e7c: 0xf1c4 0x040b   RSB.W    R4, R4, #11            ; 0xb
                ??_PrintfTiny_21:
  0x800'1e80: 0xf815 0x1b01   LDRB.W   R1, [R5], #0x1
  0x800'1e84: 0x47c8          BLX      R9
  0x800'1e86: 0x1e64          SUBS     R4, R4, #1
  0x800'1e88: 0xd1fa          BNE.N    ??_PrintfTiny_21       ; 0x800'1e80
  0x800'1e8a: 0xe7b7          B.N      ??_PrintfTiny_20       ; 0x800'1dfc
                ??_PrintfTiny_8:
  0x800'1e8c: 0x6838          LDR      R0, [R7]
  0x800'1e8e: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1e92: 0x6038          STR      R0, [R7]
  0x800'1e94: 0xe7c8          B.N      ??_PrintfTiny_22       ; 0x800'1e28
                ??_PrintfTiny_11:
  0x800'1e96: 0x6838          LDR      R0, [R7]
  0x800'1e98: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1e9c: 0x6038          STR      R0, [R7]
  0x800'1e9e: 0x2178          MOVS     R1, #120               ; 0x78
  0x800'1ea0: 0xe7c2          B.N      ??_PrintfTiny_22       ; 0x800'1e28
                ??_PrintfTiny_12:
  0x800'1ea2: 0x6838          LDR      R0, [R7]
  0x800'1ea4: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1ea8: 0x6038          STR      R0, [R7]
  0x800'1eaa: 0x4628          MOV      R0, R5
  0x800'1eac: 0xf000 0xf812   BL       strlen                 ; 0x800'1ed4
  0x800'1eb0: 0x0004          MOVS     R4, R0
  0x800'1eb2: 0x4650          MOV      R0, R10
  0x800'1eb4: 0xd0a2          BEQ.N    ??_PrintfTiny_20       ; 0x800'1dfc
                ??_PrintfTiny_23:
  0x800'1eb6: 0xf815 0x1b01   LDRB.W   R1, [R5], #0x1
  0x800'1eba: 0x47c8          BLX      R9
  0x800'1ebc: 0x1e64          SUBS     R4, R4, #1
  0x800'1ebe: 0xd1fa          BNE.N    ??_PrintfTiny_23       ; 0x800'1eb6
  0x800'1ec0: 0xe79c          B.N      ??_PrintfTiny_20       ; 0x800'1dfc
                `.text10`:
                HAL_TIM_Base_MspInit:
  // }
  0x800'1ec2: 0x4770          BX       LR
                `.text40`:
                HAL_TIM_IC_CaptureCallback:
  // }
  0x800'1ec4: 0x4770          BX       LR
                `.text38`:
                HAL_TIM_OC_DelayElapsedCallback:
  // }
  0x800'1ec6: 0x4770          BX       LR
                `.text44`:
                HAL_TIM_PWM_PulseFinishedCallback:
  // }
  0x800'1ec8: 0x4770          BX       LR
                `.text34`:
                HAL_TIM_PeriodElapsedCallback:
  // }
  0x800'1eca: 0x4770          BX       LR
                `.text18`:
                HAL_TIMEx_BreakCallback:
  // }
  0x800'1ecc: 0x4770          BX       LR
                `.text48`:
                HAL_TIM_TriggerCallback:
  // }
  0x800'1ece: 0x4770          BX       LR
                `.text14`:
                HAL_TIMEx_CommutCallback:
  // }
  0x800'1ed0: 0x4770          BX       LR
  0x800'1ed2: 0x0000          MOVS     R0, R0
                `.text6`:
                strlen:
  0x800'1ed4: 0xf100 0x0301   ADD.W    R3, R0, #1
  0x800'1ed8: 0x0781          LSLS     R1, R0, #30
  0x800'1eda: 0xd004          BEQ.N    @8001ee6
                @8001edc:
  0x800'1edc: 0xf810 0x1b01   LDRB.W   R1, [R0], #0x1
  0x800'1ee0: 0x0782          LSLS     R2, R0, #30
  0x800'1ee2: 0xb181          CBZ      R1, @8001f06
  0x800'1ee4: 0xd1fa          BNE.N    @8001edc
                @8001ee6:
  0x800'1ee6: 0x6802          LDR      R2, [R0]
                @8001ee8:
  0x800'1ee8: 0xf1a2 0x3101   SUB.W    R1, R2, #16843009      ; 0x101'0101
  0x800'1eec: 0x4391          BICS     R1, R1, R2
  0x800'1eee: 0xf011 0x3180   ANDS.W   R1, R1, #-2139062144   ; 0x8080'8080
  0x800'1ef2: 0xbf04          ITT      EQ
  0x800'1ef4: 0xf850 0x2f04   LDREQ.W  R2, [R0, #0x4]!
  0x800'1ef8: 0xe7f6          BEQ.N    @8001ee8
  0x800'1efa: 0xba09          REV      R1, R1
  0x800'1efc: 0xfab1 0xf181   CLZ      R1, R1
  0x800'1f00: 0xeb00 0x00d1   ADD.W    R0, R0, R1, LSR #3
  0x800'1f04: 0x1c40          ADDS     R0, R0, #1
                @8001f06:
  0x800'1f06: 0x1ac0          SUBS     R0, R0, R3
  0x800'1f08: 0x4770          BX       LR
  0x800'1f0a: 0x0000          MOVS     R0, R0
                `.text_3`:
                _tx_thread_system_ni_resume:
  // VOID  _tx_thread_system_ni_resume(TX_THREAD *thread_ptr)
  // {
  0x800'1f0c: 0xe92d 0x4ffe   PUSH.W   {R1-R11, LR}
  0x800'1f10: 0x0004          MOVS     R4, R0
  //     if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
  0x800'1f12: 0x6e60          LDR      R0, [R4, #0x64]
  0x800'1f14: 0x2800          CMP      R0, #0
  0x800'1f16: 0xd003          BEQ.N    ??_tx_thread_system_ni_resume_0
                                                              ; 0x800'1f20
  //         _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
  0x800'1f18: 0xf114 0x004c   ADDS.W   R0, R4, #76            ; 0x4c
  0x800'1f1c: 0xf000 0xf9b4   BL       _tx_timer_system_deactivate
                                                              ; 0x800'2288
                ??_tx_thread_system_ni_resume_0:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'1f20: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'1f24: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'1f26: 0x2c00          CMP      R4, #0
  0x800'1f28: 0xd039          BEQ.N    ??_tx_thread_system_ni_resume_1
                                                              ; 0x800'1f9e
  0x800'1f2a: 0x6821          LDR      R1, [R4]
  0x800'1f2c: 0x48c9          LDR.N    R0, ??DataTable1_2     ; 0x5448'5244
  0x800'1f2e: 0x4281          CMP      R1, R0
  0x800'1f30: 0xd135          BNE.N    ??_tx_thread_system_ni_resume_1
                                                              ; 0x800'1f9e
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f32: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'1f34: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'1f38: 0x4281          CMP      R1, R0
  0x800'1f3a: 0xd202          BCS.N    ??_tx_thread_system_ni_resume_2
                                                              ; 0x800'1f42
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f3c: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'1f3e: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_ni_resume_2:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f42: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1f44: 0x6801          LDR      R1, [R0]
  0x800'1f46: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'1f4a: 0x4281          CMP      R1, R0
  0x800'1f4c: 0xd10b          BNE.N    ??_tx_thread_system_ni_resume_3
                                                              ; 0x800'1f66
  0x800'1f4e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1f50: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'1f54: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'1f58: 0x4281          CMP      R1, R0
  0x800'1f5a: 0xd104          BNE.N    ??_tx_thread_system_ni_resume_3
                                                              ; 0x800'1f66
  0x800'1f5c: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'1f60: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1f62: 0x4281          CMP      R1, R0
  0x800'1f64: 0xd209          BCS.N    ??_tx_thread_system_ni_resume_4
                                                              ; 0x800'1f7a
                ??_tx_thread_system_ni_resume_3:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f66: 0x46ba          MOV      R10, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'1f68: 0xf38a 0x8810   MSR      PRIMASK, R10
  // }
  0x800'1f6c: 0x0020          MOVS     R0, R4
  0x800'1f6e: 0xf000 0xf9a7   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'1f72: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'1f76: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'1f78: 0x0007          MOVS     R7, R0
                ??_tx_thread_system_ni_resume_4:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f7a: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'1f7e: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'1f82: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'1f86: 0x4281          CMP      R1, R0
  0x800'1f88: 0xd009          BEQ.N    ??_tx_thread_system_ni_resume_1
                                                              ; 0x800'1f9e
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f8a: 0x46ba          MOV      R10, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'1f8c: 0xf38a 0x8810   MSR      PRIMASK, R10
  // }
  0x800'1f90: 0x0020          MOVS     R0, R4
  0x800'1f92: 0xf000 0xf9a7   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'1f96: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'1f9a: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'1f9c: 0x0007          MOVS     R7, R0
                ??_tx_thread_system_ni_resume_1:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f9e: 0x0039          MOVS     R1, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'1fa0: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'1fa4: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'1fa6: 0x2800          CMP      R0, #0
  0x800'1fa8: 0xf000 0x80d7   BEQ.W    ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
  //         if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
  0x800'1fac: 0x6b60          LDR      R0, [R4, #0x34]
  0x800'1fae: 0x2800          CMP      R0, #0
  0x800'1fb0: 0xf040 0x80cf   BNE.W    ??_tx_thread_system_ni_resume_6
                                                              ; 0x800'2152
  //             thread_ptr -> tx_thread_state =  TX_READY;
  0x800'1fb4: 0x2000          MOVS     R0, #0
  0x800'1fb6: 0x6320          STR      R0, [R4, #0x30]
  //             priority =  thread_ptr -> tx_thread_priority;
  0x800'1fb8: 0x6ae0          LDR      R0, [R4, #0x2c]
  0x800'1fba: 0x4681          MOV      R9, R0
  //             _tx_thread_performance_resume_count++;
  0x800'1fbc: 0x49a4          LDR.N    R1, ??DataTable1_1     ; _tx_thread_performance_resume_count
  0x800'1fbe: 0x6808          LDR      R0, [R1]
  0x800'1fc0: 0x1c40          ADDS     R0, R0, #1
  0x800'1fc2: 0x6008          STR      R0, [R1]
  //             thread_ptr -> tx_thread_performance_resume_count++;
  0x800'1fc4: 0xf8d4 0x00a4   LDR.W    R0, [R4, #0xa4]
  0x800'1fc8: 0x1c40          ADDS     R0, R0, #1
  0x800'1fca: 0xf8c4 0x00a4   STR.W    R0, [R4, #0xa4]
  //             head_ptr =  _tx_thread_priority_list[priority];
  0x800'1fce: 0x49a2          LDR.N    R1, ??DataTable1_3     ; _tx_thread_priority_list
  0x800'1fd0: 0xf851 0x0029   LDR.W    R0, [R1, R9, LSL #2]
  0x800'1fd4: 0x0005          MOVS     R5, R0
  //             if (head_ptr == TX_NULL)
  0x800'1fd6: 0x2d00          CMP      R5, #0
  0x800'1fd8: 0xf040 0x80b2   BNE.W    ??_tx_thread_system_ni_resume_7
                                                              ; 0x800'2140
  //                 _tx_thread_priority_list[priority] =       thread_ptr;
  0x800'1fdc: 0xf841 0x4029   STR.W    R4, [R1, R9, LSL #2]
  //                 thread_ptr -> tx_thread_ready_next =       thread_ptr;
  0x800'1fe0: 0x6224          STR      R4, [R4, #0x20]
  //                 thread_ptr -> tx_thread_ready_previous =   thread_ptr;
  0x800'1fe2: 0x6264          STR      R4, [R4, #0x24]
  //                 TX_MOD32_BIT_SET(priority, priority_bit)
  0x800'1fe4: 0x2001          MOVS     R0, #1
  0x800'1fe6: 0xfa10 0xf009   LSLS.W   R0, R0, R9
  0x800'1fea: 0x9001          STR      R0, [SP, #0x4]
  //                 _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
  0x800'1fec: 0x4a9b          LDR.N    R2, ??DataTable1_4     ; _tx_thread_priority_maps
  0x800'1fee: 0x6811          LDR      R1, [R2]
  0x800'1ff0: 0x9801          LDR      R0, [SP, #0x4]
  0x800'1ff2: 0x4301          ORRS     R1, R1, R0
  0x800'1ff4: 0x6011          STR      R1, [R2]
  //                 if (priority < _tx_thread_highest_priority)
  0x800'1ff6: 0x499a          LDR.N    R1, ??DataTable1_5     ; _tx_thread_highest_priority
  0x800'1ff8: 0x6808          LDR      R0, [R1]
  0x800'1ffa: 0x4581          CMP      R9, R0
  0x800'1ffc: 0xf080 0x80ad   BCS.W    ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
  //                     _tx_thread_highest_priority =  priority;
  0x800'2000: 0xf8c1 0x9000   STR.W    R9, [R1]
  //                     execute_ptr =  _tx_thread_execute_ptr;
  0x800'2004: 0x4a97          LDR.N    R2, ??DataTable1_6     ; _tx_thread_execute_ptr
  0x800'2006: 0x6810          LDR      R0, [R2]
  0x800'2008: 0x0006          MOVS     R6, R0
  //                     if (execute_ptr == TX_NULL)
  0x800'200a: 0x2e00          CMP      R6, #0
  0x800'200c: 0xd101          BNE.N    ??_tx_thread_system_ni_resume_8
                                                              ; 0x800'2012
  //                         _tx_thread_execute_ptr =  thread_ptr;
  0x800'200e: 0x6014          STR      R4, [R2]
  0x800'2010: 0xe0a3          B.N      ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
                ??_tx_thread_system_ni_resume_8:
  //                         if (priority < execute_ptr -> tx_thread_preempt_threshold)
  0x800'2012: 0x6bf0          LDR      R0, [R6, #0x3c]
  0x800'2014: 0x4581          CMP      R9, R0
  0x800'2016: 0xf080 0x80a0   BCS.W    ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
  //                             if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
  0x800'201a: 0x4b93          LDR.N    R3, ??DataTable1_7     ; _tx_thread_system_state
  0x800'201c: 0x6818          LDR      R0, [R3]
  0x800'201e: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'2022: 0x4308          ORRS     R0, R0, R1
  0x800'2024: 0x2800          CMP      R0, #0
  0x800'2026: 0xd109          BNE.N    ??_tx_thread_system_ni_resume_9
                                                              ; 0x800'203c
  //                                 _tx_thread_performance_solicited_preemption_count++;
  0x800'2028: 0x4990          LDR.N    R1, ??DataTable1_8     ; _tx_thread_performance_solicited_preemption_count
  0x800'202a: 0x6808          LDR      R0, [R1]
  0x800'202c: 0x1c40          ADDS     R0, R0, #1
  0x800'202e: 0x6008          STR      R0, [R1]
  //                                 execute_ptr -> tx_thread_performance_solicited_preemption_count++;
  0x800'2030: 0xf8d6 0x00ac   LDR.W    R0, [R6, #0xac]
  0x800'2034: 0x1c40          ADDS     R0, R0, #1
  0x800'2036: 0xf8c6 0x00ac   STR.W    R0, [R6, #0xac]
  0x800'203a: 0xe00f          B.N      ??_tx_thread_system_ni_resume_10
                                                              ; 0x800'205c
                ??_tx_thread_system_ni_resume_9:
  //                                 if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  0x800'203c: 0x6819          LDR      R1, [R3]
  0x800'203e: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'2042: 0x4301          ORRS     R1, R1, R0
  0x800'2044: 0xf1b1 0x3ff0   CMP.W    R1, #-252645136        ; 0xf0f0'f0f0
  0x800'2048: 0xd208          BCS.N    ??_tx_thread_system_ni_resume_10
                                                              ; 0x800'205c
  //                                     _tx_thread_performance_interrupt_preemption_count++;
  0x800'204a: 0x4989          LDR.N    R1, ??DataTable1_9     ; _tx_thread_performance_interrupt_preemption_count
  0x800'204c: 0x6808          LDR      R0, [R1]
  0x800'204e: 0x1c40          ADDS     R0, R0, #1
  0x800'2050: 0x6008          STR      R0, [R1]
  //                                     execute_ptr -> tx_thread_performance_interrupt_preemption_count++;
  0x800'2052: 0xf8d6 0x00b0   LDR.W    R0, [R6, #0xb0]
  0x800'2056: 0x1c40          ADDS     R0, R0, #1
  0x800'2058: 0xf8c6 0x00b0   STR.W    R0, [R6, #0xb0]
                ??_tx_thread_system_ni_resume_10:
  //                             execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;
  0x800'205c: 0xf8c6 0x40b8   STR.W    R4, [R6, #0xb8]
  //                             _tx_thread_execute_ptr =  thread_ptr;
  0x800'2060: 0x6014          STR      R4, [R2]
  //                             if (_tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] != _tx_thread_execute_ptr)
  0x800'2062: 0x4884          LDR.N    R0, ??DataTable1_10    ; _tx_thread_performance__execute_log_index
  0x800'2064: 0x4984          LDR.N    R1, ??DataTable1_11    ; _tx_thread_performance_execute_log
  0x800'2066: 0x6803          LDR      R3, [R0]
  0x800'2068: 0xf851 0x7023   LDR.W    R7, [R1, R3, LSL #2]
  0x800'206c: 0x6813          LDR      R3, [R2]
  0x800'206e: 0x429f          CMP      R7, R3
  0x800'2070: 0xd00b          BEQ.N    ??_tx_thread_system_ni_resume_11
                                                              ; 0x800'208a
  //                                 _tx_thread_performance__execute_log_index++;
  0x800'2072: 0x6803          LDR      R3, [R0]
  0x800'2074: 0x1c5b          ADDS     R3, R3, #1
  0x800'2076: 0x6003          STR      R3, [R0]
  //                                 if (_tx_thread_performance__execute_log_index >= TX_THREAD_EXECUTE_LOG_SIZE)
  0x800'2078: 0x6803          LDR      R3, [R0]
  0x800'207a: 0x2b08          CMP      R3, #8
  0x800'207c: 0xd301          BCC.N    ??_tx_thread_system_ni_resume_12
                                                              ; 0x800'2082
  //                                     _tx_thread_performance__execute_log_index =  ((UINT) 0);
  0x800'207e: 0x2300          MOVS     R3, #0
  0x800'2080: 0x6003          STR      R3, [R0]
                ??_tx_thread_system_ni_resume_12:
  //                                 _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
  0x800'2082: 0x6813          LDR      R3, [R2]
  0x800'2084: 0x6800          LDR      R0, [R0]
  0x800'2086: 0xf841 0x3020   STR.W    R3, [R1, R0, LSL #2]
                ??_tx_thread_system_ni_resume_11:
  //                             thread_ptr =  _tx_thread_execute_ptr;
  0x800'208a: 0x6817          LDR      R7, [R2]
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'208c: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'2090: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2092: 0x2f00          CMP      R7, #0
  0x800'2094: 0xd039          BEQ.N    ??_tx_thread_system_ni_resume_13
                                                              ; 0x800'210a
  0x800'2096: 0x6839          LDR      R1, [R7]
  0x800'2098: 0x486e          LDR.N    R0, ??DataTable1_2     ; 0x5448'5244
  0x800'209a: 0x4281          CMP      R1, R0
  0x800'209c: 0xd135          BNE.N    ??_tx_thread_system_ni_resume_13
                                                              ; 0x800'210a
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'209e: 0x68b9          LDR      R1, [R7, #0x8]
  0x800'20a0: 0xf8d7 0x00cc   LDR.W    R0, [R7, #0xcc]
  0x800'20a4: 0x4281          CMP      R1, R0
  0x800'20a6: 0xd202          BCS.N    ??_tx_thread_system_ni_resume_14
                                                              ; 0x800'20ae
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20a8: 0x68b8          LDR      R0, [R7, #0x8]
  0x800'20aa: 0xf8c7 0x00cc   STR.W    R0, [R7, #0xcc]
                ??_tx_thread_system_ni_resume_14:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20ae: 0x68f8          LDR      R0, [R7, #0xc]
  0x800'20b0: 0x6801          LDR      R1, [R0]
  0x800'20b2: 0xf8d7 0x00d4   LDR.W    R0, [R7, #0xd4]
  0x800'20b6: 0x4281          CMP      R1, R0
  0x800'20b8: 0xd10b          BNE.N    ??_tx_thread_system_ni_resume_15
                                                              ; 0x800'20d2
  0x800'20ba: 0x6938          LDR      R0, [R7, #0x10]
  0x800'20bc: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'20c0: 0xf8d7 0x00d4   LDR.W    R0, [R7, #0xd4]
  0x800'20c4: 0x4281          CMP      R1, R0
  0x800'20c6: 0xd104          BNE.N    ??_tx_thread_system_ni_resume_15
                                                              ; 0x800'20d2
  0x800'20c8: 0xf8d7 0x10cc   LDR.W    R1, [R7, #0xcc]
  0x800'20cc: 0x68f8          LDR      R0, [R7, #0xc]
  0x800'20ce: 0x4281          CMP      R1, R0
  0x800'20d0: 0xd209          BCS.N    ??_tx_thread_system_ni_resume_16
                                                              ; 0x800'20e6
                ??_tx_thread_system_ni_resume_15:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20d2: 0x4654          MOV      R4, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'20d4: 0xf384 0x8810   MSR      PRIMASK, R4
  // }
  0x800'20d8: 0x0038          MOVS     R0, R7
  0x800'20da: 0xf000 0xf8f1   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'20de: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'20e2: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'20e4: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_16:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20e6: 0xf8d7 0x00cc   LDR.W    R0, [R7, #0xcc]
  0x800'20ea: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'20ee: 0xf8d7 0x00d4   LDR.W    R0, [R7, #0xd4]
  0x800'20f2: 0x4281          CMP      R1, R0
  0x800'20f4: 0xd009          BEQ.N    ??_tx_thread_system_ni_resume_13
                                                              ; 0x800'210a
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20f6: 0x4654          MOV      R4, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'20f8: 0xf384 0x8810   MSR      PRIMASK, R4
  // }
  0x800'20fc: 0x0038          MOVS     R0, R7
  0x800'20fe: 0xf000 0xf8f1   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2102: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2106: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2108: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_13:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'210a: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'210c: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2110: 0x484e          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'2112: 0x6800          LDR      R0, [R0]
  //                             if (combined_flags == ((ULONG) 0))
  0x800'2114: 0x2800          CMP      R0, #0
  0x800'2116: 0xd112          BNE.N    ??_tx_thread_system_ni_resume_18
                                                              ; 0x800'213e
  //                                 _tx_thread_performance_non_idle_return_count++;
  0x800'2118: 0x4a58          LDR.N    R2, ??DataTable1_12    ; _tx_thread_performance_non_idle_return_count
  0x800'211a: 0x6811          LDR      R1, [R2]
  0x800'211c: 0x1c49          ADDS     R1, R1, #1
  0x800'211e: 0x6011          STR      R1, [R2]
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'2120: 0xf05f 0x5380   MOVS.W   R3, #268435456         ; 0x1000'0000
  0x800'2124: 0x4956          LDR.N    R1, ??DataTable1_13    ; 0xe000'ed04
  0x800'2126: 0x600b          STR      R3, [R1]
  //     if (__get_ipsr_value() == 0)
  0x800'2128: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'212c: 0x2900          CMP      R1, #0
  0x800'212e: 0xd106          BNE.N    ??_tx_thread_system_ni_resume_18
                                                              ; 0x800'213e
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2130: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'2134: 0x000a          MOVS     R2, R1
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'2136: 0xb662          CPSIE    i
  // }
  0x800'2138: 0x0011          MOVS     R1, R2
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'213a: 0xf381 0x8810   MSR      PRIMASK, R1
                ??_tx_thread_system_ni_resume_17:
                ??_tx_thread_system_ni_resume_18:
  // }
  0x800'213e: 0xe083          B.N      ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
                ??_tx_thread_system_ni_resume_7:
  //                 tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
  0x800'2140: 0x6a68          LDR      R0, [R5, #0x24]
  0x800'2142: 0x4680          MOV      R8, R0
  //                 tail_ptr -> tx_thread_ready_next =         thread_ptr;
  0x800'2144: 0xf8c8 0x4020   STR.W    R4, [R8, #0x20]
  //                 head_ptr -> tx_thread_ready_previous =     thread_ptr;
  0x800'2148: 0x626c          STR      R4, [R5, #0x24]
  //                 thread_ptr -> tx_thread_ready_previous =   tail_ptr;
  0x800'214a: 0xf8c4 0x8024   STR.W    R8, [R4, #0x24]
  //                 thread_ptr -> tx_thread_ready_next =       head_ptr;
  0x800'214e: 0x6225          STR      R5, [R4, #0x20]
  0x800'2150: 0xe003          B.N      ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
                ??_tx_thread_system_ni_resume_6:
  //             thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
  0x800'2152: 0x2000          MOVS     R0, #0
  0x800'2154: 0x6360          STR      R0, [R4, #0x34]
  //             thread_ptr -> tx_thread_state =            TX_SUSPENDED;
  0x800'2156: 0x2003          MOVS     R0, #3
  0x800'2158: 0x6320          STR      R0, [R4, #0x30]
                ??_tx_thread_system_ni_resume_5:
  //     if (_tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] != _tx_thread_execute_ptr)
  0x800'215a: 0x4946          LDR.N    R1, ??DataTable1_10    ; _tx_thread_performance__execute_log_index
  0x800'215c: 0x4a46          LDR.N    R2, ??DataTable1_11    ; _tx_thread_performance_execute_log
  0x800'215e: 0x4841          LDR.N    R0, ??DataTable1_6     ; _tx_thread_execute_ptr
  0x800'2160: 0x680b          LDR      R3, [R1]
  0x800'2162: 0xf852 0x3023   LDR.W    R3, [R2, R3, LSL #2]
  0x800'2166: 0x6807          LDR      R7, [R0]
  0x800'2168: 0x42bb          CMP      R3, R7
  0x800'216a: 0xd00b          BEQ.N    ??_tx_thread_system_ni_resume_20
                                                              ; 0x800'2184
  //         _tx_thread_performance__execute_log_index++;
  0x800'216c: 0x680b          LDR      R3, [R1]
  0x800'216e: 0x1c5b          ADDS     R3, R3, #1
  0x800'2170: 0x600b          STR      R3, [R1]
  //         if (_tx_thread_performance__execute_log_index >= TX_THREAD_EXECUTE_LOG_SIZE)
  0x800'2172: 0x680b          LDR      R3, [R1]
  0x800'2174: 0x2b08          CMP      R3, #8
  0x800'2176: 0xd301          BCC.N    ??_tx_thread_system_ni_resume_21
                                                              ; 0x800'217c
  //             _tx_thread_performance__execute_log_index =  ((UINT) 0);
  0x800'2178: 0x2300          MOVS     R3, #0
  0x800'217a: 0x600b          STR      R3, [R1]
                ??_tx_thread_system_ni_resume_21:
  //         _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
  0x800'217c: 0x6803          LDR      R3, [R0]
  0x800'217e: 0x6809          LDR      R1, [R1]
  0x800'2180: 0xf842 0x3021   STR.W    R3, [R2, R1, LSL #2]
                ??_tx_thread_system_ni_resume_20:
  //     TX_THREAD_GET_CURRENT(current_thread)
  0x800'2184: 0x493f          LDR.N    R1, ??DataTable1_14    ; _tx_thread_current_ptr
  0x800'2186: 0x680f          LDR      R7, [R1]
  //     if (current_thread != _tx_thread_execute_ptr)
  0x800'2188: 0x6801          LDR      R1, [R0]
  0x800'218a: 0x428f          CMP      R7, R1
  0x800'218c: 0xd05c          BEQ.N    ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
  //         thread_ptr =  _tx_thread_execute_ptr;
  0x800'218e: 0x6800          LDR      R0, [R0]
  0x800'2190: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2192: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'2196: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2198: 0x2c00          CMP      R4, #0
  0x800'219a: 0xd039          BEQ.N    ??_tx_thread_system_ni_resume_23
                                                              ; 0x800'2210
  0x800'219c: 0x6821          LDR      R1, [R4]
  0x800'219e: 0x482d          LDR.N    R0, ??DataTable1_2     ; 0x5448'5244
  0x800'21a0: 0x4281          CMP      R1, R0
  0x800'21a2: 0xd135          BNE.N    ??_tx_thread_system_ni_resume_23
                                                              ; 0x800'2210
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21a4: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'21a6: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'21aa: 0x4281          CMP      R1, R0
  0x800'21ac: 0xd202          BCS.N    ??_tx_thread_system_ni_resume_24
                                                              ; 0x800'21b4
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21ae: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'21b0: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_ni_resume_24:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21b4: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'21b6: 0x6801          LDR      R1, [R0]
  0x800'21b8: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'21bc: 0x4281          CMP      R1, R0
  0x800'21be: 0xd10b          BNE.N    ??_tx_thread_system_ni_resume_25
                                                              ; 0x800'21d8
  0x800'21c0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'21c2: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'21c6: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'21ca: 0x4281          CMP      R1, R0
  0x800'21cc: 0xd104          BNE.N    ??_tx_thread_system_ni_resume_25
                                                              ; 0x800'21d8
  0x800'21ce: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'21d2: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'21d4: 0x4281          CMP      R1, R0
  0x800'21d6: 0xd209          BCS.N    ??_tx_thread_system_ni_resume_26
                                                              ; 0x800'21ec
                ??_tx_thread_system_ni_resume_25:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21d8: 0x46d3          MOV      R11, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'21da: 0xf38b 0x8810   MSR      PRIMASK, R11
  // }
  0x800'21de: 0x0020          MOVS     R0, R4
  0x800'21e0: 0xf000 0xf86e   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'21e4: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'21e8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'21ea: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_26:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21ec: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'21f0: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'21f4: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'21f8: 0x4281          CMP      R1, R0
  0x800'21fa: 0xd009          BEQ.N    ??_tx_thread_system_ni_resume_23
                                                              ; 0x800'2210
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21fc: 0x46d3          MOV      R11, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'21fe: 0xf38b 0x8810   MSR      PRIMASK, R11
  // }
  0x800'2202: 0x0020          MOVS     R0, R4
  0x800'2204: 0xf000 0xf86e   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2208: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'220c: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'220e: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_23:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2210: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2212: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2216: 0x480d          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'2218: 0x6800          LDR      R0, [R0]
  0x800'221a: 0x9000          STR      R0, [SP]
  //         if (combined_flags == ((ULONG) 0))
  0x800'221c: 0x9800          LDR      R0, [SP]
  0x800'221e: 0x2800          CMP      R0, #0
  0x800'2220: 0xd112          BNE.N    ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
  //             _tx_thread_performance_non_idle_return_count++;
  0x800'2222: 0x4916          LDR.N    R1, ??DataTable1_12    ; _tx_thread_performance_non_idle_return_count
  0x800'2224: 0x6808          LDR      R0, [R1]
  0x800'2226: 0x1c40          ADDS     R0, R0, #1
  0x800'2228: 0x6008          STR      R0, [R1]
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'222a: 0xf05f 0x5080   MOVS.W   R0, #268435456         ; 0x1000'0000
  0x800'222e: 0x4a14          LDR.N    R2, ??DataTable1_13    ; 0xe000'ed04
  0x800'2230: 0x6010          STR      R0, [R2]
  //     if (__get_ipsr_value() == 0)
  0x800'2232: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'2236: 0x2800          CMP      R0, #0
  0x800'2238: 0xd106          BNE.N    ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'223a: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'223e: 0x0001          MOVS     R1, R0
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'2240: 0xb662          CPSIE    i
  // }
  0x800'2242: 0x0008          MOVS     R0, R1
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2244: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_system_ni_resume_19:
                ??_tx_thread_system_ni_resume_22:
                ??_tx_thread_system_ni_resume_27:
  // }
  0x800'2248: 0xe8bd 0x8ff7   POP.W    {R0-R2, R4-R11, PC}
                `$d.32`:
                ??DataTable1:
  0x800'224c: 0x2000'246c     DC32     _tx_thread_preempt_disable
                ??DataTable1_1:
  0x800'2250: 0x2000'247c     DC32     _tx_thread_performance_resume_count
                ??DataTable1_2:
  0x800'2254: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
                ??DataTable1_3:
  0x800'2258: 0x2000'224c     DC32     _tx_thread_priority_list
                ??DataTable1_4:
  0x800'225c: 0x2000'2464     DC32     _tx_thread_priority_maps
                ??DataTable1_5:
  0x800'2260: 0x2000'2468     DC32     _tx_thread_highest_priority
                ??DataTable1_6:
  0x800'2264: 0x2000'2458     DC32     _tx_thread_execute_ptr
                ??DataTable1_7:
  0x800'2268: 0x2000'0008     DC32     _tx_thread_system_state
                ??DataTable1_8:
  0x800'226c: 0x2000'2484     DC32     _tx_thread_performance_solicited_preemption_count
                ??DataTable1_9:
  0x800'2270: 0x2000'2488     DC32     _tx_thread_performance_interrupt_preemption_count
                ??DataTable1_10:
  0x800'2274: 0x2000'249c     DC32     _tx_thread_performance__execute_log_index
                ??DataTable1_11:
  0x800'2278: 0x2000'2410     DC32     _tx_thread_performance_execute_log
                ??DataTable1_12:
  0x800'227c: 0x2000'2498     DC32     _tx_thread_performance_non_idle_return_count
                ??DataTable1_13:
  0x800'2280: 0xe000'ed04     DC32     0xe000'ed04            ; '....'
                ??DataTable1_14:
  0x800'2284: 0x2000'2454     DC32     _tx_thread_current_ptr
                $t:
                `.text8`:
                _tx_timer_system_deactivate:
  // VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
  // {
  0x800'2288: 0xb410          PUSH     {R4}
  //     list_head =  timer_ptr -> tx_timer_internal_list_head;
  0x800'228a: 0x6981          LDR      R1, [R0, #0x18]
  //     if (list_head != TX_NULL)
  0x800'228c: 0x2900          CMP      R1, #0
  0x800'228e: 0xd014          BEQ.N    ??_tx_timer_system_deactivate_0
                                                              ; 0x800'22ba
  //         next_timer =  timer_ptr -> tx_timer_internal_active_next;
  0x800'2290: 0x6904          LDR      R4, [R0, #0x10]
  0x800'2292: 0x0022          MOVS     R2, R4
  //         if (timer_ptr == next_timer)
  0x800'2294: 0x4290          CMP      R0, R2
  0x800'2296: 0xd105          BNE.N    ??_tx_timer_system_deactivate_1
                                                              ; 0x800'22a4
  //             if (*(list_head) == timer_ptr)
  0x800'2298: 0x680c          LDR      R4, [R1]
  0x800'229a: 0x4284          CMP      R4, R0
  0x800'229c: 0xd10b          BNE.N    ??_tx_timer_system_deactivate_2
                                                              ; 0x800'22b6
  //                 *(list_head) =  TX_NULL;
  0x800'229e: 0x2400          MOVS     R4, #0
  0x800'22a0: 0x600c          STR      R4, [R1]
  0x800'22a2: 0xe008          B.N      ??_tx_timer_system_deactivate_2
                                                              ; 0x800'22b6
                ??_tx_timer_system_deactivate_1:
  //             previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
  0x800'22a4: 0x6944          LDR      R4, [R0, #0x14]
  0x800'22a6: 0x0023          MOVS     R3, R4
  //             next_timer -> tx_timer_internal_active_previous =  previous_timer;
  0x800'22a8: 0x6153          STR      R3, [R2, #0x14]
  //             previous_timer -> tx_timer_internal_active_next =  next_timer;
  0x800'22aa: 0x611a          STR      R2, [R3, #0x10]
  //             if (*(list_head) == timer_ptr)
  0x800'22ac: 0x680c          LDR      R4, [R1]
  0x800'22ae: 0x4284          CMP      R4, R0
  0x800'22b0: 0xd101          BNE.N    ??_tx_timer_system_deactivate_2
                                                              ; 0x800'22b6
  //                 next_timer -> tx_timer_internal_list_head =  list_head;
  0x800'22b2: 0x6191          STR      R1, [R2, #0x18]
  //                 *(list_head) =  next_timer;
  0x800'22b4: 0x600a          STR      R2, [R1]
                ??_tx_timer_system_deactivate_2:
  //         timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
  0x800'22b6: 0x2400          MOVS     R4, #0
  0x800'22b8: 0x6184          STR      R4, [R0, #0x18]
                ??_tx_timer_system_deactivate_0:
  // }
  0x800'22ba: 0xbc10          POP      {R4}
  0x800'22bc: 0x4770          BX       LR
  0x800'22be: 0x0000          MOVS     R0, R0
                `.text8`:
                _tx_thread_stack_error_handler:
  // VOID  _tx_thread_stack_error_handler(TX_THREAD *thread_ptr)
  // {
  0x800'22c0: 0xb538          PUSH     {R3-R5, LR}
  0x800'22c2: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'22c4: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'22c8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'22ca: 0x4905          LDR.N    R1, ??_tx_thread_stack_error_handler_0
                                                              ; _tx_thread_application_stack_error_handler
  0x800'22cc: 0x6808          LDR      R0, [R1]
  0x800'22ce: 0x2800          CMP      R0, #0
  0x800'22d0: 0xd002          BEQ.N    ??_tx_thread_stack_error_handler_1
                                                              ; 0x800'22d8
  //         (_tx_thread_application_stack_error_handler)(thread_ptr);
  0x800'22d2: 0x0020          MOVS     R0, R4
  0x800'22d4: 0x6809          LDR      R1, [R1]
  0x800'22d6: 0x4788          BLX      R1
                ??_tx_thread_stack_error_handler_1:
  //     TX_RESTORE
  0x800'22d8: 0x0028          MOVS     R0, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'22da: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'22de: 0xbd31          POP      {R0, R4, R5, PC}
                `$d.32`:
                ??_tx_thread_stack_error_handler_0:
  0x800'22e0: 0x2000'2478     DC32     _tx_thread_application_stack_error_handler
                $t:
                `.text8`:
                _tx_thread_stack_analyze:
  // VOID  _tx_thread_stack_analyze(TX_THREAD *thread_ptr)
  // {
  0x800'22e4: 0xb4f0          PUSH     {R4-R7}
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'22e6: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'22ea: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'22ec: 0x2800          CMP      R0, #0
  0x800'22ee: 0xd03e          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //         if (thread_ptr -> tx_thread_id == TX_THREAD_ID)
  0x800'22f0: 0x4e21          LDR.N    R6, ??_tx_thread_stack_analyze_0
                                                              ; 0x5448'5244
  0x800'22f2: 0x6807          LDR      R7, [R0]
  0x800'22f4: 0x42b7          CMP      R7, R6
  0x800'22f6: 0xd13a          BNE.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //             stack_lowest =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_start);
  0x800'22f8: 0x68c7          LDR      R7, [R0, #0xc]
  0x800'22fa: 0x0039          MOVS     R1, R7
  //             if (stack_lowest != TX_NULL)
  0x800'22fc: 0x2900          CMP      R1, #0
  0x800'22fe: 0xd036          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                 stack_highest =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_highest_ptr);
  0x800'2300: 0xf8d0 0x70cc   LDR.W    R7, [R0, #0xcc]
  0x800'2304: 0x003a          MOVS     R2, R7
  //                 if (stack_highest != TX_NULL)
  0x800'2306: 0x2a00          CMP      R2, #0
  0x800'2308: 0xd031          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                     TX_RESTORE
  0x800'230a: 0x002f          MOVS     R7, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'230c: 0xf387 0x8810   MSR      PRIMASK, R7
                ??_tx_thread_stack_analyze_2:
  // }
  0x800'2310: 0x1a57          SUBS     R7, R2, R1
  0x800'2312: 0x10bf          ASRS     R7, R7, #2
  0x800'2314: 0x087f          LSRS     R7, R7, #1
  0x800'2316: 0x003c          MOVS     R4, R7
  //                         stack_ptr =  TX_ULONG_POINTER_ADD(stack_lowest, size);
  0x800'2318: 0xeb01 0x0784   ADD.W    R7, R1, R4, LSL #2
  0x800'231c: 0x003b          MOVS     R3, R7
  //                         if (*stack_ptr != TX_STACK_FILL)
  0x800'231e: 0xf8d3 0xc000   LDR.W    R12, [R3]
  0x800'2322: 0xf8d0 0x70d4   LDR.W    R7, [R0, #0xd4]
  0x800'2326: 0x45bc          CMP      R12, R7
  0x800'2328: 0xd001          BEQ.N    ??_tx_thread_stack_analyze_3
                                                              ; 0x800'232e
  //                             stack_highest =  stack_ptr;
  0x800'232a: 0x001a          MOVS     R2, R3
  0x800'232c: 0xe000          B.N      ??_tx_thread_stack_analyze_4
                                                              ; 0x800'2330
                ??_tx_thread_stack_analyze_3:
  //                             stack_lowest =  stack_ptr;
  0x800'232e: 0x0019          MOVS     R1, R3
                ??_tx_thread_stack_analyze_4:
  //                     } while(size > ((ULONG) 1));
  0x800'2330: 0x2c02          CMP      R4, #2
  0x800'2332: 0xd2ed          BCS.N    ??_tx_thread_stack_analyze_2
                                                              ; 0x800'2310
                ??_tx_thread_stack_analyze_5:
  //                     while (*stack_ptr == TX_STACK_FILL)
  0x800'2334: 0xf8d3 0xc000   LDR.W    R12, [R3]
  0x800'2338: 0xf8d0 0x70d4   LDR.W    R7, [R0, #0xd4]
  0x800'233c: 0x45bc          CMP      R12, R7
  0x800'233e: 0xd101          BNE.N    ??_tx_thread_stack_analyze_6
                                                              ; 0x800'2344
  //                         stack_ptr =  TX_ULONG_POINTER_ADD(stack_ptr, 1);
  0x800'2340: 0x1d1b          ADDS     R3, R3, #4
  0x800'2342: 0xe7f7          B.N      ??_tx_thread_stack_analyze_5
                                                              ; 0x800'2334
                ??_tx_thread_stack_analyze_6:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2344: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'2348: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'234a: 0x003d          MOVS     R5, R7
  //                     if (thread_ptr -> tx_thread_id == TX_THREAD_ID)
  0x800'234c: 0x6807          LDR      R7, [R0]
  0x800'234e: 0x42b7          CMP      R7, R6
  0x800'2350: 0xd10d          BNE.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                         if (stack_ptr > (TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_start)))
  0x800'2352: 0x68c6          LDR      R6, [R0, #0xc]
  0x800'2354: 0x429e          CMP      R6, R3
  0x800'2356: 0xd20a          BCS.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                             if (stack_ptr < (TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_highest_ptr)))
  0x800'2358: 0xf8d0 0x60cc   LDR.W    R6, [R0, #0xcc]
  0x800'235c: 0x42b3          CMP      R3, R6
  0x800'235e: 0xd206          BCS.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                                 if (*stack_ptr != TX_STACK_FILL)
  0x800'2360: 0x681f          LDR      R7, [R3]
  0x800'2362: 0xf8d0 0x60d4   LDR.W    R6, [R0, #0xd4]
  0x800'2366: 0x42b7          CMP      R7, R6
  0x800'2368: 0xd001          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                                     thread_ptr -> tx_thread_stack_highest_ptr =  stack_ptr;
  0x800'236a: 0xf8c0 0x30cc   STR.W    R3, [R0, #0xcc]
                ??_tx_thread_stack_analyze_1:
  //     TX_RESTORE
  0x800'236e: 0x002e          MOVS     R6, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2370: 0xf386 0x8810   MSR      PRIMASK, R6
  // }
  0x800'2374: 0xbcf0          POP      {R4-R7}
  0x800'2376: 0x4770          BX       LR
                `$d.32`:
                ??_tx_thread_stack_analyze_0:
  0x800'2378: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
                $t:
                `.text_3`:
                _tx_thread_system_ni_suspend:
  // VOID  _tx_thread_system_ni_suspend(TX_THREAD *thread_ptr, ULONG wait_option)
  // {
  0x800'237c: 0xe92d 0x4ff0   PUSH.W   {R4-R11, LR}
  0x800'2380: 0xb085          SUB      SP, SP, #0x14
  0x800'2382: 0x0004          MOVS     R4, R0
  0x800'2384: 0x000d          MOVS     R5, R1
  //     TX_THREAD_GET_CURRENT(current_thread)
  0x800'2386: 0x48b8          LDR.N    R0, ??DataTable1_1     ; _tx_thread_current_ptr
  0x800'2388: 0x6806          LDR      R6, [R0]
  //     if (thread_ptr == current_thread)
  0x800'238a: 0x42b4          CMP      R4, R6
  0x800'238c: 0xd10c          BNE.N    ??_tx_thread_system_ni_suspend_0
                                                              ; 0x800'23a8
  //         if (wait_option != TX_NO_WAIT)
  0x800'238e: 0x2d00          CMP      R5, #0
  0x800'2390: 0xd007          BEQ.N    ??_tx_thread_system_ni_suspend_1
                                                              ; 0x800'23a2
  //             if (wait_option != TX_WAIT_FOREVER)
  0x800'2392: 0xf115 0x0f01   CMN.W    R5, #1
  0x800'2396: 0xd004          BEQ.N    ??_tx_thread_system_ni_suspend_1
                                                              ; 0x800'23a2
  //                 thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
  0x800'2398: 0x64e5          STR      R5, [R4, #0x4c]
  //                 _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
  0x800'239a: 0xf114 0x004c   ADDS.W   R0, R4, #76            ; 0x4c
  0x800'239e: 0xf000 0xf97d   BL       _tx_timer_system_activate
                                                              ; 0x800'269c
                ??_tx_thread_system_ni_suspend_1:
  //         _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
  0x800'23a2: 0x69e1          LDR      R1, [R4, #0x1c]
  0x800'23a4: 0x48b1          LDR.N    R0, ??DataTable1_2     ; _tx_timer_time_slice
  0x800'23a6: 0x6001          STR      R1, [R0]
                ??_tx_thread_system_ni_suspend_0:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'23a8: 0xf3ef 0x8910   MRS      R9, PRIMASK
  //     return(posture);
  0x800'23ac: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'23ae: 0x2c00          CMP      R4, #0
  0x800'23b0: 0xd039          BEQ.N    ??_tx_thread_system_ni_suspend_2
                                                              ; 0x800'2426
  0x800'23b2: 0x6821          LDR      R1, [R4]
  0x800'23b4: 0x48ae          LDR.N    R0, ??DataTable1_3     ; 0x5448'5244
  0x800'23b6: 0x4281          CMP      R1, R0
  0x800'23b8: 0xd135          BNE.N    ??_tx_thread_system_ni_suspend_2
                                                              ; 0x800'2426
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23ba: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'23bc: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'23c0: 0x4288          CMP      R0, R1
  0x800'23c2: 0xd202          BCS.N    ??_tx_thread_system_ni_suspend_3
                                                              ; 0x800'23ca
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23c4: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'23c6: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_ni_suspend_3:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23ca: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'23cc: 0x6800          LDR      R0, [R0]
  0x800'23ce: 0xf8d4 0x10d4   LDR.W    R1, [R4, #0xd4]
  0x800'23d2: 0x4288          CMP      R0, R1
  0x800'23d4: 0xd10b          BNE.N    ??_tx_thread_system_ni_suspend_4
                                                              ; 0x800'23ee
  0x800'23d6: 0x6920          LDR      R0, [R4, #0x10]
  0x800'23d8: 0xf8d0 0x0001   LDR.W    R0, [R0, #0x1]
  0x800'23dc: 0xf8d4 0x10d4   LDR.W    R1, [R4, #0xd4]
  0x800'23e0: 0x4288          CMP      R0, R1
  0x800'23e2: 0xd104          BNE.N    ??_tx_thread_system_ni_suspend_4
                                                              ; 0x800'23ee
  0x800'23e4: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'23e8: 0x68e1          LDR      R1, [R4, #0xc]
  0x800'23ea: 0x4288          CMP      R0, R1
  0x800'23ec: 0xd209          BCS.N    ??_tx_thread_system_ni_suspend_5
                                                              ; 0x800'2402
                ??_tx_thread_system_ni_suspend_4:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23ee: 0x464f          MOV      R7, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'23f0: 0xf387 0x8810   MSR      PRIMASK, R7
  // }
  0x800'23f4: 0x0020          MOVS     R0, R4
  0x800'23f6: 0xf7ff 0xff63   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'23fa: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'23fe: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2400: 0x4681          MOV      R9, R0
                ??_tx_thread_system_ni_suspend_5:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2402: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'2406: 0xf850 0x0c04   LDR.W    R0, [R0, #-0x4]
  0x800'240a: 0xf8d4 0x10d4   LDR.W    R1, [R4, #0xd4]
  0x800'240e: 0x4288          CMP      R0, R1
  0x800'2410: 0xd009          BEQ.N    ??_tx_thread_system_ni_suspend_2
                                                              ; 0x800'2426
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2412: 0x464f          MOV      R7, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2414: 0xf387 0x8810   MSR      PRIMASK, R7
  // }
  0x800'2418: 0x0020          MOVS     R0, R4
  0x800'241a: 0xf7ff 0xff63   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'241e: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2422: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2424: 0x4681          MOV      R9, R0
                ??_tx_thread_system_ni_suspend_2:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2426: 0x4648          MOV      R0, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2428: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'242c: 0xf8d4 0x10a8   LDR.W    R1, [R4, #0xa8]
  0x800'2430: 0x1c49          ADDS     R1, R1, #1
  0x800'2432: 0xf8c4 0x10a8   STR.W    R1, [R4, #0xa8]
  //     _tx_thread_performance_suspend_count++;
  0x800'2436: 0x4a8f          LDR.N    R2, ??DataTable1_4     ; _tx_thread_performance_suspend_count
  0x800'2438: 0x6811          LDR      R1, [R2]
  0x800'243a: 0x1c49          ADDS     R1, R1, #1
  0x800'243c: 0x6011          STR      R1, [R2]
  //     priority =  thread_ptr -> tx_thread_priority;
  0x800'243e: 0x6ae7          LDR      R7, [R4, #0x2c]
  //     ready_next =      thread_ptr -> tx_thread_ready_next;
  0x800'2440: 0xf8d4 0x8020   LDR.W    R8, [R4, #0x20]
  //     if (ready_next != thread_ptr)
  0x800'2444: 0x45a0          CMP      R8, R4
  0x800'2446: 0xd00d          BEQ.N    ??_tx_thread_system_ni_suspend_6
                                                              ; 0x800'2464
  //         ready_previous =  thread_ptr -> tx_thread_ready_previous;
  0x800'2448: 0x6a60          LDR      R0, [R4, #0x24]
  0x800'244a: 0x4683          MOV      R11, R0
  //         ready_next -> tx_thread_ready_previous =    ready_previous;
  0x800'244c: 0xf8c8 0xb024   STR.W    R11, [R8, #0x24]
  //         ready_previous -> tx_thread_ready_next =    ready_next;
  0x800'2450: 0xf8cb 0x8020   STR.W    R8, [R11, #0x20]
  //         if (_tx_thread_priority_list[priority] == thread_ptr)
  0x800'2454: 0x4988          LDR.N    R1, ??DataTable1_5     ; _tx_thread_priority_list
  0x800'2456: 0xf851 0x0027   LDR.W    R0, [R1, R7, LSL #2]
  0x800'245a: 0x42a0          CMP      R0, R4
  0x800'245c: 0xd13e          BNE.N    ??_tx_thread_system_ni_suspend_7
                                                              ; 0x800'24dc
  //             _tx_thread_priority_list[priority] =  ready_next;
  0x800'245e: 0xf841 0x8027   STR.W    R8, [R1, R7, LSL #2]
  0x800'2462: 0xe03b          B.N      ??_tx_thread_system_ni_suspend_7
                                                              ; 0x800'24dc
                ??_tx_thread_system_ni_suspend_6:
  //         _tx_thread_priority_list[priority] =    TX_NULL;
  0x800'2464: 0x2100          MOVS     R1, #0
  0x800'2466: 0x4884          LDR.N    R0, ??DataTable1_5     ; _tx_thread_priority_list
  0x800'2468: 0xf840 0x1027   STR.W    R1, [R0, R7, LSL #2]
  //         TX_MOD32_BIT_SET(priority, priority_bit)
  0x800'246c: 0x2201          MOVS     R2, #1
  0x800'246e: 0x40ba          LSLS     R2, R2, R7
  //         _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
  0x800'2470: 0x4882          LDR.N    R0, ??DataTable1_6     ; _tx_thread_priority_maps
  0x800'2472: 0x6801          LDR      R1, [R0]
  0x800'2474: 0x4391          BICS     R1, R1, R2
  0x800'2476: 0x6001          STR      R1, [R0]
  //         base_priority =   ((UINT) 0);
  0x800'2478: 0x2100          MOVS     R1, #0
  0x800'247a: 0x9103          STR      R1, [SP, #0xc]
  //         priority_map =    _tx_thread_priority_maps[MAP_INDEX];
  0x800'247c: 0x6800          LDR      R0, [R0]
  0x800'247e: 0x9000          STR      R0, [SP]
  //         if (priority_map == ((ULONG) 0))
  0x800'2480: 0x9800          LDR      R0, [SP]
  0x800'2482: 0x2800          CMP      R0, #0
  0x800'2484: 0xd11f          BNE.N    ??_tx_thread_system_ni_suspend_8
                                                              ; 0x800'24c6
  //             _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
  0x800'2486: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'2488: 0x497d          LDR.N    R1, ??DataTable1_7     ; _tx_thread_highest_priority
  0x800'248a: 0x6008          STR      R0, [R1]
  //             _tx_thread_execute_ptr =       TX_NULL;
  0x800'248c: 0x2100          MOVS     R1, #0
  0x800'248e: 0x487d          LDR.N    R0, ??DataTable1_8     ; _tx_thread_execute_ptr
  0x800'2490: 0x6001          STR      R1, [R0]
  //             TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  0x800'2492: 0x4874          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'2494: 0x6800          LDR      R0, [R0]
  //             if (combined_flags == ((ULONG) 0))
  0x800'2496: 0x2800          CMP      R0, #0
  0x800'2498: 0xd114          BNE.N    ??_tx_thread_system_ni_suspend_9
                                                              ; 0x800'24c4
  //                 _tx_thread_performance_idle_return_count++;
  0x800'249a: 0x497b          LDR.N    R1, ??DataTable1_9     ; _tx_thread_performance_idle_return_count
  0x800'249c: 0x680b          LDR      R3, [R1]
  0x800'249e: 0x1c5b          ADDS     R3, R3, #1
  0x800'24a0: 0x600b          STR      R3, [R1]
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'24a2: 0xf05f 0x5180   MOVS.W   R1, #268435456         ; 0x1000'0000
  0x800'24a6: 0xf8df 0xc1e4   LDR.W    R12, ??DataTable1_10   ; 0xe000'ed04
  0x800'24aa: 0xf8cc 0x1000   STR.W    R1, [R12]
  //     if (__get_ipsr_value() == 0)
  0x800'24ae: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'24b2: 0x2900          CMP      R1, #0
  0x800'24b4: 0xd106          BNE.N    ??_tx_thread_system_ni_suspend_9
                                                              ; 0x800'24c4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'24b6: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'24ba: 0x000b          MOVS     R3, R1
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'24bc: 0xb662          CPSIE    i
  // }
  0x800'24be: 0x0019          MOVS     R1, R3
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'24c0: 0xf381 0x8810   MSR      PRIMASK, R1
                ??_tx_thread_system_ni_suspend_10:
                ??_tx_thread_system_ni_suspend_9:
  // }
  0x800'24c4: 0xe0ca          B.N      ??_tx_thread_system_ni_suspend_26
                                                              ; 0x800'265c
                ??_tx_thread_system_ni_suspend_8:
  //             TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
  0x800'24c6: 0x9800          LDR      R0, [SP]
  0x800'24c8: 0xfa90 0xf0a0   RBIT.W   R0, R0
  0x800'24cc: 0xfab0 0xf080   CLZ      R0, R0
  0x800'24d0: 0x9002          STR      R0, [SP, #0x8]
  //             _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
  0x800'24d2: 0x9903          LDR      R1, [SP, #0xc]
  0x800'24d4: 0x9802          LDR      R0, [SP, #0x8]
  0x800'24d6: 0x1841          ADDS     R1, R0, R1
  0x800'24d8: 0x4869          LDR.N    R0, ??DataTable1_7     ; _tx_thread_highest_priority
  0x800'24da: 0x6001          STR      R1, [R0]
                ??_tx_thread_system_ni_suspend_7:
  //     if (thread_ptr == _tx_thread_execute_ptr)
  0x800'24dc: 0xf8df 0x91a4   LDR.W    R9, ??DataTable1_8     ; _tx_thread_execute_ptr
  0x800'24e0: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'24e4: 0x4284          CMP      R4, R0
  0x800'24e6: 0xd134          BNE.N    ??_tx_thread_system_ni_suspend_12
                                                              ; 0x800'2552
  //         _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
  0x800'24e8: 0x4863          LDR.N    R0, ??DataTable1_5     ; _tx_thread_priority_list
  0x800'24ea: 0x4965          LDR.N    R1, ??DataTable1_7     ; _tx_thread_highest_priority
  0x800'24ec: 0x6809          LDR      R1, [R1]
  0x800'24ee: 0xf850 0x0021   LDR.W    R0, [R0, R1, LSL #2]
  0x800'24f2: 0xf8c9 0x0000   STR.W    R0, [R9]
  //         if (_tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] != _tx_thread_execute_ptr)
  0x800'24f6: 0x4866          LDR.N    R0, ??DataTable1_11    ; _tx_thread_performance__execute_log_index
  0x800'24f8: 0x4966          LDR.N    R1, ??DataTable1_12    ; _tx_thread_performance_execute_log
  0x800'24fa: 0x6802          LDR      R2, [R0]
  0x800'24fc: 0xf851 0x3022   LDR.W    R3, [R1, R2, LSL #2]
  0x800'2500: 0xf8d9 0x2000   LDR.W    R2, [R9]
  0x800'2504: 0x4293          CMP      R3, R2
  0x800'2506: 0xd00c          BEQ.N    ??_tx_thread_system_ni_suspend_13
                                                              ; 0x800'2522
  //             _tx_thread_performance__execute_log_index++;
  0x800'2508: 0x6802          LDR      R2, [R0]
  0x800'250a: 0x1c52          ADDS     R2, R2, #1
  0x800'250c: 0x6002          STR      R2, [R0]
  //             if (_tx_thread_performance__execute_log_index >= TX_THREAD_EXECUTE_LOG_SIZE)
  0x800'250e: 0x6802          LDR      R2, [R0]
  0x800'2510: 0x2a08          CMP      R2, #8
  0x800'2512: 0xd301          BCC.N    ??_tx_thread_system_ni_suspend_14
                                                              ; 0x800'2518
  //                 _tx_thread_performance__execute_log_index =  ((UINT) 0);
  0x800'2514: 0x2200          MOVS     R2, #0
  0x800'2516: 0x6002          STR      R2, [R0]
                ??_tx_thread_system_ni_suspend_14:
  //             _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
  0x800'2518: 0xf8d9 0x2000   LDR.W    R2, [R9]
  0x800'251c: 0x6800          LDR      R0, [R0]
  0x800'251e: 0xf841 0x2020   STR.W    R2, [R1, R0, LSL #2]
                ??_tx_thread_system_ni_suspend_13:
  //         TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  0x800'2522: 0x4850          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'2524: 0x6800          LDR      R0, [R0]
  //         if (combined_flags == ((ULONG) 0))
  0x800'2526: 0x2800          CMP      R0, #0
  0x800'2528: 0xd112          BNE.N    ??_tx_thread_system_ni_suspend_16
                                                              ; 0x800'2550
  //             _tx_thread_performance_non_idle_return_count++;
  0x800'252a: 0x495b          LDR.N    R1, ??DataTable1_13    ; _tx_thread_performance_non_idle_return_count
  0x800'252c: 0x680a          LDR      R2, [R1]
  0x800'252e: 0x1c52          ADDS     R2, R2, #1
  0x800'2530: 0x600a          STR      R2, [R1]
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'2532: 0xf05f 0x5380   MOVS.W   R3, #268435456         ; 0x1000'0000
  0x800'2536: 0x4955          LDR.N    R1, ??DataTable1_10    ; 0xe000'ed04
  0x800'2538: 0x600b          STR      R3, [R1]
  //     if (__get_ipsr_value() == 0)
  0x800'253a: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'253e: 0x2900          CMP      R1, #0
  0x800'2540: 0xd106          BNE.N    ??_tx_thread_system_ni_suspend_16
                                                              ; 0x800'2550
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2542: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'2546: 0x000a          MOVS     R2, R1
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'2548: 0xb662          CPSIE    i
  // }
  0x800'254a: 0x0011          MOVS     R1, R2
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'254c: 0xf381 0x8810   MSR      PRIMASK, R1
                ??_tx_thread_system_ni_suspend_15:
                ??_tx_thread_system_ni_suspend_16:
  // }
  0x800'2550: 0xe084          B.N      ??_tx_thread_system_ni_suspend_26
                                                              ; 0x800'265c
                ??_tx_thread_system_ni_suspend_12:
  //     if (_tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] != _tx_thread_execute_ptr)
  0x800'2552: 0x484f          LDR.N    R0, ??DataTable1_11    ; _tx_thread_performance__execute_log_index
  0x800'2554: 0x494f          LDR.N    R1, ??DataTable1_12    ; _tx_thread_performance_execute_log
  0x800'2556: 0x6802          LDR      R2, [R0]
  0x800'2558: 0xf851 0x3022   LDR.W    R3, [R1, R2, LSL #2]
  0x800'255c: 0xf8d9 0x2000   LDR.W    R2, [R9]
  0x800'2560: 0x4293          CMP      R3, R2
  0x800'2562: 0xd00c          BEQ.N    ??_tx_thread_system_ni_suspend_17
                                                              ; 0x800'257e
  //         _tx_thread_performance__execute_log_index++;
  0x800'2564: 0x6802          LDR      R2, [R0]
  0x800'2566: 0x1c52          ADDS     R2, R2, #1
  0x800'2568: 0x6002          STR      R2, [R0]
  //         if (_tx_thread_performance__execute_log_index >= TX_THREAD_EXECUTE_LOG_SIZE)
  0x800'256a: 0x6802          LDR      R2, [R0]
  0x800'256c: 0x2a08          CMP      R2, #8
  0x800'256e: 0xd301          BCC.N    ??_tx_thread_system_ni_suspend_18
                                                              ; 0x800'2574
  //             _tx_thread_performance__execute_log_index =  ((UINT) 0);
  0x800'2570: 0x2200          MOVS     R2, #0
  0x800'2572: 0x6002          STR      R2, [R0]
                ??_tx_thread_system_ni_suspend_18:
  //         _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
  0x800'2574: 0xf8d9 0x2000   LDR.W    R2, [R9]
  0x800'2578: 0x6800          LDR      R0, [R0]
  0x800'257a: 0xf841 0x2020   STR.W    R2, [R1, R0, LSL #2]
                ??_tx_thread_system_ni_suspend_17:
  //     if (current_thread != _tx_thread_execute_ptr)
  0x800'257e: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'2582: 0x4286          CMP      R6, R0
  0x800'2584: 0xd06a          BEQ.N    ??_tx_thread_system_ni_suspend_26
                                                              ; 0x800'265c
  //         thread_ptr =  _tx_thread_execute_ptr;
  0x800'2586: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'258a: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'258c: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'2590: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2592: 0x2c00          CMP      R4, #0
  0x800'2594: 0xd03d          BEQ.N    ??_tx_thread_system_ni_suspend_20
                                                              ; 0x800'2612
  0x800'2596: 0x6821          LDR      R1, [R4]
  0x800'2598: 0x4835          LDR.N    R0, ??DataTable1_3     ; 0x5448'5244
  0x800'259a: 0x4281          CMP      R1, R0
  0x800'259c: 0xd139          BNE.N    ??_tx_thread_system_ni_suspend_20
                                                              ; 0x800'2612
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'259e: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'25a0: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'25a4: 0x4281          CMP      R1, R0
  0x800'25a6: 0xd202          BCS.N    ??_tx_thread_system_ni_suspend_21
                                                              ; 0x800'25ae
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'25a8: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'25aa: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_ni_suspend_21:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'25ae: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'25b0: 0x6801          LDR      R1, [R0]
  0x800'25b2: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'25b6: 0x4281          CMP      R1, R0
  0x800'25b8: 0xd10b          BNE.N    ??_tx_thread_system_ni_suspend_22
                                                              ; 0x800'25d2
  0x800'25ba: 0x6920          LDR      R0, [R4, #0x10]
  0x800'25bc: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'25c0: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'25c4: 0x4281          CMP      R1, R0
  0x800'25c6: 0xd104          BNE.N    ??_tx_thread_system_ni_suspend_22
                                                              ; 0x800'25d2
  0x800'25c8: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'25cc: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'25ce: 0x4281          CMP      R1, R0
  0x800'25d0: 0xd20b          BCS.N    ??_tx_thread_system_ni_suspend_23
                                                              ; 0x800'25ea
                ??_tx_thread_system_ni_suspend_22:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'25d2: 0xf8cd 0xa010   STR.W    R10, [SP, #0x10]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'25d6: 0x9804          LDR      R0, [SP, #0x10]
  0x800'25d8: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'25dc: 0x0020          MOVS     R0, R4
  0x800'25de: 0xf7ff 0xfe6f   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'25e2: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'25e6: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'25e8: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_suspend_23:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'25ea: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'25ee: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'25f2: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'25f6: 0x4281          CMP      R1, R0
  0x800'25f8: 0xd00b          BEQ.N    ??_tx_thread_system_ni_suspend_20
                                                              ; 0x800'2612
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'25fa: 0xf8cd 0xa010   STR.W    R10, [SP, #0x10]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'25fe: 0x9804          LDR      R0, [SP, #0x10]
  0x800'2600: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'2604: 0x0020          MOVS     R0, R4
  0x800'2606: 0xf7ff 0xfe6d   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'260a: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'260e: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2610: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_suspend_20:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2612: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2614: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2618: 0x4812          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'261a: 0x6800          LDR      R0, [R0]
  0x800'261c: 0x9001          STR      R0, [SP, #0x4]
  //         if (combined_flags == ((ULONG) 0))
  0x800'261e: 0x9801          LDR      R0, [SP, #0x4]
  0x800'2620: 0x2800          CMP      R0, #0
  0x800'2622: 0xd11b          BNE.N    ??_tx_thread_system_ni_suspend_26
                                                              ; 0x800'265c
  //             if (_tx_thread_execute_ptr == TX_NULL)
  0x800'2624: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'2628: 0x2800          CMP      R0, #0
  0x800'262a: 0xd104          BNE.N    ??_tx_thread_system_ni_suspend_24
                                                              ; 0x800'2636
  //                 _tx_thread_performance_idle_return_count++;
  0x800'262c: 0x4916          LDR.N    R1, ??DataTable1_9     ; _tx_thread_performance_idle_return_count
  0x800'262e: 0x6808          LDR      R0, [R1]
  0x800'2630: 0x1c40          ADDS     R0, R0, #1
  0x800'2632: 0x6008          STR      R0, [R1]
  0x800'2634: 0xe003          B.N      ??_tx_thread_system_ni_suspend_25
                                                              ; 0x800'263e
                ??_tx_thread_system_ni_suspend_24:
  //                 _tx_thread_performance_non_idle_return_count++;
  0x800'2636: 0x4918          LDR.N    R1, ??DataTable1_13    ; _tx_thread_performance_non_idle_return_count
  0x800'2638: 0x6808          LDR      R0, [R1]
  0x800'263a: 0x1c40          ADDS     R0, R0, #1
  0x800'263c: 0x6008          STR      R0, [R1]
                ??_tx_thread_system_ni_suspend_25:
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'263e: 0xf05f 0x5280   MOVS.W   R2, #268435456         ; 0x1000'0000
  0x800'2642: 0x4812          LDR.N    R0, ??DataTable1_10    ; 0xe000'ed04
  0x800'2644: 0x6002          STR      R2, [R0]
  //     if (__get_ipsr_value() == 0)
  0x800'2646: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'264a: 0x2800          CMP      R0, #0
  0x800'264c: 0xd106          BNE.N    ??_tx_thread_system_ni_suspend_26
                                                              ; 0x800'265c
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'264e: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2652: 0x0001          MOVS     R1, R0
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'2654: 0xb662          CPSIE    i
  // }
  0x800'2656: 0x0008          MOVS     R0, R1
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2658: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_system_ni_suspend_11:
                ??_tx_thread_system_ni_suspend_19:
                ??_tx_thread_system_ni_suspend_26:
  // }
  0x800'265c: 0xb005          ADD      SP, SP, #0x14
  0x800'265e: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'2662: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable1:
  0x800'2664: 0x2000'246c     DC32     _tx_thread_preempt_disable
                ??DataTable1_1:
  0x800'2668: 0x2000'2454     DC32     _tx_thread_current_ptr
                ??DataTable1_2:
  0x800'266c: 0x2000'24d4     DC32     _tx_timer_time_slice
                ??DataTable1_3:
  0x800'2670: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
                ??DataTable1_4:
  0x800'2674: 0x2000'2480     DC32     _tx_thread_performance_suspend_count
                ??DataTable1_5:
  0x800'2678: 0x2000'224c     DC32     _tx_thread_priority_list
                ??DataTable1_6:
  0x800'267c: 0x2000'2464     DC32     _tx_thread_priority_maps
                ??DataTable1_7:
  0x800'2680: 0x2000'2468     DC32     _tx_thread_highest_priority
                ??DataTable1_8:
  0x800'2684: 0x2000'2458     DC32     _tx_thread_execute_ptr
                ??DataTable1_9:
  0x800'2688: 0x2000'2494     DC32     _tx_thread_performance_idle_return_count
                ??DataTable1_10:
  0x800'268c: 0xe000'ed04     DC32     0xe000'ed04            ; '....'
                ??DataTable1_11:
  0x800'2690: 0x2000'249c     DC32     _tx_thread_performance__execute_log_index
                ??DataTable1_12:
  0x800'2694: 0x2000'2410     DC32     _tx_thread_performance_execute_log
                ??DataTable1_13:
  0x800'2698: 0x2000'2498     DC32     _tx_thread_performance_non_idle_return_count
                $t:
                `.text8`:
                _tx_timer_system_activate:
  // VOID  _tx_timer_system_activate(TX_TIMER_INTERNAL *timer_ptr)
  // {
  0x800'269c: 0xb4f0          PUSH     {R4-R7}
  //     remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
  0x800'269e: 0x6801          LDR      R1, [R0]
  //     if (remaining_ticks != ((ULONG) 0))
  0x800'26a0: 0x2900          CMP      R1, #0
  0x800'26a2: 0xd031          BEQ.N    ??_tx_timer_system_activate_1
                                                              ; 0x800'2708
  //         if (remaining_ticks != TX_WAIT_FOREVER)
  0x800'26a4: 0xf111 0x0f01   CMN.W    R1, #1
  0x800'26a8: 0xd02e          BEQ.N    ??_tx_timer_system_activate_1
                                                              ; 0x800'2708
  //             if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
  0x800'26aa: 0x6982          LDR      R2, [R0, #0x18]
  0x800'26ac: 0x2a00          CMP      R2, #0
  0x800'26ae: 0xd12b          BNE.N    ??_tx_timer_system_activate_1
                                                              ; 0x800'2708
  //                 if (remaining_ticks > TX_TIMER_ENTRIES)
  0x800'26b0: 0x2921          CMP      R1, #33                ; 0x21
  0x800'26b2: 0xd302          BCC.N    ??_tx_timer_system_activate_2
                                                              ; 0x800'26ba
  //                     expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
  0x800'26b4: 0x221f          MOVS     R2, #31                ; 0x1f
  0x800'26b6: 0x0017          MOVS     R7, R2
  0x800'26b8: 0xe001          B.N      ??_tx_timer_system_activate_3
                                                              ; 0x800'26be
                ??_tx_timer_system_activate_2:
  //                     expiration_time =  (remaining_ticks - ((ULONG) 1));
  0x800'26ba: 0x1e4a          SUBS     R2, R1, #1
  0x800'26bc: 0x0017          MOVS     R7, R2
                ??_tx_timer_system_activate_3:
  //                 timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
  0x800'26be: 0x4a13          LDR.N    R2, ??_tx_timer_system_activate_0
                                                              ; _tx_timer_current_ptr
  0x800'26c0: 0x6812          LDR      R2, [R2]
  0x800'26c2: 0xeb02 0x0287   ADD.W    R2, R2, R7, LSL #2
  0x800'26c6: 0x0013          MOVS     R3, R2
  //                 if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
  0x800'26c8: 0xf8df 0xc044   LDR.W    R12, [PC, #0x44]       ; _tx_timer_list_end
  0x800'26cc: 0xf8dc 0x2000   LDR.W    R2, [R12]
  0x800'26d0: 0x4293          CMP      R3, R2
  0x800'26d2: 0xd309          BCC.N    ??_tx_timer_system_activate_4
                                                              ; 0x800'26e8
  //                     delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
  0x800'26d4: 0xf8dc 0x2000   LDR.W    R2, [R12]
  0x800'26d8: 0x1a9a          SUBS     R2, R3, R2
  0x800'26da: 0x1092          ASRS     R2, R2, #2
  0x800'26dc: 0x0016          MOVS     R6, R2
  //                     timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
  0x800'26de: 0x4a0d          LDR.N    R2, [PC, #0x34]        ; _tx_timer_list_start
  0x800'26e0: 0x6812          LDR      R2, [R2]
  0x800'26e2: 0xeb02 0x0286   ADD.W    R2, R2, R6, LSL #2
  0x800'26e6: 0x0013          MOVS     R3, R2
                ??_tx_timer_system_activate_4:
  //                 if ((*timer_list) == TX_NULL)
  0x800'26e8: 0x681a          LDR      R2, [R3]
  0x800'26ea: 0x2a00          CMP      R2, #0
  0x800'26ec: 0xd103          BNE.N    ??_tx_timer_system_activate_5
                                                              ; 0x800'26f6
  //                     timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
  0x800'26ee: 0x6100          STR      R0, [R0, #0x10]
  //                     timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
  0x800'26f0: 0x6140          STR      R0, [R0, #0x14]
  //                     *timer_list =  timer_ptr;
  0x800'26f2: 0x6018          STR      R0, [R3]
  0x800'26f4: 0xe007          B.N      ??_tx_timer_system_activate_6
                                                              ; 0x800'2706
                ??_tx_timer_system_activate_5:
  //                     next_timer =                                        *timer_list;
  0x800'26f6: 0x681a          LDR      R2, [R3]
  0x800'26f8: 0x0014          MOVS     R4, R2
  //                     previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
  0x800'26fa: 0x6962          LDR      R2, [R4, #0x14]
  0x800'26fc: 0x0015          MOVS     R5, R2
  //                     previous_timer -> tx_timer_internal_active_next =   timer_ptr;
  0x800'26fe: 0x6128          STR      R0, [R5, #0x10]
  //                     next_timer -> tx_timer_internal_active_previous =   timer_ptr;
  0x800'2700: 0x6160          STR      R0, [R4, #0x14]
  //                     timer_ptr -> tx_timer_internal_active_next =        next_timer;
  0x800'2702: 0x6104          STR      R4, [R0, #0x10]
  //                     timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
  0x800'2704: 0x6145          STR      R5, [R0, #0x14]
                ??_tx_timer_system_activate_6:
  //                 timer_ptr -> tx_timer_internal_list_head =  timer_list;
  0x800'2706: 0x6183          STR      R3, [R0, #0x18]
                ??_tx_timer_system_activate_1:
  // }
  0x800'2708: 0xbcf0          POP      {R4-R7}
  0x800'270a: 0x4770          BX       LR
                `$d.32`:
                ??_tx_timer_system_activate_0:
  0x800'270c: 0x2000'24b0     DC32     _tx_timer_current_ptr
  0x800'2710: 0x2000'24ac     DC32     _tx_timer_list_end
  0x800'2714: 0x2000'24a8     DC32     _tx_timer_list_start
                $t:
                `.text8`:
                _tx_timer_thread_entry:
  // VOID  _tx_timer_thread_entry(ULONG timer_thread_input)
  // {
  0x800'2718: 0xe92d 0x4ff1   PUSH.W   {R0, R4-R11, LR}
  0x800'271c: 0xb088          SUB      SP, SP, #0x20
  // ULONG                       timeout_param =  ((ULONG) 0);
  0x800'271e: 0x2000          MOVS     R0, #0
  0x800'2720: 0x9006          STR      R0, [SP, #0x18]
  //     if (timer_thread_input == TX_TIMER_ID)
  0x800'2722: 0x9908          LDR      R1, [SP, #0x20]
  0x800'2724: 0x488a          LDR.N    R0, ??_tx_timer_thread_entry_0
                                                              ; 0x4154'494d
  0x800'2726: 0x4281          CMP      R1, R0
  0x800'2728: 0xf040 0x810e   BNE.W    ??_tx_timer_thread_entry_1
                                                              ; 0x800'2948
                ??_tx_timer_thread_entry_2:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'272c: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'2730: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2732: 0xf8df 0x9220   LDR.W    R9, [PC, #0x220]       ; _tx_timer_current_ptr
  0x800'2736: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'273a: 0x6800          LDR      R0, [R0]
  0x800'273c: 0x9000          STR      R0, [SP]
  //             if (expired_timers != TX_NULL)
  0x800'273e: 0x9800          LDR      R0, [SP]
  0x800'2740: 0x2800          CMP      R0, #0
  0x800'2742: 0xd002          BEQ.N    ??_tx_timer_thread_entry_3
                                                              ; 0x800'274a
  //                 expired_timers -> tx_timer_internal_list_head =  &expired_timers;
  0x800'2744: 0x466a          MOV      R2, SP
  0x800'2746: 0x9800          LDR      R0, [SP]
  0x800'2748: 0x6182          STR      R2, [R0, #0x18]
                ??_tx_timer_thread_entry_3:
  //             *_tx_timer_current_ptr =  TX_NULL;
  0x800'274a: 0x2200          MOVS     R2, #0
  0x800'274c: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'2750: 0x6002          STR      R2, [R0]
  //             _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
  0x800'2752: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'2756: 0x1d00          ADDS     R0, R0, #4
  0x800'2758: 0xf8c9 0x0000   STR.W    R0, [R9]
  //             if (_tx_timer_current_ptr == _tx_timer_list_end)
  0x800'275c: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'2760: 0x4a7d          LDR.N    R2, [PC, #0x1f4]       ; _tx_timer_list_end
  0x800'2762: 0x6812          LDR      R2, [R2]
  0x800'2764: 0x4290          CMP      R0, R2
  0x800'2766: 0xd103          BNE.N    ??_tx_timer_thread_entry_4
                                                              ; 0x800'2770
  //                 _tx_timer_current_ptr =  _tx_timer_list_start;
  0x800'2768: 0x487c          LDR.N    R0, [PC, #0x1f0]       ; _tx_timer_list_start
  0x800'276a: 0x6800          LDR      R0, [R0]
  0x800'276c: 0xf8c9 0x0000   STR.W    R0, [R9]
                ??_tx_timer_thread_entry_4:
  //             _tx_timer_expired =  TX_FALSE;
  0x800'2770: 0x2200          MOVS     R2, #0
  0x800'2772: 0x487b          LDR.N    R0, [PC, #0x1ec]       ; _tx_timer_expired
  0x800'2774: 0x6002          STR      R2, [R0]
  //             TX_RESTORE
  0x800'2776: 0x0008          MOVS     R0, R1
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2778: 0xf380 0x8810   MSR      PRIMASK, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'277c: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'2780: 0xb672          CPSID    i
                ??_tx_timer_thread_entry_5:
  //     return(int_posture);
  0x800'2782: 0x9800          LDR      R0, [SP]
  0x800'2784: 0x2800          CMP      R0, #0
  0x800'2786: 0xf000 0x80ca   BEQ.W    ??_tx_timer_thread_entry_6
                                                              ; 0x800'291e
  //                 current_timer =  expired_timers;
  0x800'278a: 0x9800          LDR      R0, [SP]
  0x800'278c: 0x0007          MOVS     R7, R0
  //                 next_timer =  expired_timers -> tx_timer_internal_active_next;
  0x800'278e: 0x9800          LDR      R0, [SP]
  0x800'2790: 0x6900          LDR      R0, [R0, #0x10]
  0x800'2792: 0x0006          MOVS     R6, R0
  //                 reactivate_timer =  TX_NULL;
  0x800'2794: 0x2000          MOVS     R0, #0
  0x800'2796: 0x9002          STR      R0, [SP, #0x8]
  //                 if (current_timer == next_timer)
  0x800'2798: 0x42b7          CMP      R7, R6
  0x800'279a: 0xd102          BNE.N    ??_tx_timer_thread_entry_7
                                                              ; 0x800'27a2
  //                     expired_timers =  TX_NULL;
  0x800'279c: 0x2000          MOVS     R0, #0
  0x800'279e: 0x9000          STR      R0, [SP]
  0x800'27a0: 0xe008          B.N      ??_tx_timer_thread_entry_8
                                                              ; 0x800'27b4
                ??_tx_timer_thread_entry_7:
  //                     previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
  0x800'27a2: 0x6978          LDR      R0, [R7, #0x14]
  0x800'27a4: 0x9001          STR      R0, [SP, #0x4]
  //                     next_timer -> tx_timer_internal_active_previous =  previous_timer;
  0x800'27a6: 0x9801          LDR      R0, [SP, #0x4]
  0x800'27a8: 0x6170          STR      R0, [R6, #0x14]
  //                     previous_timer -> tx_timer_internal_active_next =  next_timer;
  0x800'27aa: 0x9801          LDR      R0, [SP, #0x4]
  0x800'27ac: 0x6106          STR      R6, [R0, #0x10]
  //                     next_timer -> tx_timer_internal_list_head =  &expired_timers;
  0x800'27ae: 0x4668          MOV      R0, SP
  0x800'27b0: 0x61b0          STR      R0, [R6, #0x18]
  //                     expired_timers =  next_timer;
  0x800'27b2: 0x9600          STR      R6, [SP]
                ??_tx_timer_thread_entry_8:
  //                 if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
  0x800'27b4: 0x6838          LDR      R0, [R7]
  0x800'27b6: 0x2821          CMP      R0, #33                ; 0x21
  0x800'27b8: 0xd320          BCC.N    ??_tx_timer_thread_entry_9
                                                              ; 0x800'27fc
  //                     _tx_timer_performance__expiration_adjust_count++;
  0x800'27ba: 0x496a          LDR.N    R1, [PC, #0x1a8]       ; _tx_timer_performance__expiration_adjust_count
  0x800'27bc: 0x6808          LDR      R0, [R1]
  0x800'27be: 0x1c40          ADDS     R0, R0, #1
  0x800'27c0: 0x6008          STR      R0, [R1]
  //                     if (current_timer -> tx_timer_internal_timeout_function != &_tx_thread_timeout)
  0x800'27c2: 0x68b9          LDR      R1, [R7, #0x8]
  0x800'27c4: 0x4868          LDR.N    R0, [PC, #0x1a0]       ; _tx_thread_timeout
  0x800'27c6: 0x4281          CMP      R1, R0
  0x800'27c8: 0xd00e          BEQ.N    ??_tx_timer_thread_entry_10
                                                              ; 0x800'27e8
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'27ca: 0x003a          MOVS     R2, R7
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'27cc: 0x0010          MOVS     R0, R2
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'27ce: 0xf110 0x0108   ADDS.W   R1, R0, #8
  0x800'27d2: 0x1a09          SUBS     R1, R1, R0
  0x800'27d4: 0x4249          RSBS     R1, R1, #0
  0x800'27d6: 0x4411          ADD      R1, R1, R2
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'27d8: 0x000c          MOVS     R4, R1
  //                         if (timer_ptr -> tx_timer_id == TX_TIMER_ID)
  0x800'27da: 0x6822          LDR      R2, [R4]
  0x800'27dc: 0x495c          LDR.N    R1, ??_tx_timer_thread_entry_0
                                                              ; 0x4154'494d
  0x800'27de: 0x428a          CMP      R2, R1
  0x800'27e0: 0xd102          BNE.N    ??_tx_timer_thread_entry_10
                                                              ; 0x800'27e8
  //                             timer_ptr -> tx_timer_performance__expiration_adjust_count++;
  0x800'27e2: 0x6be0          LDR      R0, [R4, #0x3c]
  0x800'27e4: 0x1c40          ADDS     R0, R0, #1
  0x800'27e6: 0x63e0          STR      R0, [R4, #0x3c]
                ??_tx_timer_thread_entry_10:
  //                     current_timer -> tx_timer_internal_remaining_ticks =
  //                             current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
  0x800'27e8: 0x6838          LDR      R0, [R7]
  0x800'27ea: 0x3820          SUBS     R0, R0, #32            ; 0x20
  0x800'27ec: 0x6038          STR      R0, [R7]
  //                     timeout_function =  TX_NULL;
  0x800'27ee: 0x2000          MOVS     R0, #0
  0x800'27f0: 0x4680          MOV      R8, R0
  //                     current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
  0x800'27f2: 0xa802          ADD      R0, SP, #0x8
  0x800'27f4: 0x61b8          STR      R0, [R7, #0x18]
  //                     current_timer -> tx_timer_internal_active_next =  current_timer;
  0x800'27f6: 0x613f          STR      R7, [R7, #0x10]
  //                     reactivate_timer =  current_timer;
  0x800'27f8: 0x9702          STR      R7, [SP, #0x8]
  0x800'27fa: 0xe026          B.N      ??_tx_timer_thread_entry_11
                                                              ; 0x800'284a
                ??_tx_timer_thread_entry_9:
  //                     _tx_timer_performance_expiration_count++;
  0x800'27fc: 0x495b          LDR.N    R1, [PC, #0x16c]       ; _tx_timer_performance_expiration_count
  0x800'27fe: 0x6808          LDR      R0, [R1]
  0x800'2800: 0x1c40          ADDS     R0, R0, #1
  0x800'2802: 0x6008          STR      R0, [R1]
  //                     if (current_timer -> tx_timer_internal_timeout_function != &_tx_thread_timeout)
  0x800'2804: 0x68b9          LDR      R1, [R7, #0x8]
  0x800'2806: 0x4858          LDR.N    R0, [PC, #0x160]       ; _tx_thread_timeout
  0x800'2808: 0x4281          CMP      R1, R0
  0x800'280a: 0xd00e          BEQ.N    ??_tx_timer_thread_entry_12
                                                              ; 0x800'282a
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'280c: 0x003a          MOVS     R2, R7
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'280e: 0x0010          MOVS     R0, R2
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'2810: 0xf110 0x0108   ADDS.W   R1, R0, #8
  0x800'2814: 0x1a09          SUBS     R1, R1, R0
  0x800'2816: 0x4249          RSBS     R1, R1, #0
  0x800'2818: 0x4411          ADD      R1, R1, R2
  //                         TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'281a: 0x000c          MOVS     R4, R1
  //                         if (timer_ptr -> tx_timer_id == TX_TIMER_ID)
  0x800'281c: 0x6822          LDR      R2, [R4]
  0x800'281e: 0x494c          LDR.N    R1, ??_tx_timer_thread_entry_0
                                                              ; 0x4154'494d
  0x800'2820: 0x428a          CMP      R2, R1
  0x800'2822: 0xd102          BNE.N    ??_tx_timer_thread_entry_12
                                                              ; 0x800'282a
  //                             timer_ptr -> tx_timer_performance_expiration_count++;
  0x800'2824: 0x6ba0          LDR      R0, [R4, #0x38]
  0x800'2826: 0x1c40          ADDS     R0, R0, #1
  0x800'2828: 0x63a0          STR      R0, [R4, #0x38]
                ??_tx_timer_thread_entry_12:
  //                     timeout_function =  current_timer -> tx_timer_internal_timeout_function;
  0x800'282a: 0x68b8          LDR      R0, [R7, #0x8]
  0x800'282c: 0x4680          MOV      R8, R0
  //                     timeout_param =     current_timer -> tx_timer_internal_timeout_param;
  0x800'282e: 0x68f8          LDR      R0, [R7, #0xc]
  0x800'2830: 0x9006          STR      R0, [SP, #0x18]
  //                     current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
  0x800'2832: 0x6878          LDR      R0, [R7, #0x4]
  0x800'2834: 0x6038          STR      R0, [R7]
  //                     if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
  0x800'2836: 0x6838          LDR      R0, [R7]
  0x800'2838: 0x2800          CMP      R0, #0
  0x800'283a: 0xd004          BEQ.N    ??_tx_timer_thread_entry_13
                                                              ; 0x800'2846
  //                         current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
  0x800'283c: 0xa802          ADD      R0, SP, #0x8
  0x800'283e: 0x61b8          STR      R0, [R7, #0x18]
  //                         current_timer -> tx_timer_internal_active_next =  current_timer;
  0x800'2840: 0x613f          STR      R7, [R7, #0x10]
  //                         reactivate_timer =  current_timer;
  0x800'2842: 0x9702          STR      R7, [SP, #0x8]
  0x800'2844: 0xe001          B.N      ??_tx_timer_thread_entry_11
                                                              ; 0x800'284a
                ??_tx_timer_thread_entry_13:
  //                         current_timer -> tx_timer_internal_list_head =  TX_NULL;
  0x800'2846: 0x2000          MOVS     R0, #0
  0x800'2848: 0x61b8          STR      R0, [R7, #0x18]
                ??_tx_timer_thread_entry_11:
  //                 _tx_timer_expired_timer_ptr =  current_timer;
  0x800'284a: 0xf8df 0xb124   LDR.W    R11, [PC, #0x124]      ; _tx_timer_expired_timer_ptr
  0x800'284e: 0xf8cb 0x7000   STR.W    R7, [R11]
  //                 TX_RESTORE
  0x800'2852: 0x0029          MOVS     R1, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2854: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2858: 0x4640          MOV      R0, R8
  0x800'285a: 0x2800          CMP      R0, #0
  0x800'285c: 0xd001          BEQ.N    ??_tx_timer_thread_entry_14
                                                              ; 0x800'2862
  //                     (timeout_function) (timeout_param);
  0x800'285e: 0x9806          LDR      R0, [SP, #0x18]
  0x800'2860: 0x47c0          BLX      R8
                ??_tx_timer_thread_entry_14:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2862: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'2866: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2868: 0x2000          MOVS     R0, #0
  0x800'286a: 0xf8cb 0x0000   STR.W    R0, [R11]
  //                 if (reactivate_timer == current_timer)
  0x800'286e: 0x9802          LDR      R0, [SP, #0x8]
  0x800'2870: 0x42b8          CMP      R0, R7
  0x800'2872: 0xd14d          BNE.N    ??_tx_timer_thread_entry_15
                                                              ; 0x800'2910
  //                     if (timeout_function != TX_NULL)
  0x800'2874: 0x4640          MOV      R0, R8
  0x800'2876: 0x2800          CMP      R0, #0
  0x800'2878: 0xd016          BEQ.N    ??_tx_timer_thread_entry_16
                                                              ; 0x800'28a8
  //                         _tx_timer_performance_reactivate_count++;
  0x800'287a: 0x483e          LDR.N    R0, [PC, #0xf8]        ; _tx_timer_performance_reactivate_count
  0x800'287c: 0x6802          LDR      R2, [R0]
  0x800'287e: 0x1c52          ADDS     R2, R2, #1
  0x800'2880: 0x6002          STR      R2, [R0]
  //                         if (current_timer -> tx_timer_internal_timeout_function != &_tx_thread_timeout)
  0x800'2882: 0x68ba          LDR      R2, [R7, #0x8]
  0x800'2884: 0x4838          LDR.N    R0, [PC, #0xe0]        ; _tx_thread_timeout
  0x800'2886: 0x4282          CMP      R2, R0
  0x800'2888: 0xd00e          BEQ.N    ??_tx_timer_thread_entry_16
                                                              ; 0x800'28a8
  //                             TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'288a: 0x003b          MOVS     R3, R7
  //                             TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'288c: 0x0018          MOVS     R0, R3
  //                             TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'288e: 0xf110 0x0208   ADDS.W   R2, R0, #8
  0x800'2892: 0x1a12          SUBS     R2, R2, R0
  0x800'2894: 0x4252          RSBS     R2, R2, #0
  0x800'2896: 0x441a          ADD      R2, R2, R3
  //                             TX_USER_TIMER_POINTER_GET(current_timer, timer_ptr)
  0x800'2898: 0x0014          MOVS     R4, R2
  //                             if (timer_ptr -> tx_timer_id == TX_TIMER_ID)
  0x800'289a: 0x6823          LDR      R3, [R4]
  0x800'289c: 0x4a2c          LDR.N    R2, ??_tx_timer_thread_entry_0
                                                              ; 0x4154'494d
  0x800'289e: 0x4293          CMP      R3, R2
  0x800'28a0: 0xd102          BNE.N    ??_tx_timer_thread_entry_16
                                                              ; 0x800'28a8
  //                                 timer_ptr -> tx_timer_performance_reactivate_count++;
  0x800'28a2: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'28a4: 0x1c40          ADDS     R0, R0, #1
  0x800'28a6: 0x6320          STR      R0, [R4, #0x30]
                ??_tx_timer_thread_entry_16:
  //                     if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
  0x800'28a8: 0x6838          LDR      R0, [R7]
  0x800'28aa: 0x2821          CMP      R0, #33                ; 0x21
  0x800'28ac: 0xd302          BCC.N    ??_tx_timer_thread_entry_17
                                                              ; 0x800'28b4
  //                         expiration_time =  TX_TIMER_ENTRIES - ((UINT) 1);
  0x800'28ae: 0x201f          MOVS     R0, #31                ; 0x1f
  0x800'28b0: 0x9003          STR      R0, [SP, #0xc]
  0x800'28b2: 0xe002          B.N      ??_tx_timer_thread_entry_18
                                                              ; 0x800'28ba
                ??_tx_timer_thread_entry_17:
  //                         expiration_time =  ((UINT) current_timer -> tx_timer_internal_remaining_ticks) - ((UINT) 1);
  0x800'28b4: 0x6838          LDR      R0, [R7]
  0x800'28b6: 0x1e40          SUBS     R0, R0, #1
  0x800'28b8: 0x9003          STR      R0, [SP, #0xc]
                ??_tx_timer_thread_entry_18:
  //                     timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
  0x800'28ba: 0xf8d9 0x2000   LDR.W    R2, [R9]
  0x800'28be: 0x9803          LDR      R0, [SP, #0xc]
  0x800'28c0: 0xeb02 0x0080   ADD.W    R0, R2, R0, LSL #2
  0x800'28c4: 0x4682          MOV      R10, R0
  //                     if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
  0x800'28c6: 0x4a24          LDR.N    R2, [PC, #0x90]        ; _tx_timer_list_end
  0x800'28c8: 0x6810          LDR      R0, [R2]
  0x800'28ca: 0x4582          CMP      R10, R0
  0x800'28cc: 0xd30a          BCC.N    ??_tx_timer_thread_entry_19
                                                              ; 0x800'28e4
  //                         delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
  0x800'28ce: 0x6810          LDR      R0, [R2]
  0x800'28d0: 0xebba 0x0000   SUBS.W   R0, R10, R0
  0x800'28d4: 0x1080          ASRS     R0, R0, #2
  0x800'28d6: 0x9005          STR      R0, [SP, #0x14]
  //                         timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
  0x800'28d8: 0x4820          LDR.N    R0, [PC, #0x80]        ; _tx_timer_list_start
  0x800'28da: 0x6802          LDR      R2, [R0]
  0x800'28dc: 0x9805          LDR      R0, [SP, #0x14]
  0x800'28de: 0xeb02 0x0080   ADD.W    R0, R2, R0, LSL #2
  0x800'28e2: 0x4682          MOV      R10, R0
                ??_tx_timer_thread_entry_19:
  //                     if ((*timer_list) == TX_NULL)
  0x800'28e4: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'28e8: 0x2800          CMP      R0, #0
  0x800'28ea: 0xd104          BNE.N    ??_tx_timer_thread_entry_20
                                                              ; 0x800'28f6
  //                         current_timer -> tx_timer_internal_active_next =      current_timer;
  0x800'28ec: 0x613f          STR      R7, [R7, #0x10]
  //                         current_timer -> tx_timer_internal_active_previous =  current_timer;
  0x800'28ee: 0x617f          STR      R7, [R7, #0x14]
  //                         *timer_list =  current_timer;
  0x800'28f0: 0xf8ca 0x7000   STR.W    R7, [R10]
  0x800'28f4: 0xe00a          B.N      ??_tx_timer_thread_entry_21
                                                              ; 0x800'290c
                ??_tx_timer_thread_entry_20:
  //                         next_timer =                                          *timer_list;
  0x800'28f6: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'28fa: 0x0006          MOVS     R6, R0
  //                         previous_timer =                                      next_timer -> tx_timer_internal_active_previous;
  0x800'28fc: 0x6970          LDR      R0, [R6, #0x14]
  0x800'28fe: 0x9001          STR      R0, [SP, #0x4]
  //                         previous_timer -> tx_timer_internal_active_next =     current_timer;
  0x800'2900: 0x9801          LDR      R0, [SP, #0x4]
  0x800'2902: 0x6107          STR      R7, [R0, #0x10]
  //                         next_timer -> tx_timer_internal_active_previous =     current_timer;
  0x800'2904: 0x6177          STR      R7, [R6, #0x14]
  //                         current_timer -> tx_timer_internal_active_next =      next_timer;
  0x800'2906: 0x613e          STR      R6, [R7, #0x10]
  //                         current_timer -> tx_timer_internal_active_previous =  previous_timer;
  0x800'2908: 0x9801          LDR      R0, [SP, #0x4]
  0x800'290a: 0x6178          STR      R0, [R7, #0x14]
                ??_tx_timer_thread_entry_21:
  //                     current_timer -> tx_timer_internal_list_head =  timer_list;
  0x800'290c: 0xf8c7 0xa018   STR.W    R10, [R7, #0x18]
                ??_tx_timer_thread_entry_15:
  //                 TX_RESTORE
  0x800'2910: 0x0008          MOVS     R0, R1
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2912: 0xf380 0x8810   MSR      PRIMASK, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2916: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'291a: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'291c: 0xe731          B.N      ??_tx_timer_thread_entry_5
                                                              ; 0x800'2782
                ??_tx_timer_thread_entry_6:
  //             if (_tx_timer_expired == TX_FALSE)
  0x800'291e: 0x4810          LDR.N    R0, [PC, #0x40]        ; _tx_timer_expired
  0x800'2920: 0x6800          LDR      R0, [R0]
  0x800'2922: 0x2800          CMP      R0, #0
  0x800'2924: 0xd10c          BNE.N    ??_tx_timer_thread_entry_22
                                                              ; 0x800'2940
  //                 thread_ptr =  &_tx_timer_thread;
  0x800'2926: 0x4814          LDR.N    R0, [PC, #0x50]        ; _tx_timer_thread
  0x800'2928: 0x9004          STR      R0, [SP, #0x10]
  //                 thread_ptr -> tx_thread_state =  TX_SUSPENDED;
  0x800'292a: 0x2103          MOVS     R1, #3
  0x800'292c: 0x9804          LDR      R0, [SP, #0x10]
  0x800'292e: 0x6301          STR      R1, [R0, #0x30]
  //                 _tx_thread_system_ni_suspend(thread_ptr, ((ULONG) 0));
  0x800'2930: 0x2100          MOVS     R1, #0
  0x800'2932: 0x9804          LDR      R0, [SP, #0x10]
  0x800'2934: 0xf7ff 0xfd22   BL       _tx_thread_system_ni_suspend
                                                              ; 0x800'237c
  //                 TX_RESTORE
  0x800'2938: 0x0028          MOVS     R0, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'293a: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'293e: 0xe6f5          B.N      ??_tx_timer_thread_entry_2
                                                              ; 0x800'272c
                ??_tx_timer_thread_entry_22:
  //                 TX_RESTORE
  0x800'2940: 0x0028          MOVS     R0, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2942: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'2946: 0xe6f1          B.N      ??_tx_timer_thread_entry_2
                                                              ; 0x800'272c
                ??_tx_timer_thread_entry_1:
  // }
  0x800'2948: 0xb009          ADD      SP, SP, #0x24
  0x800'294a: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'294e: 0xbf00          NOP
                `$d.32`:
                ??_tx_timer_thread_entry_0:
  0x800'2950: 0x4154'494d     DC32     0x4154'494d            ; 'MITA'
  0x800'2954: 0x2000'24b0     DC32     _tx_timer_current_ptr
  0x800'2958: 0x2000'24ac     DC32     _tx_timer_list_end
  0x800'295c: 0x2000'24a8     DC32     _tx_timer_list_start
  0x800'2960: 0x2000'24b4     DC32     _tx_timer_expired
  0x800'2964: 0x2000'24d0     DC32     _tx_timer_performance__expiration_adjust_count
  0x800'2968: 0x0800'3cf5     DC32     _tx_thread_timeout
  0x800'296c: 0x2000'24cc     DC32     _tx_timer_performance_expiration_count
  0x800'2970: 0x2000'24b8     DC32     _tx_timer_expired_timer_ptr
  0x800'2974: 0x2000'24c8     DC32     _tx_timer_performance_reactivate_count
  0x800'2978: 0x2000'20f0     DC32     _tx_timer_thread
                $t:
                `.text8`:
                _tx_thread_create:
  // UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
  //                             VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
  //                             ULONG time_slice, UINT auto_start)
  // {
  0x800'297c: 0xe92d 0x4ffe   PUSH.W   {R1-R11, LR}
  0x800'2980: 0xb086          SUB      SP, SP, #0x18
  0x800'2982: 0x4683          MOV      R11, R0
  0x800'2984: 0xf8dd 0xa048   LDR.W    R10, [SP, #0x48]
  0x800'2988: 0x9f13          LDR      R7, [SP, #0x4c]
  0x800'298a: 0x9c14          LDR      R4, [SP, #0x50]
  0x800'298c: 0x9d16          LDR      R5, [SP, #0x58]
  // UINT                    saved_threshold =  ((UINT) 0);
  0x800'298e: 0x2600          MOVS     R6, #0
  //     thread_ptr -> tx_thread_stack_fill_value = ((ULONG) TX_RAND()) & 0xFFUL;
  0x800'2990: 0xf000 0xf8da   BL       rand                   ; 0x800'2b48
  0x800'2994: 0xf000 0x00ff   AND.W    R0, R0, #255           ; 0xff
  0x800'2998: 0xf8cb 0x00d4   STR.W    R0, [R11, #0xd4]
  //     thread_ptr -> tx_thread_stack_fill_value = thread_ptr -> tx_thread_stack_fill_value |
  //                     (thread_ptr -> tx_thread_stack_fill_value << 8) |
  //                     (thread_ptr -> tx_thread_stack_fill_value << 16) |
  //                     (thread_ptr -> tx_thread_stack_fill_value << 24);
  0x800'299c: 0xf8db 0x00d4   LDR.W    R0, [R11, #0xd4]
  0x800'29a0: 0xf8db 0x10d4   LDR.W    R1, [R11, #0xd4]
  0x800'29a4: 0xea50 0x2001   ORRS.W   R0, R0, R1, LSL #8
  0x800'29a8: 0xf8db 0x10d4   LDR.W    R1, [R11, #0xd4]
  0x800'29ac: 0xea50 0x4001   ORRS.W   R0, R0, R1, LSL #16
  0x800'29b0: 0xf8db 0x10d4   LDR.W    R1, [R11, #0xd4]
  0x800'29b4: 0xea50 0x6001   ORRS.W   R0, R0, R1, LSL #24
  0x800'29b8: 0xf8cb 0x00d4   STR.W    R0, [R11, #0xd4]
  //     TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
  0x800'29bc: 0x9704          STR      R7, [SP, #0x10]
  0x800'29be: 0xf89b 0x90d4   LDRB.W   R9, [R11, #0xd4]
  0x800'29c2: 0x46d0          MOV      R8, R10
  //     __aeabi_memset(_D, _N, _C);
  0x800'29c4: 0x464a          MOV      R2, R9
  0x800'29c6: 0x9904          LDR      R1, [SP, #0x10]
  0x800'29c8: 0x4640          MOV      R0, R8
  0x800'29ca: 0xf7fe 0xfec7   BL       __aeabi_memset         ; 0x800'175c
  //     return _D;
  0x800'29ce: 0x08bf          LSRS     R7, R7, #2
  0x800'29d0: 0xea5f 0x0887   LSLS.W   R8, R7, #2
  0x800'29d4: 0xf1b8 0x0804   SUBS.W   R8, R8, #4
  //     new_stack_start =  TX_POINTER_TO_ALIGN_TYPE_CONVERT(stack_start);
  0x800'29d8: 0xf8cd 0xa00c   STR.W    R10, [SP, #0xc]
  //     updated_stack_start =  (((new_stack_start) + ((sizeof(ULONG)) - ((ULONG) 1)) ) & (~((sizeof(ULONG)) - ((ULONG) 1))));
  0x800'29dc: 0x9f03          LDR      R7, [SP, #0xc]
  0x800'29de: 0x1cff          ADDS     R7, R7, #3
  0x800'29e0: 0x08bf          LSRS     R7, R7, #2
  0x800'29e2: 0x00bf          LSLS     R7, R7, #2
  //     if (new_stack_start != updated_stack_start)
  0x800'29e4: 0x9803          LDR      R0, [SP, #0xc]
  0x800'29e6: 0x42b8          CMP      R0, R7
  0x800'29e8: 0xd001          BEQ.N    ??_tx_thread_create_1  ; 0x800'29ee
  //         stack_size =  stack_size - (sizeof(ULONG));
  0x800'29ea: 0xf1b8 0x0804   SUBS.W   R8, R8, #4
                ??_tx_thread_create_1:
  //     stack_start =  TX_ALIGN_TYPE_TO_POINTER_CONVERT(updated_stack_start);
  0x800'29ee: 0x9712          STR      R7, [SP, #0x48]
  //     TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
  0x800'29f0: 0x20d8          MOVS     R0, #216               ; 0xd8
  0x800'29f2: 0x9005          STR      R0, [SP, #0x14]
  0x800'29f4: 0x2000          MOVS     R0, #0
  0x800'29f6: 0x9004          STR      R0, [SP, #0x10]
  0x800'29f8: 0x46d9          MOV      R9, R11
  //     __aeabi_memset(_D, _N, _C);
  0x800'29fa: 0x9a04          LDR      R2, [SP, #0x10]
  0x800'29fc: 0x9905          LDR      R1, [SP, #0x14]
  0x800'29fe: 0x4648          MOV      R0, R9
  0x800'2a00: 0xf7fe 0xfeac   BL       __aeabi_memset         ; 0x800'175c
  //     return _D;
  0x800'2a04: 0x9806          LDR      R0, [SP, #0x18]
  0x800'2a06: 0xf8cb 0x0028   STR.W    R0, [R11, #0x28]
  //     thread_ptr -> tx_thread_entry =             entry_function;
  0x800'2a0a: 0x9807          LDR      R0, [SP, #0x1c]
  0x800'2a0c: 0xf8cb 0x0044   STR.W    R0, [R11, #0x44]
  //     thread_ptr -> tx_thread_entry_parameter =   entry_input;
  0x800'2a10: 0x9808          LDR      R0, [SP, #0x20]
  0x800'2a12: 0xf8cb 0x0048   STR.W    R0, [R11, #0x48]
  //     thread_ptr -> tx_thread_stack_start =       stack_start;
  0x800'2a16: 0x9812          LDR      R0, [SP, #0x48]
  0x800'2a18: 0xf8cb 0x000c   STR.W    R0, [R11, #0xc]
  //     thread_ptr -> tx_thread_stack_size =        stack_size;
  0x800'2a1c: 0xf8cb 0x8014   STR.W    R8, [R11, #0x14]
  //     thread_ptr -> tx_thread_priority =          priority;
  0x800'2a20: 0xf8cb 0x402c   STR.W    R4, [R11, #0x2c]
  //     thread_ptr -> tx_thread_user_priority =     priority;
  0x800'2a24: 0xf8cb 0x4090   STR.W    R4, [R11, #0x90]
  //     thread_ptr -> tx_thread_time_slice =        time_slice;
  0x800'2a28: 0xf8cb 0x5018   STR.W    R5, [R11, #0x18]
  //     thread_ptr -> tx_thread_new_time_slice =    time_slice;
  0x800'2a2c: 0xf8cb 0x501c   STR.W    R5, [R11, #0x1c]
  //     thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
  0x800'2a30: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'2a32: 0xf8cb 0x0098   STR.W    R0, [R11, #0x98]
  //     temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
  0x800'2a36: 0x9812          LDR      R0, [SP, #0x48]
  //     temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
  0x800'2a38: 0x4440          ADD      R0, R0, R8
  0x800'2a3a: 0xf1b0 0x0901   SUBS.W   R9, R0, #1
  //     thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
  0x800'2a3e: 0xf8cb 0x9010   STR.W    R9, [R11, #0x10]
  //     if (priority != preempt_threshold)
  0x800'2a42: 0x9815          LDR      R0, [SP, #0x54]
  0x800'2a44: 0x4284          CMP      R4, R0
  0x800'2a46: 0xd006          BEQ.N    ??_tx_thread_create_2  ; 0x800'2a56
  //         thread_ptr -> tx_thread_preempt_threshold =       ((UINT) 0);
  0x800'2a48: 0x2000          MOVS     R0, #0
  0x800'2a4a: 0xf8cb 0x003c   STR.W    R0, [R11, #0x3c]
  //         thread_ptr -> tx_thread_user_preempt_threshold =  ((UINT) 0);
  0x800'2a4e: 0x2000          MOVS     R0, #0
  0x800'2a50: 0xf8cb 0x0094   STR.W    R0, [R11, #0x94]
  0x800'2a54: 0xe003          B.N      ??_tx_thread_create_3  ; 0x800'2a5e
                ??_tx_thread_create_2:
  //         thread_ptr -> tx_thread_preempt_threshold =       priority;
  0x800'2a56: 0xf8cb 0x403c   STR.W    R4, [R11, #0x3c]
  //         thread_ptr -> tx_thread_user_preempt_threshold =  priority;
  0x800'2a5a: 0xf8cb 0x4094   STR.W    R4, [R11, #0x94]
                ??_tx_thread_create_3:
  //     thread_ptr -> tx_thread_state =  TX_SUSPENDED;
  0x800'2a5e: 0x2003          MOVS     R0, #3
  0x800'2a60: 0xf8cb 0x0030   STR.W    R0, [R11, #0x30]
  //     TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
  0x800'2a64: 0x4831          LDR.N    R0, ??_tx_thread_create_0
                                                              ; _tx_thread_timeout
  0x800'2a66: 0xf8cb 0x0054   STR.W    R0, [R11, #0x54]
  //     TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
  0x800'2a6a: 0xf8cb 0xb058   STR.W    R11, [R11, #0x58]
  //     _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
  0x800'2a6e: 0x4930          LDR.N    R1, [PC, #0xc0]        ; _tx_thread_shell_entry
  0x800'2a70: 0x4658          MOV      R0, R11
  0x800'2a72: 0xf000 0xf8b5   BL       _tx_thread_stack_build ; 0x800'2be0
  //     thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
  0x800'2a76: 0xf8db 0x0008   LDR.W    R0, [R11, #0x8]
  0x800'2a7a: 0xf8cb 0x00cc   STR.W    R0, [R11, #0xcc]
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2a7e: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'2a82: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2a84: 0x482b          LDR.N    R0, [PC, #0xac]        ; 0x5448'5244
  0x800'2a86: 0xf8cb 0x0000   STR.W    R0, [R11]
  //     if (_tx_thread_created_count == TX_EMPTY)
  0x800'2a8a: 0x492b          LDR.N    R1, [PC, #0xac]        ; _tx_thread_created_count
  0x800'2a8c: 0x6808          LDR      R0, [R1]
  0x800'2a8e: 0x2800          CMP      R0, #0
  0x800'2a90: 0xd107          BNE.N    ??_tx_thread_create_4  ; 0x800'2aa2
  //         _tx_thread_created_ptr =                    thread_ptr;
  0x800'2a92: 0x482a          LDR.N    R0, [PC, #0xa8]        ; _tx_thread_created_ptr
  0x800'2a94: 0xf8c0 0xb000   STR.W    R11, [R0]
  //         thread_ptr -> tx_thread_created_next =      thread_ptr;
  0x800'2a98: 0xf8cb 0xb088   STR.W    R11, [R11, #0x88]
  //         thread_ptr -> tx_thread_created_previous =  thread_ptr;
  0x800'2a9c: 0xf8cb 0xb08c   STR.W    R11, [R11, #0x8c]
  0x800'2aa0: 0xe012          B.N      ??_tx_thread_create_5  ; 0x800'2ac8
                ??_tx_thread_create_4:
  //         next_thread =  _tx_thread_created_ptr;
  0x800'2aa2: 0x4826          LDR.N    R0, [PC, #0x98]        ; _tx_thread_created_ptr
  0x800'2aa4: 0x6800          LDR      R0, [R0]
  0x800'2aa6: 0x9001          STR      R0, [SP, #0x4]
  //         previous_thread =  next_thread -> tx_thread_created_previous;
  0x800'2aa8: 0x9801          LDR      R0, [SP, #0x4]
  0x800'2aaa: 0xf8d0 0x008c   LDR.W    R0, [R0, #0x8c]
  0x800'2aae: 0x9002          STR      R0, [SP, #0x8]
  //         next_thread -> tx_thread_created_previous =  thread_ptr;
  0x800'2ab0: 0x9801          LDR      R0, [SP, #0x4]
  0x800'2ab2: 0xf8c0 0xb08c   STR.W    R11, [R0, #0x8c]
  //         previous_thread -> tx_thread_created_next =  thread_ptr;
  0x800'2ab6: 0x9802          LDR      R0, [SP, #0x8]
  0x800'2ab8: 0xf8c0 0xb088   STR.W    R11, [R0, #0x88]
  //         thread_ptr -> tx_thread_created_previous =  previous_thread;
  0x800'2abc: 0x9802          LDR      R0, [SP, #0x8]
  0x800'2abe: 0xf8cb 0x008c   STR.W    R0, [R11, #0x8c]
  //         thread_ptr -> tx_thread_created_next =      next_thread;
  0x800'2ac2: 0x9801          LDR      R0, [SP, #0x4]
  0x800'2ac4: 0xf8cb 0x0088   STR.W    R0, [R11, #0x88]
                ??_tx_thread_create_5:
  //     _tx_thread_created_count++;
  0x800'2ac8: 0x6808          LDR      R0, [R1]
  0x800'2aca: 0x1c40          ADDS     R0, R0, #1
  0x800'2acc: 0x6008          STR      R0, [R1]
  //     if (auto_start == TX_AUTO_START)
  0x800'2ace: 0x9817          LDR      R0, [SP, #0x5c]
  0x800'2ad0: 0x2801          CMP      R0, #1
  0x800'2ad2: 0xd123          BNE.N    ??_tx_thread_create_6  ; 0x800'2b1c
  //         if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
  0x800'2ad4: 0x481a          LDR.N    R0, [PC, #0x68]        ; _tx_thread_system_state
  0x800'2ad6: 0x6801          LDR      R1, [R0]
  0x800'2ad8: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'2adc: 0x4301          ORRS     R1, R1, R0
  0x800'2ade: 0xf1b1 0x3ff0   CMP.W    R1, #-252645136        ; 0xf0f0'f0f0
  0x800'2ae2: 0xd30d          BCC.N    ??_tx_thread_create_7  ; 0x800'2b00
  //             saved_thread_ptr =  _tx_thread_execute_ptr;
  0x800'2ae4: 0x4817          LDR.N    R0, [PC, #0x5c]        ; _tx_thread_execute_ptr
  0x800'2ae6: 0x6800          LDR      R0, [R0]
  0x800'2ae8: 0x9000          STR      R0, [SP]
  //             if (saved_thread_ptr != TX_NULL)
  0x800'2aea: 0x9800          LDR      R0, [SP]
  0x800'2aec: 0x2800          CMP      R0, #0
  0x800'2aee: 0xd009          BEQ.N    ??_tx_thread_create_8  ; 0x800'2b04
  //                 saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
  0x800'2af0: 0x9800          LDR      R0, [SP]
  0x800'2af2: 0x6bc0          LDR      R0, [R0, #0x3c]
  0x800'2af4: 0x0006          MOVS     R6, R0
  //                 saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
  0x800'2af6: 0x9800          LDR      R0, [SP]
  0x800'2af8: 0x6ac0          LDR      R0, [R0, #0x2c]
  0x800'2afa: 0x9900          LDR      R1, [SP]
  0x800'2afc: 0x63c8          STR      R0, [R1, #0x3c]
  0x800'2afe: 0xe001          B.N      ??_tx_thread_create_8  ; 0x800'2b04
                ??_tx_thread_create_7:
  //             saved_thread_ptr =  TX_NULL;
  0x800'2b00: 0x2000          MOVS     R0, #0
  0x800'2b02: 0x9000          STR      R0, [SP]
                ??_tx_thread_create_8:
  //         _tx_thread_system_ni_resume(thread_ptr);
  0x800'2b04: 0x4658          MOV      R0, R11
  0x800'2b06: 0xf7ff 0xfa01   BL       _tx_thread_system_ni_resume
                                                              ; 0x800'1f0c
  //         TX_RESTORE
  0x800'2b0a: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2b0c: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2b10: 0x9800          LDR      R0, [SP]
  0x800'2b12: 0x2800          CMP      R0, #0
  0x800'2b14: 0xd005          BEQ.N    ??_tx_thread_create_9  ; 0x800'2b22
  //             saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
  0x800'2b16: 0x9800          LDR      R0, [SP]
  0x800'2b18: 0x63c6          STR      R6, [R0, #0x3c]
  0x800'2b1a: 0xe002          B.N      ??_tx_thread_create_9  ; 0x800'2b22
                ??_tx_thread_create_6:
  //         TX_RESTORE
  0x800'2b1c: 0x4650          MOV      R0, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2b1e: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_create_9:
  // }
  0x800'2b22: 0x2000          MOVS     R0, #0
  0x800'2b24: 0xb009          ADD      SP, SP, #0x24
  0x800'2b26: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'2b2a: 0xbf00          NOP
                `$d.32`:
                ??_tx_thread_create_0:
  0x800'2b2c: 0x0800'3cf5     DC32     _tx_thread_timeout
  0x800'2b30: 0x0800'3d4d     DC32     _tx_thread_shell_entry
  0x800'2b34: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
  0x800'2b38: 0x2000'2460     DC32     _tx_thread_created_count
  0x800'2b3c: 0x2000'245c     DC32     _tx_thread_created_ptr
  0x800'2b40: 0x2000'0008     DC32     _tx_thread_system_state
  0x800'2b44: 0x2000'2458     DC32     _tx_thread_execute_ptr
                $t:
                `.text8`:
                rand:
  0x800'2b48: 0xb5f0          PUSH     {R4-R7, LR}
  0x800'2b4a: 0x4921          LDR.N    R1, ??DataTable1       ; _Rand_rv
  0x800'2b4c: 0x4a21          LDR.N    R2, ??DataTable1_1     ; _Randinit
  0x800'2b4e: 0xf8d1 0x7080   LDR.W    R7, [R1, #0x80]
  0x800'2b52: 0x6853          LDR      R3, [R2, #0x4]
  0x800'2b54: 0x7810          LDRB     R0, [R2]
  0x800'2b56: 0x4d20          LDR.N    R5, ??DataTable1_2     ; 0x3c6e'f35f
  0x800'2b58: 0x4e20          LDR.N    R6, ??DataTable1_3     ; 0x19'660d
  0x800'2b5a: 0xf06f 0x4400   MVN.W    R4, #-2147483648       ; 0x8000'0000
  0x800'2b5e: 0xbb18          CBNZ     R0, ??rand_0           ; 0x800'2ba8
  0x800'2b60: 0x2008          MOVS     R0, #8
                ??rand_1:
  0x800'2b62: 0xfb06 0x5303   MLA      R3, R6, R3, R5
  0x800'2b66: 0x4627          MOV      R7, R4
  0x800'2b68: 0xfbb3 0xf7f7   UDIV     R7, R3, R7
  0x800'2b6c: 0x1e40          SUBS     R0, R0, #1
  0x800'2b6e: 0xfb04 0x3317   MLS      R3, R4, R7, R3
  0x800'2b72: 0xd1f6          BNE.N    ??rand_1               ; 0x800'2b62
  0x800'2b74: 0x460f          MOV      R7, R1
  0x800'2b76: 0x2010          MOVS     R0, #16                ; 0x10
                ??rand_2:
  0x800'2b78: 0xfb06 0x5303   MLA      R3, R6, R3, R5
  0x800'2b7c: 0x46a6          MOV      LR, R4
  0x800'2b7e: 0xfbb3 0xfefe   UDIV     LR, R3, LR
  0x800'2b82: 0xfb04 0x331e   MLS      R3, R4, LR, R3
  0x800'2b86: 0x603b          STR      R3, [R7]
  0x800'2b88: 0x46a4          MOV      R12, R4
  0x800'2b8a: 0xf857 0x3b04   LDR.W    R3, [R7], #0x4
  0x800'2b8e: 0xfb06 0x5303   MLA      R3, R6, R3, R5
  0x800'2b92: 0xfbb3 0xfcfc   UDIV     R12, R3, R12
  0x800'2b96: 0xfb04 0x331c   MLS      R3, R4, R12, R3
  0x800'2b9a: 0x1e40          SUBS     R0, R0, #1
  0x800'2b9c: 0xf847 0x3b04   STR.W    R3, [R7], #0x4
  0x800'2ba0: 0xd1ea          BNE.N    ??rand_2               ; 0x800'2b78
  0x800'2ba2: 0x6fcf          LDR      R7, [R1, #0x7c]
  0x800'2ba4: 0x2001          MOVS     R0, #1
  0x800'2ba6: 0x7010          STRB     R0, [R2]
                ??rand_0:
  0x800'2ba8: 0xfb06 0x5303   MLA      R3, R6, R3, R5
  0x800'2bac: 0x4625          MOV      R5, R4
  0x800'2bae: 0xf007 0x071f   AND.W    R7, R7, #31            ; 0x1f
  0x800'2bb2: 0xfbb3 0xf5f5   UDIV     R5, R3, R5
  0x800'2bb6: 0xf851 0x0027   LDR.W    R0, [R1, R7, LSL #2]
  0x800'2bba: 0xfb04 0x3315   MLS      R3, R4, R5, R3
  0x800'2bbe: 0xf841 0x3027   STR.W    R3, [R1, R7, LSL #2]
  0x800'2bc2: 0xf8c1 0x0080   STR.W    R0, [R1, #0x80]
  0x800'2bc6: 0x6053          STR      R3, [R2, #0x4]
  0x800'2bc8: 0xf020 0x4040   BIC.W    R0, R0, #-1073741824   ; 0xc000'0000
  0x800'2bcc: 0xbdf0          POP      {R4-R7, PC}
  0x800'2bce: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable1:
  0x800'2bd0: 0x2000'21c8     DC32     _Rand_rv
                ??DataTable1_1:
  0x800'2bd4: 0x2000'000c     DC32     _Randinit
                ??DataTable1_2:
  0x800'2bd8: 0x3c6e'f35f     DC32     0x3c6e'f35f            ; '_.n<'
                ??DataTable1_3:
  0x800'2bdc: 0x0019'660d     DC32     0x19'660d              ; '.f..'
                $t:
                `.text6`:
                _tx_thread_stack_build:
  //     LDR     r2, [r0, #16]                           // Pickup end of stack area
  0x800'2be0: 0x6902          LDR      R2, [R0, #0x10]
  //     BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
  0x800'2be2: 0xf022 0x0207   BIC.W    R2, R2, #7
  //     SUB     r2, r2, #68                             // Subtract frame size
  0x800'2be6: 0xf1a2 0x0244   SUB.W    R2, R2, #68            ; 0x44
  //     LDR     r3, =0xFFFFFFFD                         // Build initial LR value
  0x800'2bea: 0x4b0d          LDR.N    R3, [PC, #0x34]        ; 0xffff'fffd
  //     STR     r3, [r2, #0]                            // Save on the stack
  0x800'2bec: 0x6013          STR      R3, [R2]
  //     MOV     r3, #0                                  // Build initial register value
  0x800'2bee: 0xf04f 0x0300   MOV.W    R3, #0
  //     STR     r3, [r2, #4]                            // Store initial r4
  0x800'2bf2: 0x6053          STR      R3, [R2, #0x4]
  //     STR     r3, [r2, #8]                            // Store initial r5
  0x800'2bf4: 0x6093          STR      R3, [R2, #0x8]
  //     STR     r3, [r2, #12]                           // Store initial r6
  0x800'2bf6: 0x60d3          STR      R3, [R2, #0xc]
  //     STR     r3, [r2, #16]                           // Store initial r7
  0x800'2bf8: 0x6113          STR      R3, [R2, #0x10]
  //     STR     r3, [r2, #20]                           // Store initial r8
  0x800'2bfa: 0x6153          STR      R3, [R2, #0x14]
  //     STR     r3, [r2, #24]                           // Store initial r9
  0x800'2bfc: 0x6193          STR      R3, [R2, #0x18]
  //     STR     r3, [r2, #28]                           // Store initial r10
  0x800'2bfe: 0x61d3          STR      R3, [R2, #0x1c]
  //     STR     r3, [r2, #32]                           // Store initial r11
  0x800'2c00: 0x6213          STR      R3, [R2, #0x20]
  //     STR     r3, [r2, #36]                           // Store initial r0
  0x800'2c02: 0x6253          STR      R3, [R2, #0x24]
  //     STR     r3, [r2, #40]                           // Store initial r1
  0x800'2c04: 0x6293          STR      R3, [R2, #0x28]
  //     STR     r3, [r2, #44]                           // Store initial r2
  0x800'2c06: 0x62d3          STR      R3, [R2, #0x2c]
  //     STR     r3, [r2, #48]                           // Store initial r3
  0x800'2c08: 0x6313          STR      R3, [R2, #0x30]
  //     STR     r3, [r2, #52]                           // Store initial r12
  0x800'2c0a: 0x6353          STR      R3, [R2, #0x34]
  //     MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
  0x800'2c0c: 0xf04f 0x33ff   MOV.W    R3, #-1                ; 0xffff'ffff
  //     STR     r3, [r2, #56]                           // Store initial lr
  0x800'2c10: 0x6393          STR      R3, [R2, #0x38]
  //     STR     r1, [r2, #60]                           // Store initial pc
  0x800'2c12: 0x63d1          STR      R1, [R2, #0x3c]
  //     MOV     r3, #0x01000000                         // Only T-bit need be set
  0x800'2c14: 0xf04f 0x7380   MOV.W    R3, #16777216          ; 0x100'0000
  //     STR     r3, [r2, #64]                           // Store initial xPSR
  0x800'2c18: 0x6413          STR      R3, [R2, #0x40]
  //     STR     r2, [r0, #8]                            // Save stack pointer in thread's
  0x800'2c1a: 0x6082          STR      R2, [R0, #0x8]
  //     BX      lr                                      // Return to caller
  0x800'2c1c: 0x4770          BX       LR
  0x800'2c1e: 0x0000          MOVS     R0, R0
                `$d.32`:
  //     END
  0x800'2c20: 0xffff'fffd     DC32     -3                     ; '....'
                $t:
                `.text8`:
                _tx_byte_pool_search:
  // UCHAR  *_tx_byte_pool_search(TX_BYTE_POOL *pool_ptr, ULONG memory_size)
  // {
  0x800'2c24: 0xe92d 0x4fff   PUSH.W   {R0-R11, LR}
  0x800'2c28: 0x0006          MOVS     R6, R0
  0x800'2c2a: 0x000c          MOVS     R4, R1
  // UINT            first_free_block_found =  TX_FALSE;
  0x800'2c2c: 0x2200          MOVS     R2, #0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2c2e: 0xf3ef 0x8810   MRS      R8, PRIMASK
  //     return(posture);
  0x800'2c32: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2c34: 0x68b0          LDR      R0, [R6, #0x8]
  0x800'2c36: 0xf8d6 0xc00c   LDR.W    R12, [R6, #0xc]
  0x800'2c3a: 0xf1bc 0x0c02   SUBS.W   R12, R12, #2
  0x800'2c3e: 0xeb10 0x00cc   ADDS.W   R0, R0, R12, LSL #3
  0x800'2c42: 0x9003          STR      R0, [SP, #0xc]
  //     if (memory_size >= total_theoretical_available)
  0x800'2c44: 0x9803          LDR      R0, [SP, #0xc]
  0x800'2c46: 0x4284          CMP      R4, R0
  0x800'2c48: 0xd304          BCC.N    ??_tx_byte_pool_search_1
                                                              ; 0x800'2c54
  //         TX_RESTORE
  0x800'2c4a: 0x46c4          MOV      R12, R8
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2c4c: 0xf38c 0x8810   MSR      PRIMASK, R12
  // }
  0x800'2c50: 0x2000          MOVS     R0, #0
  0x800'2c52: 0xe0ad          B.N      ??_tx_byte_pool_search_2
                                                              ; 0x800'2db0
                ??_tx_byte_pool_search_1:
  //         TX_THREAD_GET_CURRENT(thread_ptr)
  0x800'2c54: 0x4858          LDR.N    R0, ??_tx_byte_pool_search_0
                                                              ; _tx_thread_current_ptr
  0x800'2c56: 0x6800          LDR      R0, [R0]
  0x800'2c58: 0x9001          STR      R0, [SP, #0x4]
  //         pool_ptr -> tx_byte_pool_owner =  thread_ptr;
  0x800'2c5a: 0x9801          LDR      R0, [SP, #0x4]
  0x800'2c5c: 0x6230          STR      R0, [R6, #0x20]
  //         current_ptr =      pool_ptr -> tx_byte_pool_search;
  0x800'2c5e: 0xf8d6 0xa014   LDR.W    R10, [R6, #0x14]
  //         examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
  0x800'2c62: 0x68f0          LDR      R0, [R6, #0xc]
  0x800'2c64: 0x1c40          ADDS     R0, R0, #1
  0x800'2c66: 0x0001          MOVS     R1, R0
  //         available_bytes =  ((ULONG) 0);
  0x800'2c68: 0x2000          MOVS     R0, #0
  0x800'2c6a: 0x0003          MOVS     R3, R0
                ??_tx_byte_pool_search_3:
  //             work_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
  0x800'2c6c: 0xf11a 0x0004   ADDS.W   R0, R10, #4
  0x800'2c70: 0x0005          MOVS     R5, R0
  //             free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
  0x800'2c72: 0x9500          STR      R5, [SP]
  //             if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
  0x800'2c74: 0x4851          LDR.N    R0, [PC, #0x144]       ; 0xffff'eeee
  0x800'2c76: 0xf8dd 0xc000   LDR.W    R12, [SP]
  0x800'2c7a: 0xf8dc 0xc000   LDR.W    R12, [R12]
  0x800'2c7e: 0x4584          CMP      R12, R0
  0x800'2c80: 0xd138          BNE.N    ??_tx_byte_pool_search_4
                                                              ; 0x800'2cf4
  //                 if (first_free_block_found == TX_FALSE)
  0x800'2c82: 0x2a00          CMP      R2, #0
  0x800'2c84: 0xd104          BNE.N    ??_tx_byte_pool_search_5
                                                              ; 0x800'2c90
  //                     pool_ptr->tx_byte_pool_search =  current_ptr;
  0x800'2c86: 0xf8c6 0xa014   STR.W    R10, [R6, #0x14]
  //                     first_free_block_found =  TX_TRUE;
  0x800'2c8a: 0xf05f 0x0c01   MOVS.W   R12, #1
  0x800'2c8e: 0x4662          MOV      R2, R12
                ??_tx_byte_pool_search_5:
  //                 this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
  0x800'2c90: 0x4657          MOV      R7, R10
  //                 next_ptr =             *this_block_link_ptr;
  0x800'2c92: 0xf8d7 0xc000   LDR.W    R12, [R7]
  0x800'2c96: 0x46e1          MOV      R9, R12
  //                 available_bytes =   TX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
  0x800'2c98: 0xebb9 0x0c0a   SUBS.W   R12, R9, R10
  //                 available_bytes =   available_bytes - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
  0x800'2c9c: 0xf1bc 0x0c08   SUBS.W   R12, R12, #8
  0x800'2ca0: 0x4663          MOV      R3, R12
  //                 if (available_bytes >= memory_size)
  0x800'2ca2: 0x42a3          CMP      R3, R4
  0x800'2ca4: 0xd24b          BCS.N    ??_tx_byte_pool_search_6
                                                              ; 0x800'2d3e
                ??_tx_byte_pool_search_7:
  //                     available_bytes =  ((ULONG) 0);
  0x800'2ca6: 0xf05f 0x0c00   MOVS.W   R12, #0
  0x800'2caa: 0x4663          MOV      R3, R12
  //                     work_ptr =  TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
  0x800'2cac: 0xf119 0x0c04   ADDS.W   R12, R9, #4
  0x800'2cb0: 0x4665          MOV      R5, R12
  //                     free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
  0x800'2cb2: 0x9500          STR      R5, [SP]
  //                     if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
  0x800'2cb4: 0xf8dd 0xc000   LDR.W    R12, [SP]
  0x800'2cb8: 0xf8dc 0xc000   LDR.W    R12, [R12]
  0x800'2cbc: 0x4584          CMP      R12, R0
  0x800'2cbe: 0xd111          BNE.N    ??_tx_byte_pool_search_8
                                                              ; 0x800'2ce4
  //                         next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
  0x800'2cc0: 0x46ce          MOV      LR, R9
  //                         *this_block_link_ptr =  *next_block_link_ptr;
  0x800'2cc2: 0xf8de 0xc000   LDR.W    R12, [LR]
  0x800'2cc6: 0xf8c7 0xc000   STR.W    R12, [R7]
  //                         pool_ptr -> tx_byte_pool_fragments--;
  0x800'2cca: 0xf8d6 0xc00c   LDR.W    R12, [R6, #0xc]
  0x800'2cce: 0xf1bc 0x0c01   SUBS.W   R12, R12, #1
  0x800'2cd2: 0xf8c6 0xc00c   STR.W    R12, [R6, #0xc]
  //                         if (pool_ptr -> tx_byte_pool_search ==  next_ptr)
  0x800'2cd6: 0xf8d6 0xc014   LDR.W    R12, [R6, #0x14]
  0x800'2cda: 0x45cc          CMP      R12, R9
  0x800'2cdc: 0xd10e          BNE.N    ??_tx_byte_pool_search_9
                                                              ; 0x800'2cfc
  //                             pool_ptr -> tx_byte_pool_search =  current_ptr;
  0x800'2cde: 0xf8c6 0xa014   STR.W    R10, [R6, #0x14]
  0x800'2ce2: 0xe00b          B.N      ??_tx_byte_pool_search_9
                                                              ; 0x800'2cfc
                ??_tx_byte_pool_search_8:
  //                         next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
  0x800'2ce4: 0x46ce          MOV      LR, R9
  //                         current_ptr =  *next_block_link_ptr;
  0x800'2ce6: 0xf8de 0xc000   LDR.W    R12, [LR]
  0x800'2cea: 0x46e2          MOV      R10, R12
  //                         if (examine_blocks != ((UINT) 0))
  0x800'2cec: 0x2900          CMP      R1, #0
  0x800'2cee: 0xd005          BEQ.N    ??_tx_byte_pool_search_9
                                                              ; 0x800'2cfc
  //                             examine_blocks--;
  0x800'2cf0: 0x1e49          SUBS     R1, R1, #1
  0x800'2cf2: 0xe003          B.N      ??_tx_byte_pool_search_9
                                                              ; 0x800'2cfc
                ??_tx_byte_pool_search_4:
  //                 this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
  0x800'2cf4: 0x4657          MOV      R7, R10
  //                 current_ptr =  *this_block_link_ptr;
  0x800'2cf6: 0xf8d7 0xc000   LDR.W    R12, [R7]
  0x800'2cfa: 0x46e2          MOV      R10, R12
                ??_tx_byte_pool_search_9:
  //             if (examine_blocks != ((UINT) 0))
  0x800'2cfc: 0x2900          CMP      R1, #0
  0x800'2cfe: 0xd000          BEQ.N    ??_tx_byte_pool_search_10
                                                              ; 0x800'2d02
  //                 examine_blocks--;
  0x800'2d00: 0x1e49          SUBS     R1, R1, #1
                ??_tx_byte_pool_search_10:
  //             TX_RESTORE
  0x800'2d02: 0xf8cd 0x8008   STR.W    R8, [SP, #0x8]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2d06: 0xf8dd 0xc008   LDR.W    R12, [SP, #0x8]
  0x800'2d0a: 0xf38c 0x8810   MSR      PRIMASK, R12
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2d0e: 0xf3ef 0x8c10   MRS      R12, PRIMASK
  //     return(posture);
  0x800'2d12: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2d14: 0x46e0          MOV      R8, R12
  //             if (pool_ptr -> tx_byte_pool_owner != thread_ptr)
  0x800'2d16: 0xf8d6 0xc020   LDR.W    R12, [R6, #0x20]
  0x800'2d1a: 0xf8dd 0xb004   LDR.W    R11, [SP, #0x4]
  0x800'2d1e: 0x45dc          CMP      R12, R11
  0x800'2d20: 0xd00b          BEQ.N    ??_tx_byte_pool_search_11
                                                              ; 0x800'2d3a
  //                 current_ptr =      pool_ptr -> tx_byte_pool_search;
  0x800'2d22: 0xf8d6 0xc014   LDR.W    R12, [R6, #0x14]
  0x800'2d26: 0x46e2          MOV      R10, R12
  //                 examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
  0x800'2d28: 0xf8d6 0xc00c   LDR.W    R12, [R6, #0xc]
  0x800'2d2c: 0xf11c 0x0c01   ADDS.W   R12, R12, #1
  0x800'2d30: 0x4661          MOV      R1, R12
  //                 pool_ptr -> tx_byte_pool_owner =  thread_ptr;
  0x800'2d32: 0xf8dd 0xc004   LDR.W    R12, [SP, #0x4]
  0x800'2d36: 0xf8c6 0xc020   STR.W    R12, [R6, #0x20]
                ??_tx_byte_pool_search_11:
  //         } while(examine_blocks != ((UINT) 0));
  0x800'2d3a: 0x2900          CMP      R1, #0
  0x800'2d3c: 0xd196          BNE.N    ??_tx_byte_pool_search_3
                                                              ; 0x800'2c6c
                ??_tx_byte_pool_search_6:
  //         if (available_bytes != ((ULONG) 0))
  0x800'2d3e: 0x2b00          CMP      R3, #0
  0x800'2d40: 0xd032          BEQ.N    ??_tx_byte_pool_search_12
                                                              ; 0x800'2da8
  //             if ((available_bytes - memory_size) >= ((ULONG) TX_BYTE_BLOCK_MIN))
  0x800'2d42: 0xebb3 0x0c04   SUBS.W   R12, R3, R4
  0x800'2d46: 0xf1bc 0x0f14   CMP.W    R12, #20               ; 0x14
  0x800'2d4a: 0xd318          BCC.N    ??_tx_byte_pool_search_13
                                                              ; 0x800'2d7e
  //                 next_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (memory_size + ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
  0x800'2d4c: 0xeb0a 0x0c04   ADD.W    R12, R10, R4
  0x800'2d50: 0xf11c 0x0c08   ADDS.W   R12, R12, #8
  0x800'2d54: 0x46e1          MOV      R9, R12
  //                 next_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
  0x800'2d56: 0x46ce          MOV      LR, R9
  //                 this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
  0x800'2d58: 0x4657          MOV      R7, R10
  //                 *next_block_link_ptr =  *this_block_link_ptr;
  0x800'2d5a: 0xf8d7 0xc000   LDR.W    R12, [R7]
  0x800'2d5e: 0xf8ce 0xc000   STR.W    R12, [LR]
  //                 work_ptr =              TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
  0x800'2d62: 0xf119 0x0c04   ADDS.W   R12, R9, #4
  0x800'2d66: 0x4665          MOV      R5, R12
  //                 free_ptr =              TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
  0x800'2d68: 0x9500          STR      R5, [SP]
  //                 *free_ptr =             TX_BYTE_BLOCK_FREE;
  0x800'2d6a: 0xf8dd 0xc000   LDR.W    R12, [SP]
  0x800'2d6e: 0xf8cc 0x0000   STR.W    R0, [R12]
  //                 pool_ptr -> tx_byte_pool_fragments++;
  0x800'2d72: 0x68f0          LDR      R0, [R6, #0xc]
  0x800'2d74: 0x1c40          ADDS     R0, R0, #1
  0x800'2d76: 0x60f0          STR      R0, [R6, #0xc]
  //                 *this_block_link_ptr =  next_ptr;
  0x800'2d78: 0xf8c7 0x9000   STR.W    R9, [R7]
  //                 available_bytes =  memory_size;
  0x800'2d7c: 0x0023          MOVS     R3, R4
                ??_tx_byte_pool_search_13:
  //             work_ptr =              TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
  0x800'2d7e: 0xf11a 0x0004   ADDS.W   R0, R10, #4
  0x800'2d82: 0x0005          MOVS     R5, R0
  //             this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
  0x800'2d84: 0x002f          MOVS     R7, R5
  //             *this_block_link_ptr =  TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
  0x800'2d86: 0x603e          STR      R6, [R7]
  //             pool_ptr -> tx_byte_pool_available =  (pool_ptr -> tx_byte_pool_available - available_bytes) - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
  0x800'2d88: 0x68b0          LDR      R0, [R6, #0x8]
  0x800'2d8a: 0x1ac0          SUBS     R0, R0, R3
  0x800'2d8c: 0x3808          SUBS     R0, R0, #8
  0x800'2d8e: 0x60b0          STR      R0, [R6, #0x8]
  //             if (current_ptr == pool_ptr -> tx_byte_pool_search)
  0x800'2d90: 0x6970          LDR      R0, [R6, #0x14]
  0x800'2d92: 0x4582          CMP      R10, R0
  0x800'2d94: 0xd102          BNE.N    ??_tx_byte_pool_search_14
                                                              ; 0x800'2d9c
  //                 this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
  0x800'2d96: 0x4657          MOV      R7, R10
  //                 pool_ptr -> tx_byte_pool_search =  *this_block_link_ptr;
  0x800'2d98: 0x6838          LDR      R0, [R7]
  0x800'2d9a: 0x6170          STR      R0, [R6, #0x14]
                ??_tx_byte_pool_search_14:
  //             TX_RESTORE
  0x800'2d9c: 0x46c4          MOV      R12, R8
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2d9e: 0xf38c 0x8810   MSR      PRIMASK, R12
  // }
  0x800'2da2: 0xf11a 0x0008   ADDS.W   R0, R10, #8
  0x800'2da6: 0xe003          B.N      ??_tx_byte_pool_search_2
                                                              ; 0x800'2db0
                ??_tx_byte_pool_search_12:
  //             TX_RESTORE
  0x800'2da8: 0x46c4          MOV      R12, R8
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2daa: 0xf38c 0x8810   MSR      PRIMASK, R12
  // }
  0x800'2dae: 0x2000          MOVS     R0, #0
                ??_tx_byte_pool_search_2:
  //     return(current_ptr);
  0x800'2db0: 0xb004          ADD      SP, SP, #0x10
  0x800'2db2: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'2db6: 0xbf00          NOP
                `$d.32`:
                ??_tx_byte_pool_search_0:
  0x800'2db8: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'2dbc: 0xffff'eeee     DC32     -4370                  ; '....'
                $t:
                `.text8`:
                _tx_thread_time_slice:
  // VOID  _tx_thread_time_slice(VOID)
  // {
  0x800'2dc0: 0xe92d 0x41f0   PUSH.W   {R4-R8, LR}
  //     TX_THREAD_GET_CURRENT(thread_ptr)
  0x800'2dc4: 0x485d          LDR.N    R0, ??_tx_thread_time_slice_0
                                                              ; _tx_thread_current_ptr
  0x800'2dc6: 0x6804          LDR      R4, [R0]
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2dc8: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'2dcc: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2dce: 0x2c00          CMP      R4, #0
  0x800'2dd0: 0xd039          BEQ.N    ??_tx_thread_time_slice_1
                                                              ; 0x800'2e46
  0x800'2dd2: 0x6820          LDR      R0, [R4]
  0x800'2dd4: 0x495a          LDR.N    R1, [PC, #0x168]       ; 0x5448'5244
  0x800'2dd6: 0x4288          CMP      R0, R1
  0x800'2dd8: 0xd135          BNE.N    ??_tx_thread_time_slice_1
                                                              ; 0x800'2e46
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2dda: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'2ddc: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'2de0: 0x4281          CMP      R1, R0
  0x800'2de2: 0xd202          BCS.N    ??_tx_thread_time_slice_2
                                                              ; 0x800'2dea
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2de4: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'2de6: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_time_slice_2:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2dea: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'2dec: 0x6801          LDR      R1, [R0]
  0x800'2dee: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2df2: 0x4281          CMP      R1, R0
  0x800'2df4: 0xd10b          BNE.N    ??_tx_thread_time_slice_3
                                                              ; 0x800'2e0e
  0x800'2df6: 0x6920          LDR      R0, [R4, #0x10]
  0x800'2df8: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'2dfc: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2e00: 0x4281          CMP      R1, R0
  0x800'2e02: 0xd104          BNE.N    ??_tx_thread_time_slice_3
                                                              ; 0x800'2e0e
  0x800'2e04: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'2e08: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'2e0a: 0x4281          CMP      R1, R0
  0x800'2e0c: 0xd209          BCS.N    ??_tx_thread_time_slice_4
                                                              ; 0x800'2e22
                ??_tx_thread_time_slice_3:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2e0e: 0x003d          MOVS     R5, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2e10: 0xf385 0x8810   MSR      PRIMASK, R5
  // }
  0x800'2e14: 0x0020          MOVS     R0, R4
  0x800'2e16: 0xf7ff 0xfa53   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2e1a: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2e1e: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2e20: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_4:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2e22: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'2e26: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'2e2a: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2e2e: 0x4281          CMP      R1, R0
  0x800'2e30: 0xd009          BEQ.N    ??_tx_thread_time_slice_1
                                                              ; 0x800'2e46
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2e32: 0x003d          MOVS     R5, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2e34: 0xf385 0x8810   MSR      PRIMASK, R5
  // }
  0x800'2e38: 0x0020          MOVS     R0, R4
  0x800'2e3a: 0xf7ff 0xfa53   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2e3e: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2e42: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2e44: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_1:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2e46: 0x003a          MOVS     R2, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2e48: 0xf382 0x8810   MSR      PRIMASK, R2
  // }
  0x800'2e4c: 0x2500          MOVS     R5, #0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2e4e: 0xf3ef 0x8610   MRS      R6, PRIMASK
  //     return(posture);
  0x800'2e52: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2e54: 0x2000          MOVS     R0, #0
  0x800'2e56: 0x493b          LDR.N    R1, [PC, #0xec]        ; _tx_timer_expired_time_slice
  0x800'2e58: 0x6008          STR      R0, [R1]
  //     if (thread_ptr != TX_NULL)
  0x800'2e5a: 0x2c00          CMP      R4, #0
  0x800'2e5c: 0xd024          BEQ.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2ea8
  //         if (thread_ptr -> tx_thread_state == TX_READY)
  0x800'2e5e: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'2e60: 0x2800          CMP      R0, #0
  0x800'2e62: 0xd121          BNE.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2ea8
  //             thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
  0x800'2e64: 0x69e0          LDR      R0, [R4, #0x1c]
  0x800'2e66: 0x61a0          STR      R0, [R4, #0x18]
  //             _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
  0x800'2e68: 0x69a1          LDR      R1, [R4, #0x18]
  0x800'2e6a: 0x4837          LDR.N    R0, [PC, #0xdc]        ; _tx_timer_time_slice
  0x800'2e6c: 0x6001          STR      R1, [R0]
  //             if (thread_ptr -> tx_thread_ready_next != thread_ptr)
  0x800'2e6e: 0x6a20          LDR      R0, [R4, #0x20]
  0x800'2e70: 0x42a0          CMP      R0, R4
  0x800'2e72: 0xd019          BEQ.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2ea8
  //                 if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
  0x800'2e74: 0x6ae0          LDR      R0, [R4, #0x2c]
  0x800'2e76: 0x6be1          LDR      R1, [R4, #0x3c]
  0x800'2e78: 0x4288          CMP      R0, R1
  0x800'2e7a: 0xd115          BNE.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2ea8
  //                     _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
  0x800'2e7c: 0x4933          LDR.N    R1, [PC, #0xcc]        ; _tx_thread_priority_list
  0x800'2e7e: 0x6a20          LDR      R0, [R4, #0x20]
  0x800'2e80: 0x6ae2          LDR      R2, [R4, #0x2c]
  0x800'2e82: 0xf841 0x0022   STR.W    R0, [R1, R2, LSL #2]
  //                     _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
  0x800'2e86: 0x4832          LDR.N    R0, [PC, #0xc8]        ; _tx_thread_execute_ptr
  0x800'2e88: 0x4a32          LDR.N    R2, [PC, #0xc8]        ; _tx_thread_highest_priority
  0x800'2e8a: 0x6812          LDR      R2, [R2]
  0x800'2e8c: 0xf851 0x1022   LDR.W    R1, [R1, R2, LSL #2]
  0x800'2e90: 0x6001          STR      R1, [R0]
  //                     thread_ptr -> tx_thread_performance_time_slice_count++;
  0x800'2e92: 0xf8d4 0x10bc   LDR.W    R1, [R4, #0xbc]
  0x800'2e96: 0x1c49          ADDS     R1, R1, #1
  0x800'2e98: 0xf8c4 0x10bc   STR.W    R1, [R4, #0xbc]
  //                     _tx_thread_performance_time_slice_count++;
  0x800'2e9c: 0x4a2e          LDR.N    R2, [PC, #0xb8]        ; _tx_thread_performance_time_slice_count
  0x800'2e9e: 0x6811          LDR      R1, [R2]
  0x800'2ea0: 0x1c49          ADDS     R1, R1, #1
  0x800'2ea2: 0x6011          STR      R1, [R2]
  //                     next_thread_ptr =  _tx_thread_execute_ptr;
  0x800'2ea4: 0x6800          LDR      R0, [R0]
  0x800'2ea6: 0x0005          MOVS     R5, R0
                ??_tx_thread_time_slice_5:
  //     TX_RESTORE
  0x800'2ea8: 0x0030          MOVS     R0, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2eaa: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'2eae: 0x2d00          CMP      R5, #0
  0x800'2eb0: 0xd041          BEQ.N    ??_tx_thread_time_slice_6
                                                              ; 0x800'2f36
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2eb2: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'2eb6: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2eb8: 0x2d00          CMP      R5, #0
  0x800'2eba: 0xd039          BEQ.N    ??_tx_thread_time_slice_7
                                                              ; 0x800'2f30
  0x800'2ebc: 0x6829          LDR      R1, [R5]
  0x800'2ebe: 0x4820          LDR.N    R0, [PC, #0x80]        ; 0x5448'5244
  0x800'2ec0: 0x4281          CMP      R1, R0
  0x800'2ec2: 0xd135          BNE.N    ??_tx_thread_time_slice_7
                                                              ; 0x800'2f30
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2ec4: 0x68a9          LDR      R1, [R5, #0x8]
  0x800'2ec6: 0xf8d5 0x00cc   LDR.W    R0, [R5, #0xcc]
  0x800'2eca: 0x4281          CMP      R1, R0
  0x800'2ecc: 0xd202          BCS.N    ??_tx_thread_time_slice_8
                                                              ; 0x800'2ed4
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2ece: 0x68a8          LDR      R0, [R5, #0x8]
  0x800'2ed0: 0xf8c5 0x00cc   STR.W    R0, [R5, #0xcc]
                ??_tx_thread_time_slice_8:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2ed4: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'2ed6: 0x6801          LDR      R1, [R0]
  0x800'2ed8: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2edc: 0x4281          CMP      R1, R0
  0x800'2ede: 0xd10b          BNE.N    ??_tx_thread_time_slice_9
                                                              ; 0x800'2ef8
  0x800'2ee0: 0x6928          LDR      R0, [R5, #0x10]
  0x800'2ee2: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'2ee6: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2eea: 0x4281          CMP      R1, R0
  0x800'2eec: 0xd104          BNE.N    ??_tx_thread_time_slice_9
                                                              ; 0x800'2ef8
  0x800'2eee: 0xf8d5 0x10cc   LDR.W    R1, [R5, #0xcc]
  0x800'2ef2: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'2ef4: 0x4281          CMP      R1, R0
  0x800'2ef6: 0xd209          BCS.N    ??_tx_thread_time_slice_10
                                                              ; 0x800'2f0c
                ??_tx_thread_time_slice_9:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2ef8: 0x46b8          MOV      R8, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2efa: 0xf388 0x8810   MSR      PRIMASK, R8
  // }
  0x800'2efe: 0x0028          MOVS     R0, R5
  0x800'2f00: 0xf7ff 0xf9de   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2f04: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2f08: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2f0a: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_10:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2f0c: 0xf8d5 0x00cc   LDR.W    R0, [R5, #0xcc]
  0x800'2f10: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'2f14: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2f18: 0x4281          CMP      R1, R0
  0x800'2f1a: 0xd009          BEQ.N    ??_tx_thread_time_slice_7
                                                              ; 0x800'2f30
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2f1c: 0x46b8          MOV      R8, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2f1e: 0xf388 0x8810   MSR      PRIMASK, R8
  // }
  0x800'2f22: 0x0028          MOVS     R0, R5
  0x800'2f24: 0xf7ff 0xf9de   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2f28: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2f2c: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2f2e: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_7:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2f30: 0x0038          MOVS     R0, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2f32: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_time_slice_6:
  // }
  0x800'2f36: 0xe8bd 0x81f0   POP.W    {R4-R8, PC}
  0x800'2f3a: 0xbf00          NOP
                `$d.32`:
                ??_tx_thread_time_slice_0:
  0x800'2f3c: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'2f40: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
  0x800'2f44: 0x2000'24a4     DC32     _tx_timer_expired_time_slice
  0x800'2f48: 0x2000'24d4     DC32     _tx_timer_time_slice
  0x800'2f4c: 0x2000'224c     DC32     _tx_thread_priority_list
  0x800'2f50: 0x2000'2458     DC32     _tx_thread_execute_ptr
  0x800'2f54: 0x2000'2468     DC32     _tx_thread_highest_priority
  0x800'2f58: 0x2000'248c     DC32     _tx_thread_performance_time_slice_count
                $t:
                `.text8`:
                _txe_thread_create:
  // UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr,
  //                 VOID (*entry_function)(ULONG id), ULONG entry_input,
  //                 VOID *stack_start, ULONG stack_size,
  //                 UINT priority, UINT preempt_threshold,
  //                 ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
  // {
  0x800'2f5c: 0xe92d 0x4ffe   PUSH.W   {R1-R11, LR}
  0x800'2f60: 0xb08a          SUB      SP, SP, #0x28
  0x800'2f62: 0x0004          MOVS     R4, R0
  0x800'2f64: 0x9d16          LDR      R5, [SP, #0x58]
  0x800'2f66: 0xf8dd 0xb05c   LDR.W    R11, [SP, #0x5c]
  0x800'2f6a: 0x9f18          LDR      R7, [SP, #0x60]
  //     status =  TX_SUCCESS;
  0x800'2f6c: 0x2600          MOVS     R6, #0
  //     if (thread_ptr == TX_NULL)
  0x800'2f6e: 0x2c00          CMP      R4, #0
  0x800'2f70: 0xd102          BNE.N    ??_txe_thread_create_1 ; 0x800'2f78
  //         status =  TX_THREAD_ERROR;
  0x800'2f72: 0x200e          MOVS     R0, #14                ; 0xe
  0x800'2f74: 0x0006          MOVS     R6, R0
  0x800'2f76: 0xe095          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_1:
  //     else if (thread_control_block_size != (sizeof(TX_THREAD)))
  0x800'2f78: 0x981c          LDR      R0, [SP, #0x70]
  0x800'2f7a: 0x28d8          CMP      R0, #216               ; 0xd8
  0x800'2f7c: 0xd002          BEQ.N    ??_txe_thread_create_3 ; 0x800'2f84
  //         status =  TX_THREAD_ERROR;
  0x800'2f7e: 0x200e          MOVS     R0, #14                ; 0xe
  0x800'2f80: 0x0006          MOVS     R6, R0
  0x800'2f82: 0xe08f          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_3:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2f84: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2f88: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2f8a: 0x9006          STR      R0, [SP, #0x18]
  //         _tx_thread_preempt_disable++;
  0x800'2f8c: 0x4851          LDR.N    R0, ??_txe_thread_create_0
                                                              ; _tx_thread_preempt_disable
  0x800'2f8e: 0x6801          LDR      R1, [R0]
  0x800'2f90: 0x1c49          ADDS     R1, R1, #1
  0x800'2f92: 0x6001          STR      R1, [R0]
  //         TX_RESTORE
  0x800'2f94: 0x9906          LDR      R1, [SP, #0x18]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2f96: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2f9a: 0x2200          MOVS     R2, #0
  0x800'2f9c: 0x4690          MOV      R8, R2
  //         next_thread =  _tx_thread_created_ptr;
  0x800'2f9e: 0x4a4e          LDR.N    R2, [PC, #0x138]       ; _tx_thread_created_ptr
  0x800'2fa0: 0x6812          LDR      R2, [R2]
  0x800'2fa2: 0x4692          MOV      R10, R2
  //         work_ptr =     TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
  0x800'2fa4: 0x002a          MOVS     R2, R5
  //         work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
  0x800'2fa6: 0x445a          ADD      R2, R2, R11
  0x800'2fa8: 0x1e52          SUBS     R2, R2, #1
  0x800'2faa: 0x9209          STR      R2, [SP, #0x24]
  //         stack_end =    TX_UCHAR_TO_VOID_POINTER_CONVERT(work_ptr);
  0x800'2fac: 0x9a09          LDR      R2, [SP, #0x24]
  0x800'2fae: 0x9207          STR      R2, [SP, #0x1c]
  //         for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
  0x800'2fb0: 0x2200          MOVS     R2, #0
  0x800'2fb2: 0x4691          MOV      R9, R2
                ??_txe_thread_create_4:
  //         for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
  0x800'2fb4: 0x4949          LDR.N    R1, [PC, #0x124]       ; _tx_thread_created_count
  0x800'2fb6: 0x6809          LDR      R1, [R1]
  0x800'2fb8: 0x4589          CMP      R9, R1
  0x800'2fba: 0xd225          BCS.N    ??_txe_thread_create_5 ; 0x800'3008
  //             if (thread_ptr == next_thread)
  0x800'2fbc: 0x4554          CMP      R4, R10
  0x800'2fbe: 0xd101          BNE.N    ??_txe_thread_create_6 ; 0x800'2fc4
  //                 break_flag =  TX_TRUE;
  0x800'2fc0: 0x2101          MOVS     R1, #1
  0x800'2fc2: 0x4688          MOV      R8, R1
                ??_txe_thread_create_6:
  //             if (break_flag == TX_TRUE)
  0x800'2fc4: 0xf1b8 0x0f01   CMP.W    R8, #1
  0x800'2fc8: 0xd01e          BEQ.N    ??_txe_thread_create_5 ; 0x800'3008
                ??_txe_thread_create_7:
  //             if (stack_start >= next_thread -> tx_thread_stack_start)
  0x800'2fca: 0xf8da 0x100c   LDR.W    R1, [R10, #0xc]
  0x800'2fce: 0x428d          CMP      R5, R1
  0x800'2fd0: 0xd307          BCC.N    ??_txe_thread_create_8 ; 0x800'2fe2
  //                 if (stack_start < next_thread -> tx_thread_stack_end)
  0x800'2fd2: 0xf8da 0x1010   LDR.W    R1, [R10, #0x10]
  0x800'2fd6: 0x428d          CMP      R5, R1
  0x800'2fd8: 0xd203          BCS.N    ??_txe_thread_create_8 ; 0x800'2fe2
  //                     stack_start =  TX_NULL;
  0x800'2fda: 0x2100          MOVS     R1, #0
  0x800'2fdc: 0x000d          MOVS     R5, R1
  //                     break_flag =  TX_TRUE;
  0x800'2fde: 0x2101          MOVS     R1, #1
  0x800'2fe0: 0x4688          MOV      R8, R1
                ??_txe_thread_create_8:
  //             if (stack_end >= next_thread -> tx_thread_stack_start)
  0x800'2fe2: 0x9907          LDR      R1, [SP, #0x1c]
  0x800'2fe4: 0xf8da 0x200c   LDR.W    R2, [R10, #0xc]
  0x800'2fe8: 0x4291          CMP      R1, R2
  0x800'2fea: 0xd308          BCC.N    ??_txe_thread_create_9 ; 0x800'2ffe
  //                 if (stack_end < next_thread -> tx_thread_stack_end)
  0x800'2fec: 0x9907          LDR      R1, [SP, #0x1c]
  0x800'2fee: 0xf8da 0x2010   LDR.W    R2, [R10, #0x10]
  0x800'2ff2: 0x4291          CMP      R1, R2
  0x800'2ff4: 0xd203          BCS.N    ??_txe_thread_create_9 ; 0x800'2ffe
  //                     stack_start =  TX_NULL;
  0x800'2ff6: 0x2100          MOVS     R1, #0
  0x800'2ff8: 0x000d          MOVS     R5, R1
  //                     break_flag =  TX_TRUE;
  0x800'2ffa: 0x2101          MOVS     R1, #1
  0x800'2ffc: 0x4688          MOV      R8, R1
                ??_txe_thread_create_9:
  //             next_thread =  next_thread -> tx_thread_created_next;
  0x800'2ffe: 0xf8da 0xa088   LDR.W    R10, [R10, #0x88]
  //         for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
  0x800'3002: 0xf119 0x0901   ADDS.W   R9, R9, #1
  0x800'3006: 0xe7d5          B.N      ??_txe_thread_create_4 ; 0x800'2fb4
                ??_txe_thread_create_5:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3008: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'300c: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'300e: 0x9106          STR      R1, [SP, #0x18]
  //         _tx_thread_preempt_disable--;
  0x800'3010: 0x6801          LDR      R1, [R0]
  0x800'3012: 0x1e49          SUBS     R1, R1, #1
  0x800'3014: 0x6001          STR      R1, [R0]
  //         TX_RESTORE
  0x800'3016: 0x9806          LDR      R0, [SP, #0x18]
  0x800'3018: 0x9000          STR      R0, [SP]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'301a: 0x9800          LDR      R0, [SP]
  0x800'301c: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'3020: 0xf000 0xf864   BL       _tx_thread_system_preempt_check
                                                              ; 0x800'30ec
  //         if (thread_ptr == next_thread)
  0x800'3024: 0x4554          CMP      R4, R10
  0x800'3026: 0xd102          BNE.N    ??_txe_thread_create_10
                                                              ; 0x800'302e
  //             status =  TX_THREAD_ERROR;
  0x800'3028: 0x200e          MOVS     R0, #14                ; 0xe
  0x800'302a: 0x0006          MOVS     R6, R0
  0x800'302c: 0xe03a          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_10:
  //         else if (stack_start == TX_NULL)
  0x800'302e: 0x2d00          CMP      R5, #0
  0x800'3030: 0xd102          BNE.N    ??_txe_thread_create_11
                                                              ; 0x800'3038
  //             status =  TX_PTR_ERROR;
  0x800'3032: 0x2003          MOVS     R0, #3
  0x800'3034: 0x0006          MOVS     R6, R0
  0x800'3036: 0xe035          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_11:
  //         else if (entry_function == TX_NULL)
  0x800'3038: 0x980b          LDR      R0, [SP, #0x2c]
  0x800'303a: 0x2800          CMP      R0, #0
  0x800'303c: 0xd102          BNE.N    ??_txe_thread_create_12
                                                              ; 0x800'3044
  //             status =  TX_PTR_ERROR;
  0x800'303e: 0x2003          MOVS     R0, #3
  0x800'3040: 0x0006          MOVS     R6, R0
  0x800'3042: 0xe02f          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_12:
  //         else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
  0x800'3044: 0xf5bb 0x6f80   CMP.W    R11, #1024             ; 0x400
  0x800'3048: 0xd202          BCS.N    ??_txe_thread_create_13
                                                              ; 0x800'3050
  //             status =  TX_SIZE_ERROR;
  0x800'304a: 0x2005          MOVS     R0, #5
  0x800'304c: 0x0006          MOVS     R6, R0
  0x800'304e: 0xe029          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_13:
  //         else if (priority >= ((UINT) TX_MAX_PRIORITIES))
  0x800'3050: 0x2f20          CMP      R7, #32                ; 0x20
  0x800'3052: 0xd302          BCC.N    ??_txe_thread_create_14
                                                              ; 0x800'305a
  //             status =  TX_PRIORITY_ERROR;
  0x800'3054: 0x200f          MOVS     R0, #15                ; 0xf
  0x800'3056: 0x0006          MOVS     R6, R0
  0x800'3058: 0xe024          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_14:
  //         else if (preempt_threshold > priority)
  0x800'305a: 0x9819          LDR      R0, [SP, #0x64]
  0x800'305c: 0x4287          CMP      R7, R0
  0x800'305e: 0xd202          BCS.N    ??_txe_thread_create_15
                                                              ; 0x800'3066
  //             status =  TX_THRESH_ERROR;
  0x800'3060: 0x2018          MOVS     R0, #24                ; 0x18
  0x800'3062: 0x0006          MOVS     R6, R0
  0x800'3064: 0xe01e          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_15:
  //         else if (auto_start > TX_AUTO_START)
  0x800'3066: 0x981b          LDR      R0, [SP, #0x6c]
  0x800'3068: 0x2802          CMP      R0, #2
  0x800'306a: 0xd302          BCC.N    ??_txe_thread_create_16
                                                              ; 0x800'3072
  //             status =  TX_START_ERROR;
  0x800'306c: 0x2010          MOVS     R0, #16                ; 0x10
  0x800'306e: 0x0006          MOVS     R6, R0
  0x800'3070: 0xe018          B.N      ??_txe_thread_create_2 ; 0x800'30a4
                ??_txe_thread_create_16:
  //             TX_THREAD_GET_CURRENT(current_thread)
  0x800'3072: 0x481b          LDR.N    R0, [PC, #0x6c]        ; _tx_thread_current_ptr
  0x800'3074: 0x6800          LDR      R0, [R0]
  0x800'3076: 0x9008          STR      R0, [SP, #0x20]
  //             if (current_thread == &_tx_timer_thread)
  0x800'3078: 0x9908          LDR      R1, [SP, #0x20]
  0x800'307a: 0x481a          LDR.N    R0, [PC, #0x68]        ; _tx_timer_thread
  0x800'307c: 0x4281          CMP      R1, R0
  0x800'307e: 0xd101          BNE.N    ??_txe_thread_create_17
                                                              ; 0x800'3084
  //                 status =  TX_CALLER_ERROR;
  0x800'3080: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'3082: 0x0006          MOVS     R6, R0
                ??_txe_thread_create_17:
  //             if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  0x800'3084: 0x4a18          LDR.N    R2, [PC, #0x60]        ; _tx_thread_system_state
  0x800'3086: 0x6810          LDR      R0, [R2]
  0x800'3088: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'308c: 0x4308          ORRS     R0, R0, R1
  0x800'308e: 0x2800          CMP      R0, #0
  0x800'3090: 0xd008          BEQ.N    ??_txe_thread_create_2 ; 0x800'30a4
  //                 if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  0x800'3092: 0x6811          LDR      R1, [R2]
  0x800'3094: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'3098: 0x4301          ORRS     R1, R1, R0
  0x800'309a: 0xf1b1 0x3ff0   CMP.W    R1, #-252645136        ; 0xf0f0'f0f0
  0x800'309e: 0xd201          BCS.N    ??_txe_thread_create_2 ; 0x800'30a4
  //                     status =  TX_CALLER_ERROR;
  0x800'30a0: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'30a2: 0x0006          MOVS     R6, R0
                ??_txe_thread_create_2:
  //     if (status == TX_SUCCESS)
  0x800'30a4: 0x2e00          CMP      R6, #0
  0x800'30a6: 0xd110          BNE.N    ??_txe_thread_create_18
                                                              ; 0x800'30ca
  //         status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
  //                         stack_start, stack_size, priority, preempt_threshold,
  //                         time_slice, auto_start);
  0x800'30a8: 0x981b          LDR      R0, [SP, #0x6c]
  0x800'30aa: 0x9005          STR      R0, [SP, #0x14]
  0x800'30ac: 0x981a          LDR      R0, [SP, #0x68]
  0x800'30ae: 0x9004          STR      R0, [SP, #0x10]
  0x800'30b0: 0x9819          LDR      R0, [SP, #0x64]
  0x800'30b2: 0x9003          STR      R0, [SP, #0xc]
  0x800'30b4: 0x9702          STR      R7, [SP, #0x8]
  0x800'30b6: 0xf8cd 0xb004   STR.W    R11, [SP, #0x4]
  0x800'30ba: 0x9500          STR      R5, [SP]
  0x800'30bc: 0x9b0c          LDR      R3, [SP, #0x30]
  0x800'30be: 0x9a0b          LDR      R2, [SP, #0x2c]
  0x800'30c0: 0x990a          LDR      R1, [SP, #0x28]
  0x800'30c2: 0x0020          MOVS     R0, R4
  0x800'30c4: 0xf7ff 0xfc5a   BL       _tx_thread_create      ; 0x800'297c
  0x800'30c8: 0x0006          MOVS     R6, R0
                ??_txe_thread_create_18:
  //     return(status);
  0x800'30ca: 0x0030          MOVS     R0, R6
  0x800'30cc: 0xb00d          ADD      SP, SP, #0x34
  0x800'30ce: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'30d2: 0xbf00          NOP
                `$d.32`:
                ??_txe_thread_create_0:
  0x800'30d4: 0x2000'246c     DC32     _tx_thread_preempt_disable
  0x800'30d8: 0x2000'245c     DC32     _tx_thread_created_ptr
  0x800'30dc: 0x2000'2460     DC32     _tx_thread_created_count
  0x800'30e0: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'30e4: 0x2000'20f0     DC32     _tx_timer_thread
  0x800'30e8: 0x2000'0008     DC32     _tx_thread_system_state
                $t:
                `.text8`:
                _tx_thread_system_preempt_check:
  // VOID  _tx_thread_system_preempt_check(VOID)
  // {
  0x800'30ec: 0xe92d 0x41f0   PUSH.W   {R4-R8, LR}
  //     TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
  0x800'30f0: 0x4834          LDR.N    R0, ??_tx_thread_system_preempt_check_0
                                                              ; _tx_thread_preempt_disable
  0x800'30f2: 0x6805          LDR      R5, [R0]
  //     if (combined_flags == ((ULONG) 0))
  0x800'30f4: 0x2d00          CMP      R5, #0
  0x800'30f6: 0xd163          BNE.N    ??_tx_thread_system_preempt_check_8
                                                              ; 0x800'31c0
  //         TX_THREAD_GET_CURRENT(current_thread)
  0x800'30f8: 0x4833          LDR.N    R0, [PC, #0xcc]        ; _tx_thread_current_ptr
  0x800'30fa: 0x6800          LDR      R0, [R0]
  0x800'30fc: 0x0006          MOVS     R6, R0
  //         thread_ptr =  _tx_thread_execute_ptr;
  0x800'30fe: 0x4833          LDR.N    R0, [PC, #0xcc]        ; _tx_thread_execute_ptr
  0x800'3100: 0x6800          LDR      R0, [R0]
  0x800'3102: 0x0004          MOVS     R4, R0
  //         if (current_thread != thread_ptr)
  0x800'3104: 0x42a6          CMP      R6, R4
  0x800'3106: 0xd05b          BEQ.N    ??_tx_thread_system_preempt_check_8
                                                              ; 0x800'31c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3108: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'310c: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'310e: 0x2c00          CMP      R4, #0
  0x800'3110: 0xd039          BEQ.N    ??_tx_thread_system_preempt_check_2
                                                              ; 0x800'3186
  0x800'3112: 0x6821          LDR      R1, [R4]
  0x800'3114: 0x482e          LDR.N    R0, [PC, #0xb8]        ; 0x5448'5244
  0x800'3116: 0x4281          CMP      R1, R0
  0x800'3118: 0xd135          BNE.N    ??_tx_thread_system_preempt_check_2
                                                              ; 0x800'3186
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'311a: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'311c: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'3120: 0x4281          CMP      R1, R0
  0x800'3122: 0xd202          BCS.N    ??_tx_thread_system_preempt_check_3
                                                              ; 0x800'312a
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'3124: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'3126: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_preempt_check_3:
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'312a: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'312c: 0x6800          LDR      R0, [R0]
  0x800'312e: 0xf8d4 0x10d4   LDR.W    R1, [R4, #0xd4]
  0x800'3132: 0x4288          CMP      R0, R1
  0x800'3134: 0xd10b          BNE.N    ??_tx_thread_system_preempt_check_4
                                                              ; 0x800'314e
  0x800'3136: 0x6920          LDR      R0, [R4, #0x10]
  0x800'3138: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'313c: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'3140: 0x4281          CMP      R1, R0
  0x800'3142: 0xd104          BNE.N    ??_tx_thread_system_preempt_check_4
                                                              ; 0x800'314e
  0x800'3144: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'3148: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'314a: 0x4281          CMP      R1, R0
  0x800'314c: 0xd209          BCS.N    ??_tx_thread_system_preempt_check_5
                                                              ; 0x800'3162
                ??_tx_thread_system_preempt_check_4:
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'314e: 0x46b8          MOV      R8, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3150: 0xf388 0x8810   MSR      PRIMASK, R8
  // }
  0x800'3154: 0x0020          MOVS     R0, R4
  0x800'3156: 0xf7ff 0xf8b3   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'315a: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'315e: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3160: 0x0007          MOVS     R7, R0
                ??_tx_thread_system_preempt_check_5:
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'3162: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'3166: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'316a: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'316e: 0x4281          CMP      R1, R0
  0x800'3170: 0xd009          BEQ.N    ??_tx_thread_system_preempt_check_2
                                                              ; 0x800'3186
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'3172: 0x46b8          MOV      R8, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3174: 0xf388 0x8810   MSR      PRIMASK, R8
  // }
  0x800'3178: 0x0020          MOVS     R0, R4
  0x800'317a: 0xf7ff 0xf8b3   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'317e: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'3182: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3184: 0x0007          MOVS     R7, R0
                ??_tx_thread_system_preempt_check_2:
  //             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'3186: 0x0038          MOVS     R0, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3188: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'318c: 0x2c00          CMP      R4, #0
  0x800'318e: 0xd104          BNE.N    ??_tx_thread_system_preempt_check_6
                                                              ; 0x800'319a
  //                 _tx_thread_performance_idle_return_count++;
  0x800'3190: 0x4910          LDR.N    R1, [PC, #0x40]        ; _tx_thread_performance_idle_return_count
  0x800'3192: 0x6808          LDR      R0, [R1]
  0x800'3194: 0x1c40          ADDS     R0, R0, #1
  0x800'3196: 0x6008          STR      R0, [R1]
  0x800'3198: 0xe003          B.N      ??_tx_thread_system_preempt_check_7
                                                              ; 0x800'31a2
                ??_tx_thread_system_preempt_check_6:
  //                 _tx_thread_performance_non_idle_return_count++;
  0x800'319a: 0x490f          LDR.N    R1, [PC, #0x3c]        ; _tx_thread_performance_non_idle_return_count
  0x800'319c: 0x6808          LDR      R0, [R1]
  0x800'319e: 0x1c40          ADDS     R0, R0, #1
  0x800'31a0: 0x6008          STR      R0, [R1]
                ??_tx_thread_system_preempt_check_7:
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'31a2: 0xf05f 0x5280   MOVS.W   R2, #268435456         ; 0x1000'0000
  0x800'31a6: 0x480d          LDR.N    R0, [PC, #0x34]        ; 0xe000'ed04
  0x800'31a8: 0x6002          STR      R2, [R0]
  //     if (__get_ipsr_value() == 0)
  0x800'31aa: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'31ae: 0x2800          CMP      R0, #0
  0x800'31b0: 0xd106          BNE.N    ??_tx_thread_system_preempt_check_8
                                                              ; 0x800'31c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'31b2: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'31b6: 0x0001          MOVS     R1, R0
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'31b8: 0xb662          CPSIE    i
  // }
  0x800'31ba: 0x0008          MOVS     R0, R1
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'31bc: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_system_preempt_check_1:
                ??_tx_thread_system_preempt_check_8:
  // }
  0x800'31c0: 0xe8bd 0x81f0   POP.W    {R4-R8, PC}
                `$d.32`:
                ??_tx_thread_system_preempt_check_0:
  0x800'31c4: 0x2000'246c     DC32     _tx_thread_preempt_disable
  0x800'31c8: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'31cc: 0x2000'2458     DC32     _tx_thread_execute_ptr
  0x800'31d0: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
  0x800'31d4: 0x2000'2494     DC32     _tx_thread_performance_idle_return_count
  0x800'31d8: 0x2000'2498     DC32     _tx_thread_performance_non_idle_return_count
  0x800'31dc: 0xe000'ed04     DC32     0xe000'ed04            ; '....'
                $t:
                `.text8`:
                _tx_byte_allocate:
  // UINT  _tx_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, ULONG memory_size,  ULONG wait_option)
  // {
  0x800'31e0: 0xe92d 0x4ff8   PUSH.W   {R3-R11, LR}
  0x800'31e4: 0xb084          SUB      SP, SP, #0x10
  0x800'31e6: 0x4683          MOV      R11, R0
  0x800'31e8: 0x000f          MOVS     R7, R1
  0x800'31ea: 0x001e          MOVS     R6, R3
  //     memory_size = (((memory_size + (sizeof(ALIGN_TYPE)))-((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
  0x800'31ec: 0x1cd2          ADDS     R2, R2, #3
  0x800'31ee: 0x0892          LSRS     R2, R2, #2
  0x800'31f0: 0xea5f 0x0882   LSLS.W   R8, R2, #2
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'31f4: 0xf3ef 0x8910   MRS      R9, PRIMASK
  //     return(posture);
  0x800'31f8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'31fa: 0x483a          LDR.N    R0, ??_tx_byte_allocate_0
                                                              ; _tx_thread_current_ptr
  0x800'31fc: 0xf8d0 0xa000   LDR.W    R10, [R0]
  //     finished =  TX_FALSE;
  0x800'3200: 0x2500          MOVS     R5, #0
                ??_tx_byte_allocate_1:
  //         pool_ptr -> tx_byte_pool_owner =  thread_ptr;
  0x800'3202: 0xf8cb 0xa020   STR.W    R10, [R11, #0x20]
  //         TX_RESTORE
  0x800'3206: 0xf8cd 0x900c   STR.W    R9, [SP, #0xc]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'320a: 0x9803          LDR      R0, [SP, #0xc]
  0x800'320c: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'3210: 0x4641          MOV      R1, R8
  0x800'3212: 0x4658          MOV      R0, R11
  0x800'3214: 0xf7ff 0xfd06   BL       _tx_byte_pool_search   ; 0x800'2c24
  0x800'3218: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'321a: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'321e: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3220: 0x4681          MOV      R9, R0
  //         if (work_ptr != TX_NULL)
  0x800'3222: 0x2c00          CMP      R4, #0
  0x800'3224: 0xd002          BEQ.N    ??_tx_byte_allocate_2  ; 0x800'322c
  //             finished =  TX_TRUE;
  0x800'3226: 0x2001          MOVS     R0, #1
  0x800'3228: 0x0005          MOVS     R5, R0
  0x800'322a: 0xe005          B.N      ??_tx_byte_allocate_3  ; 0x800'3238
                ??_tx_byte_allocate_2:
  //             if (pool_ptr -> tx_byte_pool_owner == thread_ptr)
  0x800'322c: 0xf8db 0x0020   LDR.W    R0, [R11, #0x20]
  0x800'3230: 0x4550          CMP      R0, R10
  0x800'3232: 0xd101          BNE.N    ??_tx_byte_allocate_3  ; 0x800'3238
  //                 finished =  TX_TRUE;
  0x800'3234: 0x2001          MOVS     R0, #1
  0x800'3236: 0x0005          MOVS     R5, R0
                ??_tx_byte_allocate_3:
  //     } while (finished == TX_FALSE);
  0x800'3238: 0x2d00          CMP      R5, #0
  0x800'323a: 0xd0e2          BEQ.N    ??_tx_byte_allocate_1  ; 0x800'3202
  //     *memory_ptr =  (VOID *) work_ptr;
  0x800'323c: 0x603c          STR      R4, [R7]
  //     if (work_ptr != TX_NULL)
  0x800'323e: 0x2c00          CMP      R4, #0
  0x800'3240: 0xd004          BEQ.N    ??_tx_byte_allocate_4  ; 0x800'324c
  //         TX_RESTORE
  0x800'3242: 0x4649          MOV      R1, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3244: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'3248: 0x2000          MOVS     R0, #0
  0x800'324a: 0xe048          B.N      ??_tx_byte_allocate_5  ; 0x800'32de
                ??_tx_byte_allocate_4:
  //         if (wait_option != TX_NO_WAIT)
  0x800'324c: 0x2e00          CMP      R6, #0
  0x800'324e: 0xd042          BEQ.N    ??_tx_byte_allocate_6  ; 0x800'32d6
  //             if (_tx_thread_preempt_disable != ((UINT) 0))
  0x800'3250: 0x4825          LDR.N    R0, [PC, #0x94]        ; _tx_thread_preempt_disable
  0x800'3252: 0x6800          LDR      R0, [R0]
  0x800'3254: 0x2800          CMP      R0, #0
  0x800'3256: 0xd004          BEQ.N    ??_tx_byte_allocate_7  ; 0x800'3262
  //                 status =  TX_NO_MEMORY;
  0x800'3258: 0x2010          MOVS     R0, #16                ; 0x10
  //                 TX_RESTORE
  0x800'325a: 0x4649          MOV      R1, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'325c: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'3260: 0xe03d          B.N      ??_tx_byte_allocate_5  ; 0x800'32de
                ??_tx_byte_allocate_7:
  //                 thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_byte_pool_cleanup);
  0x800'3262: 0x4822          LDR.N    R0, [PC, #0x88]        ; _tx_byte_pool_cleanup
  0x800'3264: 0xf8ca 0x0068   STR.W    R0, [R10, #0x68]
  //                 thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
  0x800'3268: 0xf8ca 0xb06c   STR.W    R11, [R10, #0x6c]
  //                 thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) memory_ptr;
  0x800'326c: 0xf8ca 0x707c   STR.W    R7, [R10, #0x7c]
  //                 thread_ptr -> tx_thread_suspend_info =  memory_size;
  0x800'3270: 0xf8ca 0x8078   STR.W    R8, [R10, #0x78]
  //                 suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
  0x800'3274: 0xf8db 0x0028   LDR.W    R0, [R11, #0x28]
  0x800'3278: 0x9002          STR      R0, [SP, #0x8]
  //                 (pool_ptr -> tx_byte_pool_suspended_count)++;
  0x800'327a: 0xf8db 0x0028   LDR.W    R0, [R11, #0x28]
  0x800'327e: 0x1c40          ADDS     R0, R0, #1
  0x800'3280: 0xf8cb 0x0028   STR.W    R0, [R11, #0x28]
  //                 if (suspended_count == TX_NO_SUSPENSIONS)
  0x800'3284: 0x9802          LDR      R0, [SP, #0x8]
  0x800'3286: 0x2800          CMP      R0, #0
  0x800'3288: 0xd106          BNE.N    ??_tx_byte_allocate_8  ; 0x800'3298
  //                     pool_ptr -> tx_byte_pool_suspension_list =      thread_ptr;
  0x800'328a: 0xf8cb 0xa024   STR.W    R10, [R11, #0x24]
  //                     thread_ptr -> tx_thread_suspended_next =        thread_ptr;
  0x800'328e: 0xf8ca 0xa070   STR.W    R10, [R10, #0x70]
  //                     thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
  0x800'3292: 0xf8ca 0xa074   STR.W    R10, [R10, #0x74]
  0x800'3296: 0xe011          B.N      ??_tx_byte_allocate_9  ; 0x800'32bc
                ??_tx_byte_allocate_8:
  //                     next_thread =                                   pool_ptr -> tx_byte_pool_suspension_list;
  0x800'3298: 0xf8db 0x0024   LDR.W    R0, [R11, #0x24]
  0x800'329c: 0x9000          STR      R0, [SP]
  //                     thread_ptr -> tx_thread_suspended_next =        next_thread;
  0x800'329e: 0x9800          LDR      R0, [SP]
  0x800'32a0: 0xf8ca 0x0070   STR.W    R0, [R10, #0x70]
  //                     previous_thread =                               next_thread -> tx_thread_suspended_previous;
  0x800'32a4: 0x9800          LDR      R0, [SP]
  0x800'32a6: 0x6f40          LDR      R0, [R0, #0x74]
  0x800'32a8: 0x9001          STR      R0, [SP, #0x4]
  //                     thread_ptr -> tx_thread_suspended_previous =    previous_thread;
  0x800'32aa: 0x9801          LDR      R0, [SP, #0x4]
  0x800'32ac: 0xf8ca 0x0074   STR.W    R0, [R10, #0x74]
  //                     previous_thread -> tx_thread_suspended_next =   thread_ptr;
  0x800'32b0: 0x9801          LDR      R0, [SP, #0x4]
  0x800'32b2: 0xf8c0 0xa070   STR.W    R10, [R0, #0x70]
  //                     next_thread -> tx_thread_suspended_previous =   thread_ptr;
  0x800'32b6: 0x9800          LDR      R0, [SP]
  0x800'32b8: 0xf8c0 0xa074   STR.W    R10, [R0, #0x74]
                ??_tx_byte_allocate_9:
  //                 thread_ptr -> tx_thread_state =       TX_BYTE_MEMORY;
  0x800'32bc: 0x2009          MOVS     R0, #9
  0x800'32be: 0xf8ca 0x0030   STR.W    R0, [R10, #0x30]
  //                 _tx_thread_system_ni_suspend(thread_ptr, wait_option);
  0x800'32c2: 0x0031          MOVS     R1, R6
  0x800'32c4: 0x4650          MOV      R0, R10
  0x800'32c6: 0xf7ff 0xf859   BL       _tx_thread_system_ni_suspend
                                                              ; 0x800'237c
  //                 TX_RESTORE
  0x800'32ca: 0x4649          MOV      R1, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'32cc: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'32d0: 0xf8da 0x0084   LDR.W    R0, [R10, #0x84]
  0x800'32d4: 0xe003          B.N      ??_tx_byte_allocate_5  ; 0x800'32de
                ??_tx_byte_allocate_6:
  //             TX_RESTORE
  0x800'32d6: 0x4649          MOV      R1, R9
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'32d8: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'32dc: 0x2010          MOVS     R0, #16                ; 0x10
                ??_tx_byte_allocate_5:
  //     return(status);
  0x800'32de: 0xb005          ADD      SP, SP, #0x14
  0x800'32e0: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
                `$d.32`:
                ??_tx_byte_allocate_0:
  0x800'32e4: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'32e8: 0x2000'246c     DC32     _tx_thread_preempt_disable
  0x800'32ec: 0x0800'3c99     DC32     _tx_byte_pool_cleanup
                $t:
                `.text8`:
                _tx_byte_pool_create:
  // UINT  _tx_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size)
  // {
  0x800'32f0: 0xe92d 0x4ff8   PUSH.W   {R3-R11, LR}
  0x800'32f4: 0xb084          SUB      SP, SP, #0x10
  0x800'32f6: 0x4681          MOV      R9, R0
  0x800'32f8: 0x000c          MOVS     R4, R1
  0x800'32fa: 0x0015          MOVS     R5, R2
  0x800'32fc: 0x469b          MOV      R11, R3
  //     TX_MEMSET(pool_ptr, 0, (sizeof(TX_BYTE_POOL)));
  0x800'32fe: 0x2734          MOVS     R7, #52                ; 0x34
  0x800'3300: 0xf05f 0x0800   MOVS.W   R8, #0
  0x800'3304: 0x46ca          MOV      R10, R9
  //     __aeabi_memset(_D, _N, _C);
  0x800'3306: 0x4642          MOV      R2, R8
  0x800'3308: 0x0039          MOVS     R1, R7
  0x800'330a: 0x4650          MOV      R0, R10
  0x800'330c: 0xf7fe 0xfa26   BL       __aeabi_memset         ; 0x800'175c
  //     return _D;
  0x800'3310: 0xea5f 0x0b9b   LSRS.W   R11, R11, #2
  0x800'3314: 0xea5f 0x018b   LSLS.W   R1, R11, #2
  //     pool_ptr -> tx_byte_pool_name =              name_ptr;
  0x800'3318: 0xf8c9 0x4004   STR.W    R4, [R9, #0x4]
  //     pool_ptr -> tx_byte_pool_start =   TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'331c: 0xf8c9 0x5018   STR.W    R5, [R9, #0x18]
  //     pool_ptr -> tx_byte_pool_size =    pool_size;
  0x800'3320: 0xf8c9 0x101c   STR.W    R1, [R9, #0x1c]
  //     pool_ptr -> tx_byte_pool_list =    TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'3324: 0xf8c9 0x5010   STR.W    R5, [R9, #0x10]
  //     pool_ptr -> tx_byte_pool_search =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'3328: 0xf8c9 0x5014   STR.W    R5, [R9, #0x14]
  //     pool_ptr -> tx_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
  0x800'332c: 0xf1b1 0x0008   SUBS.W   R0, R1, #8
  0x800'3330: 0xf8c9 0x0008   STR.W    R0, [R9, #0x8]
  //     pool_ptr -> tx_byte_pool_fragments =   ((UINT) 2);
  0x800'3334: 0x2002          MOVS     R0, #2
  0x800'3336: 0xf8c9 0x000c   STR.W    R0, [R9, #0xc]
  //     block_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'333a: 0x0028          MOVS     R0, R5
  //     block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, pool_size);
  0x800'333c: 0x4408          ADD      R0, R0, R1
  //     block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));
  0x800'333e: 0x1f00          SUBS     R0, R0, #4
  //     temp_ptr =             TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
  0x800'3340: 0x464a          MOV      R2, R9
  //     block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
  0x800'3342: 0x9000          STR      R0, [SP]
  //     *block_indirect_ptr =  temp_ptr;
  0x800'3344: 0x9b00          LDR      R3, [SP]
  0x800'3346: 0x601a          STR      R2, [R3]
  //     block_ptr =            TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
  0x800'3348: 0xf1b0 0x0e04   SUBS.W   LR, R0, #4
  //     block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
  0x800'334c: 0x4673          MOV      R3, LR
  //     *block_indirect_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'334e: 0x601d          STR      R5, [R3]
  //     temp_ptr =             TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'3350: 0x9503          STR      R5, [SP, #0xc]
  //     block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
  0x800'3352: 0x9803          LDR      R0, [SP, #0xc]
  0x800'3354: 0x9000          STR      R0, [SP]
  //     *block_indirect_ptr =  block_ptr;
  0x800'3356: 0x9800          LDR      R0, [SP]
  0x800'3358: 0xf8c0 0xe000   STR.W    LR, [R0]
  //     block_ptr =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
  0x800'335c: 0x0028          MOVS     R0, R5
  //     block_ptr =            TX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
  0x800'335e: 0xf110 0x0a04   ADDS.W   R10, R0, #4
  //     free_ptr =             TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
  0x800'3362: 0xf8cd 0xa008   STR.W    R10, [SP, #0x8]
  //     *free_ptr =            TX_BYTE_BLOCK_FREE;
  0x800'3366: 0xf8df 0xc06c   LDR.W    R12, ??_tx_byte_pool_create_0
                                                              ; 0xffff'eeee
  0x800'336a: 0x9802          LDR      R0, [SP, #0x8]
  0x800'336c: 0xf8c0 0xc000   STR.W    R12, [R0]
  //     pool_ptr -> tx_byte_pool_owner =  TX_NULL;
  0x800'3370: 0x2000          MOVS     R0, #0
  0x800'3372: 0xf8c9 0x0020   STR.W    R0, [R9, #0x20]
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3376: 0xf3ef 0x8c10   MRS      R12, PRIMASK
  //     return(posture);
  0x800'337a: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'337c: 0x4816          LDR.N    R0, [PC, #0x58]        ; 0x4259'5445
  0x800'337e: 0xf8c9 0x0000   STR.W    R0, [R9]
  //     if (_tx_byte_pool_created_count == TX_EMPTY)
  0x800'3382: 0xf8df 0xb058   LDR.W    R11, [PC, #0x58]       ; _tx_byte_pool_created_count
  0x800'3386: 0xf8db 0x0000   LDR.W    R0, [R11]
  0x800'338a: 0x2800          CMP      R0, #0
  0x800'338c: 0xd107          BNE.N    ??_tx_byte_pool_create_1
                                                              ; 0x800'339e
  //         _tx_byte_pool_created_ptr =                  pool_ptr;
  0x800'338e: 0x4814          LDR.N    R0, [PC, #0x50]        ; _tx_byte_pool_created_ptr
  0x800'3390: 0xf8c0 0x9000   STR.W    R9, [R0]
  //         pool_ptr -> tx_byte_pool_created_next =      pool_ptr;
  0x800'3394: 0xf8c9 0x902c   STR.W    R9, [R9, #0x2c]
  //         pool_ptr -> tx_byte_pool_created_previous =  pool_ptr;
  0x800'3398: 0xf8c9 0x9030   STR.W    R9, [R9, #0x30]
  0x800'339c: 0xe00e          B.N      ??_tx_byte_pool_create_2
                                                              ; 0x800'33bc
                ??_tx_byte_pool_create_1:
  //         next_pool =      _tx_byte_pool_created_ptr;
  0x800'339e: 0x4810          LDR.N    R0, [PC, #0x40]        ; _tx_byte_pool_created_ptr
  0x800'33a0: 0x6800          LDR      R0, [R0]
  0x800'33a2: 0x0006          MOVS     R6, R0
  //         previous_pool =  next_pool -> tx_byte_pool_created_previous;
  0x800'33a4: 0x6b32          LDR      R2, [R6, #0x30]
  0x800'33a6: 0x9201          STR      R2, [SP, #0x4]
  //         next_pool -> tx_byte_pool_created_previous =  pool_ptr;
  0x800'33a8: 0xf8c6 0x9030   STR.W    R9, [R6, #0x30]
  //         previous_pool -> tx_byte_pool_created_next =  pool_ptr;
  0x800'33ac: 0x9801          LDR      R0, [SP, #0x4]
  0x800'33ae: 0xf8c0 0x902c   STR.W    R9, [R0, #0x2c]
  //         pool_ptr -> tx_byte_pool_created_previous =  previous_pool;
  0x800'33b2: 0x9801          LDR      R0, [SP, #0x4]
  0x800'33b4: 0xf8c9 0x0030   STR.W    R0, [R9, #0x30]
  //         pool_ptr -> tx_byte_pool_created_next =      next_pool;
  0x800'33b8: 0xf8c9 0x602c   STR.W    R6, [R9, #0x2c]
                ??_tx_byte_pool_create_2:
  //     _tx_byte_pool_created_count++;
  0x800'33bc: 0xf8db 0x0000   LDR.W    R0, [R11]
  0x800'33c0: 0x1c40          ADDS     R0, R0, #1
  0x800'33c2: 0xf8cb 0x0000   STR.W    R0, [R11]
  //     TX_RESTORE
  0x800'33c6: 0x4662          MOV      R2, R12
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'33c8: 0xf382 0x8810   MSR      PRIMASK, R2
  // }
  0x800'33cc: 0x2000          MOVS     R0, #0
  0x800'33ce: 0xb005          ADD      SP, SP, #0x14
  0x800'33d0: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
                `$d.32`:
                ??_tx_byte_pool_create_0:
  0x800'33d4: 0xffff'eeee     DC32     -4370                  ; '....'
  0x800'33d8: 0x4259'5445     DC32     0x4259'5445            ; 'ETYB'
  0x800'33dc: 0x2000'2448     DC32     _tx_byte_pool_created_count
  0x800'33e0: 0x2000'2444     DC32     _tx_byte_pool_created_ptr
                $t:
                `.text8`:
                _txe_byte_pool_create:
  // UINT  _txe_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size, UINT pool_control_block_size)
  // {
  0x800'33e4: 0xe92d 0x4ff2   PUSH.W   {R1, R4-R11, LR}
  0x800'33e8: 0xb082          SUB      SP, SP, #0x8
  0x800'33ea: 0x0004          MOVS     R4, R0
  0x800'33ec: 0x0015          MOVS     R5, R2
  0x800'33ee: 0x469b          MOV      R11, R3
  //     status =  TX_SUCCESS;
  0x800'33f0: 0x2600          MOVS     R6, #0
  //     if (pool_ptr == TX_NULL)
  0x800'33f2: 0x2c00          CMP      R4, #0
  0x800'33f4: 0xd102          BNE.N    ??_txe_byte_pool_create_1
                                                              ; 0x800'33fc
  //         status =  TX_POOL_ERROR;
  0x800'33f6: 0x2002          MOVS     R0, #2
  0x800'33f8: 0x0006          MOVS     R6, R0
  0x800'33fa: 0xe054          B.N      ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
                ??_txe_byte_pool_create_1:
  //     else if (pool_control_block_size != (sizeof(TX_BYTE_POOL)))
  0x800'33fc: 0x980c          LDR      R0, [SP, #0x30]
  0x800'33fe: 0x2834          CMP      R0, #52                ; 0x34
  0x800'3400: 0xd002          BEQ.N    ??_txe_byte_pool_create_3
                                                              ; 0x800'3408
  //         status =  TX_POOL_ERROR;
  0x800'3402: 0x2002          MOVS     R0, #2
  0x800'3404: 0x0006          MOVS     R6, R0
  0x800'3406: 0xe04e          B.N      ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
                ??_txe_byte_pool_create_3:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3408: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'340c: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'340e: 0x482c          LDR.N    R0, ??_txe_byte_pool_create_0
                                                              ; _tx_thread_preempt_disable
  0x800'3410: 0x6801          LDR      R1, [R0]
  0x800'3412: 0x1c49          ADDS     R1, R1, #1
  0x800'3414: 0x6001          STR      R1, [R0]
  //         TX_RESTORE
  0x800'3416: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3418: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'341c: 0x4a29          LDR.N    R2, [PC, #0xa4]        ; _tx_byte_pool_created_ptr
  0x800'341e: 0x6812          LDR      R2, [R2]
  0x800'3420: 0x4691          MOV      R9, R2
  //         for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
  0x800'3422: 0x2200          MOVS     R2, #0
  0x800'3424: 0x4690          MOV      R8, R2
                ??_txe_byte_pool_create_4:
  //         for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
  0x800'3426: 0x4928          LDR.N    R1, [PC, #0xa0]        ; _tx_byte_pool_created_count
  0x800'3428: 0x6809          LDR      R1, [R1]
  0x800'342a: 0x4588          CMP      R8, R1
  0x800'342c: 0xd206          BCS.N    ??_txe_byte_pool_create_5
                                                              ; 0x800'343c
  //             if (pool_ptr == next_pool)
  0x800'342e: 0x454c          CMP      R4, R9
  0x800'3430: 0xd004          BEQ.N    ??_txe_byte_pool_create_5
                                                              ; 0x800'343c
                ??_txe_byte_pool_create_6:
  //                 next_pool =  next_pool -> tx_byte_pool_created_next;
  0x800'3432: 0xf8d9 0x902c   LDR.W    R9, [R9, #0x2c]
  //         for (i = ((ULONG) 0); i < _tx_byte_pool_created_count; i++)
  0x800'3436: 0xf118 0x0801   ADDS.W   R8, R8, #1
  0x800'343a: 0xe7f4          B.N      ??_txe_byte_pool_create_4
                                                              ; 0x800'3426
                ??_txe_byte_pool_create_5:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'343c: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'3440: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3442: 0x6801          LDR      R1, [R0]
  0x800'3444: 0x1e49          SUBS     R1, R1, #1
  0x800'3446: 0x6001          STR      R1, [R0]
  //         TX_RESTORE
  0x800'3448: 0x9701          STR      R7, [SP, #0x4]
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'344a: 0x9801          LDR      R0, [SP, #0x4]
  0x800'344c: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'3450: 0xf7ff 0xfe4c   BL       _tx_thread_system_preempt_check
                                                              ; 0x800'30ec
  //         if (pool_ptr == next_pool)
  0x800'3454: 0x454c          CMP      R4, R9
  0x800'3456: 0xd102          BNE.N    ??_txe_byte_pool_create_7
                                                              ; 0x800'345e
  //             status =  TX_POOL_ERROR;
  0x800'3458: 0x2002          MOVS     R0, #2
  0x800'345a: 0x0006          MOVS     R6, R0
  0x800'345c: 0xe023          B.N      ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
                ??_txe_byte_pool_create_7:
  //         else if (pool_start == TX_NULL)
  0x800'345e: 0x2d00          CMP      R5, #0
  0x800'3460: 0xd102          BNE.N    ??_txe_byte_pool_create_8
                                                              ; 0x800'3468
  //             status =  TX_PTR_ERROR;
  0x800'3462: 0x2003          MOVS     R0, #3
  0x800'3464: 0x0006          MOVS     R6, R0
  0x800'3466: 0xe01e          B.N      ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
                ??_txe_byte_pool_create_8:
  //         else if (pool_size < TX_BYTE_POOL_MIN)
  0x800'3468: 0xf1bb 0x0f64   CMP.W    R11, #100              ; 0x64
  0x800'346c: 0xd202          BCS.N    ??_txe_byte_pool_create_9
                                                              ; 0x800'3474
  //             status =  TX_SIZE_ERROR;
  0x800'346e: 0x2005          MOVS     R0, #5
  0x800'3470: 0x0006          MOVS     R6, R0
  0x800'3472: 0xe018          B.N      ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
                ??_txe_byte_pool_create_9:
  //             TX_THREAD_GET_CURRENT(thread_ptr)
  0x800'3474: 0x4815          LDR.N    R0, [PC, #0x54]        ; _tx_thread_current_ptr
  0x800'3476: 0x6800          LDR      R0, [R0]
  0x800'3478: 0x9000          STR      R0, [SP]
  //             if (thread_ptr == &_tx_timer_thread)
  0x800'347a: 0x9800          LDR      R0, [SP]
  0x800'347c: 0x4914          LDR.N    R1, [PC, #0x50]        ; _tx_timer_thread
  0x800'347e: 0x4288          CMP      R0, R1
  0x800'3480: 0xd101          BNE.N    ??_txe_byte_pool_create_10
                                                              ; 0x800'3486
  //                 status =  TX_CALLER_ERROR;
  0x800'3482: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'3484: 0x0006          MOVS     R6, R0
                ??_txe_byte_pool_create_10:
  //             if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  0x800'3486: 0x4a13          LDR.N    R2, [PC, #0x4c]        ; _tx_thread_system_state
  0x800'3488: 0x6810          LDR      R0, [R2]
  0x800'348a: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'348e: 0x4308          ORRS     R0, R0, R1
  0x800'3490: 0x2800          CMP      R0, #0
  0x800'3492: 0xd008          BEQ.N    ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
  //                 if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  0x800'3494: 0x6811          LDR      R1, [R2]
  0x800'3496: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'349a: 0x4301          ORRS     R1, R1, R0
  0x800'349c: 0xf1b1 0x3ff0   CMP.W    R1, #-252645136        ; 0xf0f0'f0f0
  0x800'34a0: 0xd201          BCS.N    ??_txe_byte_pool_create_2
                                                              ; 0x800'34a6
  //                     status =  TX_CALLER_ERROR;
  0x800'34a2: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'34a4: 0x0006          MOVS     R6, R0
                ??_txe_byte_pool_create_2:
  //     if (status == TX_SUCCESS)
  0x800'34a6: 0x2e00          CMP      R6, #0
  0x800'34a8: 0xd106          BNE.N    ??_txe_byte_pool_create_11
                                                              ; 0x800'34b8
  //         status =  _tx_byte_pool_create(pool_ptr, name_ptr, pool_start, pool_size);
  0x800'34aa: 0x465b          MOV      R3, R11
  0x800'34ac: 0x002a          MOVS     R2, R5
  0x800'34ae: 0x9902          LDR      R1, [SP, #0x8]
  0x800'34b0: 0x0020          MOVS     R0, R4
  0x800'34b2: 0xf7ff 0xff1d   BL       _tx_byte_pool_create   ; 0x800'32f0
  0x800'34b6: 0x0006          MOVS     R6, R0
                ??_txe_byte_pool_create_11:
  //     return(status);
  0x800'34b8: 0x0030          MOVS     R0, R6
  0x800'34ba: 0xe8bd 0x8ffe   POP.W    {R1-R11, PC}
  0x800'34be: 0xbf00          NOP
                `$d.32`:
                ??_txe_byte_pool_create_0:
  0x800'34c0: 0x2000'246c     DC32     _tx_thread_preempt_disable
  0x800'34c4: 0x2000'2444     DC32     _tx_byte_pool_created_ptr
  0x800'34c8: 0x2000'2448     DC32     _tx_byte_pool_created_count
  0x800'34cc: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'34d0: 0x2000'20f0     DC32     _tx_timer_thread
  0x800'34d4: 0x2000'0008     DC32     _tx_thread_system_state
                $t:
                `.text8`:
                __write:
  // size_t __write(int handle, const unsigned char * buffer, size_t size) {
  0x800'34d8: 0xb570          PUSH     {R4-R6, LR}
  0x800'34da: 0x0006          MOVS     R6, R0
  0x800'34dc: 0x000c          MOVS     R4, R1
  0x800'34de: 0x0015          MOVS     R5, R2
  //     if(HAL_UART_Transmit(&huart1, (uint8_t *)buffer, size, 0xFFFF) == HAL_OK) {
  0x800'34e0: 0xf64f 0x73ff   MOVW     R3, #65535             ; 0xffff
  0x800'34e4: 0x002a          MOVS     R2, R5
  0x800'34e6: 0xb292          UXTH     R2, R2
  0x800'34e8: 0x0021          MOVS     R1, R4
  0x800'34ea: 0x482c          LDR.N    R0, ??DataTable10      ; huart1
  0x800'34ec: 0xf7fc 0xfef7   BL       HAL_UART_Transmit      ; 0x800'02de
  0x800'34f0: 0x2800          CMP      R0, #0
  0x800'34f2: 0xd101          BNE.N    ??__write_0            ; 0x800'34f8
  //         return size;
  0x800'34f4: 0x0028          MOVS     R0, R5
  0x800'34f6: 0xe001          B.N      ??__write_1            ; 0x800'34fc
                ??__write_0:
  //         return _LLIO_ERROR;
  0x800'34f8: 0xf05f 0x30ff   MOVS.W   R0, #-1                ; 0xffff'ffff
                ??__write_1:
  0x800'34fc: 0xbd70          POP      {R4-R6, PC}
                `.text_23`:
                tx_task_entry:
  // static void tx_task_entry(ULONG thread_input) {
  0x800'34fe: 0xb538          PUSH     {R3-R5, LR}
  0x800'3500: 0x0005          MOVS     R5, R0
  //     int counter = 0;
  0x800'3502: 0x2400          MOVS     R4, #0
                ??tx_task_entry_0:
  //         printf("hello threadx %d\r\n", counter++);
  0x800'3504: 0x0021          MOVS     R1, R4
  0x800'3506: 0x4826          LDR.N    R0, ??DataTable10_8    ; ?_1
  0x800'3508: 0xf7fd 0xfe5a   BL       printf                 ; 0x800'11c0
  0x800'350c: 0x1c64          ADDS     R4, R4, #1
  //         tx_thread_sleep(1000);
  0x800'350e: 0xf44f 0x707a   MOV.W    R0, #1000              ; 0x3e8
  0x800'3512: 0xf000 0xf855   BL       _tx_thread_sleep       ; 0x800'35c0
  0x800'3516: 0xe7f5          B.N      ??tx_task_entry_0      ; 0x800'3504
                `.text_24`:
                tx_application_define:
  // void tx_application_define(void *first_unused_memory) {
  0x800'3518: 0xb538          PUSH     {R3-R5, LR}
  0x800'351a: 0xb088          SUB      SP, SP, #0x20
  0x800'351c: 0x0004          MOVS     R4, R0
  //     CHAR *tx_stack = TX_NULL;
  0x800'351e: 0x2000          MOVS     R0, #0
  0x800'3520: 0x9007          STR      R0, [SP, #0x1c]
  //     tx_byte_pool_create(&tx_pool, "tx_pool", tx_memory, sizeof(tx_memory));
  0x800'3522: 0x4d20          LDR.N    R5, ??DataTable10_9    ; `tx_application_define::tx_pool`
  0x800'3524: 0x2034          MOVS     R0, #52                ; 0x34
  0x800'3526: 0x9000          STR      R0, [SP]
  0x800'3528: 0xf44f 0x5380   MOV.W    R3, #4096              ; 0x1000
  0x800'352c: 0x4a1e          LDR.N    R2, ??DataTable10_10   ; `tx_application_define::tx_memory`
  0x800'352e: 0x491f          LDR.N    R1, ??DataTable10_11   ; ?_2
  0x800'3530: 0x0028          MOVS     R0, R5
  0x800'3532: 0xf7ff 0xff57   BL       _txe_byte_pool_create  ; 0x800'33e4
  //     tx_byte_allocate(&tx_pool, (VOID **) &tx_stack, 1024, TX_NO_WAIT);
  0x800'3536: 0x2300          MOVS     R3, #0
  0x800'3538: 0xf44f 0x6280   MOV.W    R2, #1024              ; 0x400
  0x800'353c: 0xa907          ADD      R1, SP, #0x1c
  0x800'353e: 0x0028          MOVS     R0, R5
  0x800'3540: 0xf000 0xf884   BL       _txe_byte_allocate     ; 0x800'364c
  //     tx_thread_create(&tx_task, "tx_task", tx_task_entry, 0, tx_stack, 1024, 1, 1, 10, TX_AUTO_START);
  0x800'3544: 0x20d8          MOVS     R0, #216               ; 0xd8
  0x800'3546: 0x9006          STR      R0, [SP, #0x18]
  0x800'3548: 0x2001          MOVS     R0, #1
  0x800'354a: 0x9005          STR      R0, [SP, #0x14]
  0x800'354c: 0x200a          MOVS     R0, #10                ; 0xa
  0x800'354e: 0x9004          STR      R0, [SP, #0x10]
  0x800'3550: 0x2001          MOVS     R0, #1
  0x800'3552: 0x9003          STR      R0, [SP, #0xc]
  0x800'3554: 0x2001          MOVS     R0, #1
  0x800'3556: 0x9002          STR      R0, [SP, #0x8]
  0x800'3558: 0xf44f 0x6080   MOV.W    R0, #1024              ; 0x400
  0x800'355c: 0x9001          STR      R0, [SP, #0x4]
  0x800'355e: 0x9807          LDR      R0, [SP, #0x1c]
  0x800'3560: 0x9000          STR      R0, [SP]
  0x800'3562: 0x2300          MOVS     R3, #0
  0x800'3564: 0x4a12          LDR.N    R2, ??DataTable10_12   ; tx_task_entry
  0x800'3566: 0x4913          LDR.N    R1, ??DataTable10_13   ; ?_3
  0x800'3568: 0x4813          LDR.N    R0, ??DataTable10_14   ; `tx_application_define::tx_task`
  0x800'356a: 0xf7ff 0xfcf7   BL       _txe_thread_create     ; 0x800'2f5c
  //     tx_block_release(tx_stack);
  0x800'356e: 0x9807          LDR      R0, [SP, #0x1c]
  0x800'3570: 0xf000 0xf8cc   BL       _txe_block_release     ; 0x800'370c
  // }
  0x800'3574: 0xb009          ADD      SP, SP, #0x24
  0x800'3576: 0xbd30          POP      {R4, R5, PC}
                `.text_25`:
                main:
  // int main(void) {
  0x800'3578: 0xb580          PUSH     {R7, LR}
  //     HAL_Init();
  0x800'357a: 0xf000 0xf8e3   BL       HAL_Init               ; 0x800'3744
  //     MX_GPIO_Init();
  0x800'357e: 0xf000 0xf8fb   BL       MX_GPIO_Init           ; 0x800'3778
  //     MX_USART1_UART_Init();
  0x800'3582: 0xf7fd 0xfbfb   BL       MX_USART1_UART_Init    ; 0x800'0d7c
  //     tx_kernel_enter();
  0x800'3586: 0xf000 0xf91f   BL       _tx_initialize_kernel_enter
                                                              ; 0x800'37c8
                ??main_0:
  //         printf("hello qemu.\r\n");
  0x800'358a: 0x480c          LDR.N    R0, ??DataTable10_15   ; ?_4
  0x800'358c: 0xf7fd 0xfe18   BL       printf                 ; 0x800'11c0
  //         HAL_Delay(1000);
  0x800'3590: 0xf44f 0x707a   MOV.W    R0, #1000              ; 0x3e8
  0x800'3594: 0xf000 0xf93c   BL       HAL_Delay              ; 0x800'3810
  0x800'3598: 0xe7f7          B.N      ??main_0               ; 0x800'358a
  0x800'359a: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable10:
  0x800'359c: 0x2000'234c     DC32     huart1
                ??DataTable10_8:
  0x800'35a0: 0x0800'3fe0     DC32     ?_1
                ??DataTable10_9:
  0x800'35a4: 0x2000'23dc     DC32     `tx_application_define::tx_pool`
                ??DataTable10_10:
  0x800'35a8: 0x2000'0018     DC32     `tx_application_define::tx_memory`
                ??DataTable10_11:
  0x800'35ac: 0x0800'40b0     DC32     ?_2
                ??DataTable10_12:
  0x800'35b0: 0x0800'34ff     DC32     tx_task_entry
                ??DataTable10_13:
  0x800'35b4: 0x0800'40b8     DC32     ?_3
                ??DataTable10_14:
  0x800'35b8: 0x2000'2018     DC32     `tx_application_define::tx_task`
                ??DataTable10_15:
  0x800'35bc: 0x0800'4044     DC32     ?_4
                $t:
                `.text8`:
                _tx_thread_sleep:
  // UINT  _tx_thread_sleep(ULONG timer_ticks)
  // {
  0x800'35c0: 0xb570          PUSH     {R4-R6, LR}
  0x800'35c2: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'35c4: 0xf3ef 0x8610   MRS      R6, PRIMASK
  //     return(posture);
  0x800'35c8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'35ca: 0x481c          LDR.N    R0, ??_tx_thread_sleep_0
                                                              ; _tx_thread_current_ptr
  0x800'35cc: 0x6805          LDR      R5, [R0]
  //     if (thread_ptr == TX_NULL)
  0x800'35ce: 0x2d00          CMP      R5, #0
  0x800'35d0: 0xd104          BNE.N    ??_tx_thread_sleep_1   ; 0x800'35dc
  //         TX_RESTORE
  0x800'35d2: 0x0031          MOVS     R1, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'35d4: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'35d8: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'35da: 0xe02e          B.N      ??_tx_thread_sleep_2   ; 0x800'363a
                ??_tx_thread_sleep_1:
  //     else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  0x800'35dc: 0x4818          LDR.N    R0, [PC, #0x60]        ; _tx_thread_system_state
  0x800'35de: 0x6800          LDR      R0, [R0]
  0x800'35e0: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'35e4: 0x4308          ORRS     R0, R0, R1
  0x800'35e6: 0x2800          CMP      R0, #0
  0x800'35e8: 0xd004          BEQ.N    ??_tx_thread_sleep_3   ; 0x800'35f4
  //         TX_RESTORE
  0x800'35ea: 0x0031          MOVS     R1, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'35ec: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'35f0: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'35f2: 0xe022          B.N      ??_tx_thread_sleep_2   ; 0x800'363a
                ??_tx_thread_sleep_3:
  //     else if (thread_ptr == &_tx_timer_thread)
  0x800'35f4: 0x4813          LDR.N    R0, [PC, #0x4c]        ; _tx_timer_thread
  0x800'35f6: 0x4285          CMP      R5, R0
  0x800'35f8: 0xd104          BNE.N    ??_tx_thread_sleep_4   ; 0x800'3604
  //         TX_RESTORE
  0x800'35fa: 0x0031          MOVS     R1, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'35fc: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'3600: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'3602: 0xe01a          B.N      ??_tx_thread_sleep_2   ; 0x800'363a
                ??_tx_thread_sleep_4:
  //     else if (timer_ticks == ((ULONG) 0))
  0x800'3604: 0x2c00          CMP      R4, #0
  0x800'3606: 0xd104          BNE.N    ??_tx_thread_sleep_5   ; 0x800'3612
  //         TX_RESTORE
  0x800'3608: 0x0031          MOVS     R1, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'360a: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'360e: 0x2000          MOVS     R0, #0
  0x800'3610: 0xe013          B.N      ??_tx_thread_sleep_2   ; 0x800'363a
                ??_tx_thread_sleep_5:
  //         if (_tx_thread_preempt_disable != ((UINT) 0))
  0x800'3612: 0x480d          LDR.N    R0, [PC, #0x34]        ; _tx_thread_preempt_disable
  0x800'3614: 0x6800          LDR      R0, [R0]
  0x800'3616: 0x2800          CMP      R0, #0
  0x800'3618: 0xd004          BEQ.N    ??_tx_thread_sleep_6   ; 0x800'3624
  //             TX_RESTORE
  0x800'361a: 0x0031          MOVS     R1, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'361c: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'3620: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'3622: 0xe00a          B.N      ??_tx_thread_sleep_2   ; 0x800'363a
                ??_tx_thread_sleep_6:
  //             thread_ptr -> tx_thread_state =    TX_SLEEP;
  0x800'3624: 0x2004          MOVS     R0, #4
  0x800'3626: 0x6328          STR      R0, [R5, #0x30]
  //             _tx_thread_system_ni_suspend(thread_ptr, timer_ticks);
  0x800'3628: 0x0021          MOVS     R1, R4
  0x800'362a: 0x0028          MOVS     R0, R5
  0x800'362c: 0xf7fe 0xfea6   BL       _tx_thread_system_ni_suspend
                                                              ; 0x800'237c
  //             TX_RESTORE
  0x800'3630: 0x0031          MOVS     R1, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3632: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'3636: 0xf8d5 0x0084   LDR.W    R0, [R5, #0x84]
                ??_tx_thread_sleep_2:
  //     return(status);
  0x800'363a: 0xbd70          POP      {R4-R6, PC}
                `$d.32`:
                ??_tx_thread_sleep_0:
  0x800'363c: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'3640: 0x2000'0008     DC32     _tx_thread_system_state
  0x800'3644: 0x2000'20f0     DC32     _tx_timer_thread
  0x800'3648: 0x2000'246c     DC32     _tx_thread_preempt_disable
                $t:
                `.text8`:
                _txe_byte_allocate:
  // UINT  _txe_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr,
  //                                     ULONG memory_size,  ULONG wait_option)
  // {
  0x800'364c: 0xe92d 0x43f8   PUSH.W   {R3-R9, LR}
  0x800'3650: 0x0005          MOVS     R5, R0
  0x800'3652: 0x000e          MOVS     R6, R1
  0x800'3654: 0x0017          MOVS     R7, R2
  0x800'3656: 0x4698          MOV      R8, R3
  //     status =  TX_SUCCESS;
  0x800'3658: 0x2400          MOVS     R4, #0
  //     if (pool_ptr == TX_NULL)
  0x800'365a: 0x2d00          CMP      R5, #0
  0x800'365c: 0xd102          BNE.N    ??_txe_byte_allocate_1 ; 0x800'3664
  //         status =  TX_POOL_ERROR;
  0x800'365e: 0x2002          MOVS     R0, #2
  0x800'3660: 0x0004          MOVS     R4, R0
  0x800'3662: 0xe022          B.N      ??_txe_byte_allocate_2 ; 0x800'36aa
                ??_txe_byte_allocate_1:
  //     else if  (pool_ptr -> tx_byte_pool_id != TX_BYTE_POOL_ID)
  0x800'3664: 0x6829          LDR      R1, [R5]
  0x800'3666: 0x4825          LDR.N    R0, ??_txe_byte_allocate_0
                                                              ; 0x4259'5445
  0x800'3668: 0x4281          CMP      R1, R0
  0x800'366a: 0xd002          BEQ.N    ??_txe_byte_allocate_3 ; 0x800'3672
  //         status =  TX_POOL_ERROR;
  0x800'366c: 0x2002          MOVS     R0, #2
  0x800'366e: 0x0004          MOVS     R4, R0
  0x800'3670: 0xe01b          B.N      ??_txe_byte_allocate_2 ; 0x800'36aa
                ??_txe_byte_allocate_3:
  //     else if (memory_ptr == TX_NULL)
  0x800'3672: 0x2e00          CMP      R6, #0
  0x800'3674: 0xd102          BNE.N    ??_txe_byte_allocate_4 ; 0x800'367c
  //         status =  TX_PTR_ERROR;
  0x800'3676: 0x2003          MOVS     R0, #3
  0x800'3678: 0x0004          MOVS     R4, R0
  0x800'367a: 0xe016          B.N      ??_txe_byte_allocate_2 ; 0x800'36aa
                ??_txe_byte_allocate_4:
  //     else if (memory_size == ((ULONG) 0))
  0x800'367c: 0x2f00          CMP      R7, #0
  0x800'367e: 0xd102          BNE.N    ??_txe_byte_allocate_5 ; 0x800'3686
  //         status =  TX_SIZE_ERROR;
  0x800'3680: 0x2005          MOVS     R0, #5
  0x800'3682: 0x0004          MOVS     R4, R0
  0x800'3684: 0xe011          B.N      ??_txe_byte_allocate_2 ; 0x800'36aa
                ??_txe_byte_allocate_5:
  //     else if (memory_size > pool_ptr -> tx_byte_pool_size)
  0x800'3686: 0x69e8          LDR      R0, [R5, #0x1c]
  0x800'3688: 0x42b8          CMP      R0, R7
  0x800'368a: 0xd202          BCS.N    ??_txe_byte_allocate_6 ; 0x800'3692
  //         status =  TX_SIZE_ERROR;
  0x800'368c: 0x2005          MOVS     R0, #5
  0x800'368e: 0x0004          MOVS     R4, R0
  0x800'3690: 0xe00b          B.N      ??_txe_byte_allocate_2 ; 0x800'36aa
                ??_txe_byte_allocate_6:
  //         if (wait_option != TX_NO_WAIT)
  0x800'3692: 0xf1b8 0x0f00   CMP.W    R8, #0
  0x800'3696: 0xd008          BEQ.N    ??_txe_byte_allocate_2 ; 0x800'36aa
  //             if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  0x800'3698: 0x4819          LDR.N    R0, [PC, #0x64]        ; _tx_thread_system_state
  0x800'369a: 0x6800          LDR      R0, [R0]
  0x800'369c: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'36a0: 0x4308          ORRS     R0, R0, R1
  0x800'36a2: 0x2800          CMP      R0, #0
  0x800'36a4: 0xd001          BEQ.N    ??_txe_byte_allocate_2 ; 0x800'36aa
  //                 status =  TX_WAIT_ERROR;
  0x800'36a6: 0x2004          MOVS     R0, #4
  0x800'36a8: 0x0004          MOVS     R4, R0
                ??_txe_byte_allocate_2:
  //     if (status == TX_SUCCESS)
  0x800'36aa: 0x2c00          CMP      R4, #0
  0x800'36ac: 0xd107          BNE.N    ??_txe_byte_allocate_7 ; 0x800'36be
  //         TX_THREAD_GET_CURRENT(thread_ptr)
  0x800'36ae: 0x4815          LDR.N    R0, [PC, #0x54]        ; _tx_thread_current_ptr
  0x800'36b0: 0x6800          LDR      R0, [R0]
  0x800'36b2: 0x4681          MOV      R9, R0
  //         if (thread_ptr == &_tx_timer_thread)
  0x800'36b4: 0x4814          LDR.N    R0, [PC, #0x50]        ; _tx_timer_thread
  0x800'36b6: 0x4581          CMP      R9, R0
  0x800'36b8: 0xd101          BNE.N    ??_txe_byte_allocate_7 ; 0x800'36be
  //             status =  TX_CALLER_ERROR;
  0x800'36ba: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'36bc: 0x0004          MOVS     R4, R0
                ??_txe_byte_allocate_7:
  //     if (status == TX_SUCCESS)
  0x800'36be: 0x2c00          CMP      R4, #0
  0x800'36c0: 0xd10f          BNE.N    ??_txe_byte_allocate_8 ; 0x800'36e2
  //         if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
  0x800'36c2: 0x4a0f          LDR.N    R2, [PC, #0x3c]        ; _tx_thread_system_state
  0x800'36c4: 0x6810          LDR      R0, [R2]
  0x800'36c6: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'36ca: 0x4308          ORRS     R0, R0, R1
  0x800'36cc: 0x2800          CMP      R0, #0
  0x800'36ce: 0xd008          BEQ.N    ??_txe_byte_allocate_8 ; 0x800'36e2
  //             if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  0x800'36d0: 0x6811          LDR      R1, [R2]
  0x800'36d2: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'36d6: 0x4301          ORRS     R1, R1, R0
  0x800'36d8: 0xf1b1 0x3ff0   CMP.W    R1, #-252645136        ; 0xf0f0'f0f0
  0x800'36dc: 0xd201          BCS.N    ??_txe_byte_allocate_8 ; 0x800'36e2
  //                 status =  TX_CALLER_ERROR;
  0x800'36de: 0x2013          MOVS     R0, #19                ; 0x13
  0x800'36e0: 0x0004          MOVS     R4, R0
                ??_txe_byte_allocate_8:
  //     if (status == TX_SUCCESS)
  0x800'36e2: 0x2c00          CMP      R4, #0
  0x800'36e4: 0xd106          BNE.N    ??_txe_byte_allocate_9 ; 0x800'36f4
  //         status =  _tx_byte_allocate(pool_ptr, memory_ptr, memory_size,  wait_option);
  0x800'36e6: 0x4643          MOV      R3, R8
  0x800'36e8: 0x003a          MOVS     R2, R7
  0x800'36ea: 0x0031          MOVS     R1, R6
  0x800'36ec: 0x0028          MOVS     R0, R5
  0x800'36ee: 0xf7ff 0xfd77   BL       _tx_byte_allocate      ; 0x800'31e0
  0x800'36f2: 0x0004          MOVS     R4, R0
                ??_txe_byte_allocate_9:
  //     return(status);
  0x800'36f4: 0x0020          MOVS     R0, R4
  0x800'36f6: 0xe8bd 0x83f2   POP.W    {R1, R4-R9, PC}
  0x800'36fa: 0xbf00          NOP
                `$d.32`:
                ??_txe_byte_allocate_0:
  0x800'36fc: 0x4259'5445     DC32     0x4259'5445            ; 'ETYB'
  0x800'3700: 0x2000'0008     DC32     _tx_thread_system_state
  0x800'3704: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'3708: 0x2000'20f0     DC32     _tx_timer_thread
                $t:
                `.text8`:
                _txe_block_release:
  // UINT  _txe_block_release(VOID *block_ptr)
  // {
  0x800'370c: 0xb5f8          PUSH     {R3-R7, LR}
  0x800'370e: 0x0004          MOVS     R4, R0
  //     if (block_ptr == TX_NULL)
  0x800'3710: 0x2c00          CMP      R4, #0
  0x800'3712: 0xd101          BNE.N    ??_txe_block_release_1 ; 0x800'3718
  //         status =  TX_PTR_ERROR;
  0x800'3714: 0x2003          MOVS     R0, #3
  0x800'3716: 0xe012          B.N      ??_txe_block_release_2 ; 0x800'373e
                ??_txe_block_release_1:
  //         work_ptr =      TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
  0x800'3718: 0x0020          MOVS     R0, R4
  //         work_ptr =      TX_UCHAR_POINTER_SUB(work_ptr, (sizeof(UCHAR *)));
  0x800'371a: 0x1f01          SUBS     R1, R0, #4
  //         indirect_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
  0x800'371c: 0x000e          MOVS     R6, R1
  //         work_ptr =      *indirect_ptr;
  0x800'371e: 0x6830          LDR      R0, [R6]
  0x800'3720: 0x0007          MOVS     R7, R0
  //         pool_ptr =      TX_UCHAR_TO_BLOCK_POOL_POINTER_CONVERT(work_ptr);
  0x800'3722: 0x003d          MOVS     R5, R7
  //         if (pool_ptr == TX_NULL)
  0x800'3724: 0x2d00          CMP      R5, #0
  0x800'3726: 0xd101          BNE.N    ??_txe_block_release_3 ; 0x800'372c
  //             status =  TX_PTR_ERROR;
  0x800'3728: 0x2003          MOVS     R0, #3
  0x800'372a: 0xe008          B.N      ??_txe_block_release_2 ; 0x800'373e
                ??_txe_block_release_3:
  //         else if  (pool_ptr -> tx_block_pool_id != TX_BLOCK_POOL_ID)
  0x800'372c: 0x6829          LDR      R1, [R5]
  0x800'372e: 0x4804          LDR.N    R0, ??_txe_block_release_0
                                                              ; 0x424c'4f43
  0x800'3730: 0x4281          CMP      R1, R0
  0x800'3732: 0xd001          BEQ.N    ??_txe_block_release_4 ; 0x800'3738
  //             status =  TX_PTR_ERROR;
  0x800'3734: 0x2003          MOVS     R0, #3
  0x800'3736: 0xe002          B.N      ??_txe_block_release_2 ; 0x800'373e
                ??_txe_block_release_4:
  //             status =  _tx_block_release(block_ptr);
  0x800'3738: 0x0020          MOVS     R0, R4
  0x800'373a: 0xf000 0xf87d   BL       _tx_block_release      ; 0x800'3838
                ??_txe_block_release_2:
  //     return(status);
  0x800'373e: 0xbdf2          POP      {R1, R4-R7, PC}
                `$d.32`:
                ??_txe_block_release_0:
  0x800'3740: 0x424c'4f43     DC32     0x424c'4f43            ; 'COLB'
                $t:
                `.text11`:
                HAL_Init:
  // HAL_StatusTypeDef HAL_Init(void)
  // {
  0x800'3744: 0xb580          PUSH     {R7, LR}
  //   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
  0x800'3746: 0x480b          LDR.N    R0, ??DataTable18      ; 0x4002'3c00
  0x800'3748: 0x6801          LDR      R1, [R0]
  0x800'374a: 0xf451 0x7100   ORRS.W   R1, R1, #512           ; 0x200
  0x800'374e: 0x6001          STR      R1, [R0]
  //   __HAL_FLASH_DATA_CACHE_ENABLE();
  0x800'3750: 0x6801          LDR      R1, [R0]
  0x800'3752: 0xf451 0x6180   ORRS.W   R1, R1, #1024          ; 0x400
  0x800'3756: 0x6001          STR      R1, [R0]
  //   __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  0x800'3758: 0x6801          LDR      R1, [R0]
  0x800'375a: 0xf451 0x7180   ORRS.W   R1, R1, #256           ; 0x100
  0x800'375e: 0x6001          STR      R1, [R0]
  //   HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  0x800'3760: 0x2003          MOVS     R0, #3
  0x800'3762: 0xf7fe 0xfabd   BL       HAL_NVIC_SetPriorityGrouping
                                                              ; 0x800'1ce0
  //   HAL_InitTick(TICK_INT_PRIORITY);
  0x800'3766: 0x200f          MOVS     R0, #15                ; 0xf
  0x800'3768: 0xf000 0xf8b0   BL       HAL_InitTick           ; 0x800'38cc
  //   HAL_MspInit();
  0x800'376c: 0xf000 0xf914   BL       HAL_MspInit            ; 0x800'3998
  //   return HAL_OK;
  0x800'3770: 0x2000          MOVS     R0, #0
  0x800'3772: 0xbd02          POP      {R1, PC}
                `$d.32`:
                ??DataTable18:
  0x800'3774: 0x4002'3c00     DC32     0x4002'3c00            ; '.<.@'
                $t:
                `.text8`:
                MX_GPIO_Init:
  // void MX_GPIO_Init(void)
  // {
  0x800'3778: 0xb081          SUB      SP, SP, #0x4
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'377a: 0x2000          MOVS     R0, #0
  0x800'377c: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'377e: 0x4811          LDR.N    R0, ??MX_GPIO_Init_0   ; 0x4002'3830
  0x800'3780: 0x6801          LDR      R1, [R0]
  0x800'3782: 0xf051 0x0104   ORRS.W   R1, R1, #4
  0x800'3786: 0x6001          STR      R1, [R0]
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'3788: 0x6801          LDR      R1, [R0]
  0x800'378a: 0xf011 0x0104   ANDS.W   R1, R1, #4
  0x800'378e: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'3790: 0x9900          LDR      R1, [SP]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'3792: 0x2100          MOVS     R1, #0
  0x800'3794: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'3796: 0x6801          LDR      R1, [R0]
  0x800'3798: 0xf051 0x0180   ORRS.W   R1, R1, #128           ; 0x80
  0x800'379c: 0x6001          STR      R1, [R0]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'379e: 0x6801          LDR      R1, [R0]
  0x800'37a0: 0xf011 0x0180   ANDS.W   R1, R1, #128           ; 0x80
  0x800'37a4: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'37a6: 0x9900          LDR      R1, [SP]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'37a8: 0x2100          MOVS     R1, #0
  0x800'37aa: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'37ac: 0x6801          LDR      R1, [R0]
  0x800'37ae: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'37b2: 0x6001          STR      R1, [R0]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'37b4: 0x6800          LDR      R0, [R0]
  0x800'37b6: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'37ba: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'37bc: 0x9800          LDR      R0, [SP]
  // }
  0x800'37be: 0xb001          ADD      SP, SP, #0x4
  0x800'37c0: 0x4770          BX       LR
  0x800'37c2: 0xbf00          NOP
                `$d.32`:
                ??MX_GPIO_Init_0:
  0x800'37c4: 0x4002'3830     DC32     0x4002'3830            ; '08.@'
                $t:
                `.text8`:
                _tx_initialize_kernel_enter:
  // VOID  _tx_initialize_kernel_enter(VOID)
  // {
  0x800'37c8: 0xb510          PUSH     {R4, LR}
  //     if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
  0x800'37ca: 0x4c0e          LDR.N    R4, ??_tx_initialize_kernel_enter_0
                                                              ; _tx_thread_system_state
  0x800'37cc: 0x6820          LDR      R0, [R4]
  0x800'37ce: 0xf110 0x3f0f   CMN.W    R0, #252645135         ; 0xf0f'0f0f
  0x800'37d2: 0xd00a          BEQ.N    ??_tx_initialize_kernel_enter_1
                                                              ; 0x800'37ea
  //         _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
  0x800'37d4: 0xf05f 0x30f0   MOVS.W   R0, #-252645136        ; 0xf0f0'f0f0
  0x800'37d8: 0x6020          STR      R0, [R4]
  //         _tx_initialize_low_level();
  0x800'37da: 0xf000 0xf8fd   BL       _tx_initialize_low_level
                                                              ; 0x800'39d8
  //         _tx_initialize_high_level();
  0x800'37de: 0xf000 0xf935   BL       _tx_initialize_high_level
                                                              ; 0x800'3a4c
  //         TX_PORT_SPECIFIC_POST_INITIALIZATION
  0x800'37e2: 0x4909          LDR.N    R1, [PC, #0x24]        ; _tx_thread_preempt_disable
  0x800'37e4: 0x6808          LDR      R0, [R1]
  0x800'37e6: 0x1c40          ADDS     R0, R0, #1
  0x800'37e8: 0x6008          STR      R0, [R1]
                ??_tx_initialize_kernel_enter_1:
  //     _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
  0x800'37ea: 0xf05f 0x30f0   MOVS.W   R0, #-252645136        ; 0xf0f0'f0f0
  0x800'37ee: 0x6020          STR      R0, [R4]
  //     tx_application_define(_tx_initialize_unused_memory);
  0x800'37f0: 0x4806          LDR.N    R0, [PC, #0x18]        ; _tx_initialize_unused_memory
  0x800'37f2: 0x6800          LDR      R0, [R0]
  0x800'37f4: 0xf7ff 0xfe90   BL       tx_application_define  ; 0x800'3518
  //     _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
  0x800'37f8: 0x2000          MOVS     R0, #0
  0x800'37fa: 0x6020          STR      R0, [R4]
  //     _tx_thread_schedule();
  0x800'37fc: 0xf000 0xf92c   BL       _tx_thread_schedule    ; 0x800'3a58
  // }
  0x800'3800: 0xbd10          POP      {R4, PC}
  0x800'3802: 0xbf00          NOP
                `$d.32`:
                ??_tx_initialize_kernel_enter_0:
  0x800'3804: 0x2000'0008     DC32     _tx_thread_system_state
  0x800'3808: 0x2000'246c     DC32     _tx_thread_preempt_disable
  0x800'380c: 0x2000'244c     DC32     _tx_initialize_unused_memory
                $t:
                `.text23`:
                HAL_Delay:
  // __weak void HAL_Delay(uint32_t Delay)
  // {
  0x800'3810: 0xb570          PUSH     {R4-R6, LR}
  0x800'3812: 0x0004          MOVS     R4, R0
  //   uint32_t tickstart = HAL_GetTick();
  0x800'3814: 0xf7fd 0xfb14   BL       HAL_GetTick            ; 0x800'0e40
  0x800'3818: 0x0005          MOVS     R5, R0
  //   uint32_t wait = Delay;
  0x800'381a: 0x0026          MOVS     R6, R4
  //   if (wait < HAL_MAX_DELAY)
  0x800'381c: 0xf116 0x0f01   CMN.W    R6, #1
  0x800'3820: 0xd002          BEQ.N    ??HAL_Delay_1          ; 0x800'3828
  //     wait += (uint32_t)(uwTickFreq);
  0x800'3822: 0x4804          LDR.N    R0, ??HAL_Delay_0      ; uwTickFreq
  0x800'3824: 0x7800          LDRB     R0, [R0]
  0x800'3826: 0x1836          ADDS     R6, R6, R0
                ??HAL_Delay_1:
  //   while((HAL_GetTick() - tickstart) < wait)
  0x800'3828: 0xf7fd 0xfb0a   BL       HAL_GetTick            ; 0x800'0e40
  0x800'382c: 0x1b40          SUBS     R0, R0, R5
  0x800'382e: 0x42b0          CMP      R0, R6
  0x800'3830: 0xd3fa          BCC.N    ??HAL_Delay_1          ; 0x800'3828
  // }
  0x800'3832: 0xbd70          POP      {R4-R6, PC}
                `$d.32`:
                ??HAL_Delay_0:
  0x800'3834: 0x2000'0014     DC32     uwTickFreq
                $t:
                `.text8`:
                _tx_block_release:
  // UINT  _tx_block_release(VOID *block_ptr)
  // {
  0x800'3838: 0xe92d 0x4ffe   PUSH.W   {R1-R11, LR}
  0x800'383c: 0x4683          MOV      R11, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'383e: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'3842: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3844: 0x4658          MOV      R0, R11
  //     work_ptr =        TX_UCHAR_POINTER_SUB(work_ptr, (sizeof(UCHAR *)));
  0x800'3846: 0xf1b0 0x0804   SUBS.W   R8, R0, #4
  //     next_block_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
  0x800'384a: 0x46c1          MOV      R9, R8
  //     pool_ptr =        TX_UCHAR_TO_BLOCK_POOL_POINTER_CONVERT((*next_block_ptr));
  0x800'384c: 0xf8d9 0xa000   LDR.W    R10, [R9]
  //     thread_ptr =  pool_ptr -> tx_block_pool_suspension_list;
  0x800'3850: 0xf8da 0x4020   LDR.W    R4, [R10, #0x20]
  //     if (thread_ptr != TX_NULL)
  0x800'3854: 0x2c00          CMP      R4, #0
  0x800'3856: 0xd028          BEQ.N    ??_tx_block_release_0  ; 0x800'38aa
  //         (pool_ptr -> tx_block_pool_suspended_count)--;
  0x800'3858: 0xf8da 0x0024   LDR.W    R0, [R10, #0x24]
  0x800'385c: 0x1e40          SUBS     R0, R0, #1
  0x800'385e: 0xf8ca 0x0024   STR.W    R0, [R10, #0x24]
  //         suspended_count =  (pool_ptr -> tx_block_pool_suspended_count);
  0x800'3862: 0xf8da 0x0024   LDR.W    R0, [R10, #0x24]
  0x800'3866: 0x9000          STR      R0, [SP]
  //         if (suspended_count == TX_NO_SUSPENSIONS)
  0x800'3868: 0x9800          LDR      R0, [SP]
  0x800'386a: 0x2800          CMP      R0, #0
  0x800'386c: 0xd103          BNE.N    ??_tx_block_release_1  ; 0x800'3876
  //             pool_ptr -> tx_block_pool_suspension_list =  TX_NULL;
  0x800'386e: 0x2000          MOVS     R0, #0
  0x800'3870: 0xf8ca 0x0020   STR.W    R0, [R10, #0x20]
  0x800'3874: 0xe007          B.N      ??_tx_block_release_2  ; 0x800'3886
                ??_tx_block_release_1:
  //             next_thread =                                thread_ptr -> tx_thread_suspended_next;
  0x800'3876: 0x6f20          LDR      R0, [R4, #0x70]
  0x800'3878: 0x0005          MOVS     R5, R0
  //             pool_ptr -> tx_block_pool_suspension_list =  next_thread;
  0x800'387a: 0xf8ca 0x5020   STR.W    R5, [R10, #0x20]
  //             previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
  0x800'387e: 0x6f60          LDR      R0, [R4, #0x74]
  0x800'3880: 0x0006          MOVS     R6, R0
  //             next_thread -> tx_thread_suspended_previous =  previous_thread;
  0x800'3882: 0x676e          STR      R6, [R5, #0x74]
  //             previous_thread -> tx_thread_suspended_next =  next_thread;
  0x800'3884: 0x6735          STR      R5, [R6, #0x70]
                ??_tx_block_release_2:
  //         thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  0x800'3886: 0x2000          MOVS     R0, #0
  0x800'3888: 0x66a0          STR      R0, [R4, #0x68]
  //         return_block_ptr =  TX_VOID_TO_INDIRECT_UCHAR_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
  0x800'388a: 0x6fe0          LDR      R0, [R4, #0x7c]
  0x800'388c: 0x9001          STR      R0, [SP, #0x4]
  //         work_ptr =          TX_VOID_TO_UCHAR_POINTER_CONVERT(block_ptr);
  0x800'388e: 0x46d8          MOV      R8, R11
  //         *return_block_ptr =  work_ptr;
  0x800'3890: 0x9801          LDR      R0, [SP, #0x4]
  0x800'3892: 0xf8c0 0x8000   STR.W    R8, [R0]
  //         thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
  0x800'3896: 0x2000          MOVS     R0, #0
  0x800'3898: 0xf8c4 0x0084   STR.W    R0, [R4, #0x84]
  //         _tx_thread_system_ni_resume(thread_ptr);
  0x800'389c: 0x0020          MOVS     R0, R4
  0x800'389e: 0xf7fe 0xfb35   BL       _tx_thread_system_ni_resume
                                                              ; 0x800'1f0c
  //         TX_RESTORE
  0x800'38a2: 0x0038          MOVS     R0, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'38a4: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'38a8: 0xe00d          B.N      ??_tx_block_release_3  ; 0x800'38c6
                ??_tx_block_release_0:
  //         *next_block_ptr =  pool_ptr -> tx_block_pool_available_list;
  0x800'38aa: 0xf8da 0x0010   LDR.W    R0, [R10, #0x10]
  0x800'38ae: 0xf8c9 0x0000   STR.W    R0, [R9]
  //         pool_ptr -> tx_block_pool_available_list =  work_ptr;
  0x800'38b2: 0xf8ca 0x8010   STR.W    R8, [R10, #0x10]
  //         pool_ptr -> tx_block_pool_available++;
  0x800'38b6: 0xf8da 0x0008   LDR.W    R0, [R10, #0x8]
  0x800'38ba: 0x1c40          ADDS     R0, R0, #1
  0x800'38bc: 0xf8ca 0x0008   STR.W    R0, [R10, #0x8]
  //         TX_RESTORE
  0x800'38c0: 0x0038          MOVS     R0, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'38c2: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_block_release_3:
  // }
  0x800'38c6: 0x2000          MOVS     R0, #0
  0x800'38c8: 0xe8bd 0x8ffe   POP.W    {R1-R11, PC}
                `.text9`:
                HAL_InitTick:
  // HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
  // {
  0x800'38cc: 0xe92d 0x47f8   PUSH.W   {R3-R10, LR}
  0x800'38d0: 0xb087          SUB      SP, SP, #0x1c
  0x800'38d2: 0x0005          MOVS     R5, R0
  //   uint32_t              uwTimclock, uwAPB1Prescaler = 0U;
  0x800'38d4: 0x2700          MOVS     R7, #0
  //   uint32_t              uwPrescalerValue = 0U;
  0x800'38d6: 0x2600          MOVS     R6, #0
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'38d8: 0x2000          MOVS     R0, #0
  0x800'38da: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'38dc: 0x492a          LDR.N    R1, ??DataTable2       ; 0x4002'3840
  0x800'38de: 0x6808          LDR      R0, [R1]
  0x800'38e0: 0xf050 0x0001   ORRS.W   R0, R0, #1
  0x800'38e4: 0x6008          STR      R0, [R1]
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'38e6: 0x6808          LDR      R0, [R1]
  0x800'38e8: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'38ec: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'38ee: 0x9800          LDR      R0, [SP]
  //   HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
  0x800'38f0: 0xa901          ADD      R1, SP, #0x4
  0x800'38f2: 0xa802          ADD      R0, SP, #0x8
  0x800'38f4: 0xf7fd 0xfb29   BL       HAL_RCC_GetClockConfig ; 0x800'0f4a
  //   uwAPB1Prescaler = clkconfig.APB1CLKDivider;
  0x800'38f8: 0x9c05          LDR      R4, [SP, #0x14]
  //   if (uwAPB1Prescaler == RCC_HCLK_DIV1)
  0x800'38fa: 0x2c00          CMP      R4, #0
  0x800'38fc: 0xd103          BNE.N    ??HAL_InitTick_0       ; 0x800'3906
  //     uwTimclock = HAL_RCC_GetPCLK1Freq();
  0x800'38fe: 0xf7fd 0xfb0e   BL       HAL_RCC_GetPCLK1Freq   ; 0x800'0f1e
  0x800'3902: 0x0007          MOVS     R7, R0
  0x800'3904: 0xe002          B.N      ??HAL_InitTick_1       ; 0x800'390c
                ??HAL_InitTick_0:
  //     uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
  0x800'3906: 0xf7fd 0xfb0a   BL       HAL_RCC_GetPCLK1Freq   ; 0x800'0f1e
  0x800'390a: 0x0047          LSLS     R7, R0, #1
                ??HAL_InitTick_1:
  //   uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
  0x800'390c: 0x481f          LDR.N    R0, ??DataTable2_1     ; 0xf'4240
  0x800'390e: 0xfbb7 0xf8f0   UDIV     R8, R7, R0
  0x800'3912: 0xf1b8 0x0801   SUBS.W   R8, R8, #1
  //   htim2.Instance = TIM2;
  0x800'3916: 0xf8df 0x9078   LDR.W    R9, ??DataTable2_2     ; htim2
  0x800'391a: 0xf05f 0x4080   MOVS.W   R0, #1073741824        ; 0x4000'0000
  0x800'391e: 0xf8c9 0x0000   STR.W    R0, [R9]
  //   htim2.Init.Period = (1000000U / 1000U) - 1U;
  0x800'3922: 0xf240 0x30e7   MOVW     R0, #999               ; 0x3e7
  0x800'3926: 0xf8c9 0x000c   STR.W    R0, [R9, #0xc]
  //   htim2.Init.Prescaler = uwPrescalerValue;
  0x800'392a: 0xf8c9 0x8004   STR.W    R8, [R9, #0x4]
  //   htim2.Init.ClockDivision = 0;
  0x800'392e: 0x2000          MOVS     R0, #0
  0x800'3930: 0xf8c9 0x0010   STR.W    R0, [R9, #0x10]
  //   htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  0x800'3934: 0x2000          MOVS     R0, #0
  0x800'3936: 0xf8c9 0x0008   STR.W    R0, [R9, #0x8]
  //   htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  0x800'393a: 0x2000          MOVS     R0, #0
  0x800'393c: 0xf8c9 0x0018   STR.W    R0, [R9, #0x18]
  //   status = HAL_TIM_Base_Init(&htim2);
  0x800'3940: 0x4648          MOV      R0, R9
  0x800'3942: 0xf7fd 0xfc5d   BL       HAL_TIM_Base_Init      ; 0x800'1200
  0x800'3946: 0x4682          MOV      R10, R0
  //   if (status == HAL_OK)
  0x800'3948: 0x4650          MOV      R0, R10
  0x800'394a: 0xb2c0          UXTB     R0, R0
  0x800'394c: 0x2800          CMP      R0, #0
  0x800'394e: 0xd116          BNE.N    ??HAL_InitTick_2       ; 0x800'397e
  //     status = HAL_TIM_Base_Start_IT(&htim2);
  0x800'3950: 0x4648          MOV      R0, R9
  0x800'3952: 0xf7fd 0xfd31   BL       HAL_TIM_Base_Start_IT  ; 0x800'13b8
  0x800'3956: 0x4682          MOV      R10, R0
  //     if (status == HAL_OK)
  0x800'3958: 0x4650          MOV      R0, R10
  0x800'395a: 0xb2c0          UXTB     R0, R0
  0x800'395c: 0x2800          CMP      R0, #0
  0x800'395e: 0xd10e          BNE.N    ??HAL_InitTick_2       ; 0x800'397e
  //         HAL_NVIC_EnableIRQ(TIM2_IRQn);
  0x800'3960: 0x201c          MOVS     R0, #28                ; 0x1c
  0x800'3962: 0xf7fe 0xf9f5   BL       HAL_NVIC_EnableIRQ     ; 0x800'1d50
  //       if (TickPriority < (1UL << __NVIC_PRIO_BITS))
  0x800'3966: 0x2d10          CMP      R5, #16                ; 0x10
  0x800'3968: 0xd207          BCS.N    ??HAL_InitTick_3       ; 0x800'397a
  //         HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority, 0U);
  0x800'396a: 0x2200          MOVS     R2, #0
  0x800'396c: 0x0029          MOVS     R1, R5
  0x800'396e: 0x201c          MOVS     R0, #28                ; 0x1c
  0x800'3970: 0xf7fe 0xf9cb   BL       HAL_NVIC_SetPriority   ; 0x800'1d0a
  //         uwTickPrio = TickPriority;
  0x800'3974: 0x4807          LDR.N    R0, ??DataTable2_3     ; uwTickPrio
  0x800'3976: 0x6005          STR      R5, [R0]
  0x800'3978: 0xe001          B.N      ??HAL_InitTick_2       ; 0x800'397e
                ??HAL_InitTick_3:
  //         status = HAL_ERROR;
  0x800'397a: 0x2001          MOVS     R0, #1
  0x800'397c: 0x4682          MOV      R10, R0
                ??HAL_InitTick_2:
  //   return status;
  0x800'397e: 0x4650          MOV      R0, R10
  0x800'3980: 0xb2c0          UXTB     R0, R0
  0x800'3982: 0xb008          ADD      SP, SP, #0x20
  0x800'3984: 0xe8bd 0x87f0   POP.W    {R4-R10, PC}
                `$d.32`:
                ??DataTable2:
  0x800'3988: 0x4002'3840     DC32     0x4002'3840            ; '@8.@'
                ??DataTable2_1:
  0x800'398c: 0x000f'4240     DC32     0xf'4240               ; '@B..'
                ??DataTable2_2:
  0x800'3990: 0x2000'2394     DC32     htim2
                ??DataTable2_3:
  0x800'3994: 0x2000'0000     DC32     uwTickPrio
                $t:
                `.text8`:
                HAL_MspInit:
  // void HAL_MspInit(void)
  // {
  0x800'3998: 0xb081          SUB      SP, SP, #0x4
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'399a: 0x2000          MOVS     R0, #0
  0x800'399c: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'399e: 0x490c          LDR.N    R1, ??HAL_MspInit_0    ; 0x4002'3844
  0x800'39a0: 0x6808          LDR      R0, [R1]
  0x800'39a2: 0xf450 0x4080   ORRS.W   R0, R0, #16384         ; 0x4000
  0x800'39a6: 0x6008          STR      R0, [R1]
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'39a8: 0x6808          LDR      R0, [R1]
  0x800'39aa: 0xf410 0x4080   ANDS.W   R0, R0, #16384         ; 0x4000
  0x800'39ae: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'39b0: 0x9800          LDR      R0, [SP]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'39b2: 0x2000          MOVS     R0, #0
  0x800'39b4: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'39b6: 0x4907          LDR.N    R1, [PC, #0x1c]        ; 0x4002'3840
  0x800'39b8: 0x6808          LDR      R0, [R1]
  0x800'39ba: 0xf050 0x5080   ORRS.W   R0, R0, #268435456     ; 0x1000'0000
  0x800'39be: 0x6008          STR      R0, [R1]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'39c0: 0x6808          LDR      R0, [R1]
  0x800'39c2: 0xf010 0x5080   ANDS.W   R0, R0, #268435456     ; 0x1000'0000
  0x800'39c6: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'39c8: 0x9800          LDR      R0, [SP]
  // }
  0x800'39ca: 0xb001          ADD      SP, SP, #0x4
  0x800'39cc: 0x4770          BX       LR
  0x800'39ce: 0xbf00          NOP
                `$d.32`:
                ??HAL_MspInit_0:
  0x800'39d0: 0x4002'3844     DC32     0x4002'3844            ; 'D8.@'
  0x800'39d4: 0x4002'3840     DC32     0x4002'3840            ; '@8.@'
                $t:
                `.text7`:
                _tx_initialize_low_level:
  //     CPSID   i                                       ; Disable interrupts
  0x800'39d8: 0xb672          CPSID    i
  //     LDR     r0, =__tx_free_memory_start             ; Get end of non-initialized RAM area
  0x800'39da: 0x4814          LDR.N    R0, [PC, #0x50]        ; __tx_free_memory_start
  //     LDR     r2, =_tx_initialize_unused_memory       ; Build address of unused memory pointer
  0x800'39dc: 0x4a14          LDR.N    R2, [PC, #0x50]        ; _tx_initialize_unused_memory
  //     STR     r0, [r2, #0]                            ; Save first free memory address
  0x800'39de: 0x6010          STR      R0, [R2]
  //     LDR     r0, =0xE0001000                         ; Build address of DWT register
  0x800'39e0: 0x4814          LDR.N    R0, [PC, #0x50]        ; 0xe000'1000
  //     LDR     r1, [r0]                                ; Pickup the current value
  0x800'39e2: 0x6801          LDR      R1, [R0]
  //     ORR     r1, r1, #1                              ; Set the CYCCNTENA bit
  0x800'39e4: 0xf041 0x0101   ORR.W    R1, R1, #1
  //     STR     r1, [r0]                                ; Enable the cycle count register
  0x800'39e8: 0x6001          STR      R1, [R0]
  //     MOV     r0, #0xE000E000                         ; Build address of NVIC registers
  0x800'39ea: 0xf04f 0x20e0   MOV.W    R0, #-536813568        ; 0xe000'e000
  //     LDR     r1, =__vector_table                     ; Pickup address of vector table
  0x800'39ee: 0x4912          LDR.N    R1, [PC, #0x48]        ; __vector_table
  //     STR     r1, [r0, #0xD08]                        ; Set vector table address
  0x800'39f0: 0xf8c0 0x1d08   STR.W    R1, [R0, #0xd08]
  //     LDR     r0, =_tx_thread_system_stack_ptr        ; Build address of system stack pointer
  0x800'39f4: 0x4811          LDR.N    R0, [PC, #0x44]        ; _tx_thread_system_stack_ptr
  //     LDR     r1, =__vector_table                     ; Pickup address of vector table
  0x800'39f6: 0x4910          LDR.N    R1, [PC, #0x40]        ; __vector_table
  //     LDR     r1, [r1]                                ; Pickup reset stack pointer
  0x800'39f8: 0x6809          LDR      R1, [R1]
  //     STR     r1, [r0]                                ; Save system stack pointer
  0x800'39fa: 0x6001          STR      R1, [R0]
  //     MOV     r0, #0xE000E000                         ; Build address of NVIC registers
  0x800'39fc: 0xf04f 0x20e0   MOV.W    R0, #-536813568        ; 0xe000'e000
  //     LDR     r1, =SYSTICK_CYCLES
  0x800'3a00: 0x490f          LDR.N    R1, [PC, #0x3c]        ; SYSTICK_CYCLES
  //     STR     r1, [r0, #0x14]                         ; Setup SysTick Reload Value
  0x800'3a02: 0x6141          STR      R1, [R0, #0x14]
  //     MOV     r1, #0x7                                ; Build SysTick Control Enable Value
  0x800'3a04: 0xf04f 0x0107   MOV.W    R1, #7
  //     STR     r1, [r0, #0x10]                         ; Setup SysTick Control
  0x800'3a08: 0x6101          STR      R1, [R0, #0x10]
  //     LDR     r1, =0x00000000                         ; Rsrv, UsgF, BusF, MemM
  0x800'3a0a: 0x2100          MOVS     R1, #0
  //     STR     r1, [r0, #0xD18]                        ; Setup System Handlers 4-7 Priority Registers
  0x800'3a0c: 0xf8c0 0x1d18   STR.W    R1, [R0, #0xd18]
  //     LDR     r1, =0xFF000000                         ; SVCl, Rsrv, Rsrv, Rsrv
  0x800'3a10: 0x490c          LDR.N    R1, [PC, #0x30]        ; 0xff00'0000
  //     STR     r1, [r0, #0xD1C]                        ; Setup System Handlers 8-11 Priority Registers
  0x800'3a12: 0xf8c0 0x1d1c   STR.W    R1, [R0, #0xd1c]
  //     LDR     r1, =0x40FF0000                         ; SysT, PnSV, Rsrv, DbgM
  0x800'3a16: 0x490c          LDR.N    R1, [PC, #0x30]        ; 0x40ff'0000
  //     STR     r1, [r0, #0xD20]                        ; Setup System Handlers 12-15 Priority Registers
  0x800'3a18: 0xf8c0 0x1d20   STR.W    R1, [R0, #0xd20]
  //     BX      lr
  0x800'3a1c: 0x4770          BX       LR
                SysTick_Handler:
                __tx_SysTickHandler:
  //     PUSH    {r0, lr}
  0x800'3a1e: 0xb501          PUSH     {R0, LR}
  //     BL      _tx_timer_interrupt
  0x800'3a20: 0xf000 0xf87a   BL       _tx_timer_interrupt    ; 0x800'3b18
  //     POP     {r0, lr}
  0x800'3a24: 0xe8bd 0x4001   POP.W    {R0, LR}
  //     BX      LR
  0x800'3a28: 0x4770          BX       LR
  0x800'3a2a: 0x0000          MOVS     R0, R0
                `$d.32`:
  //     END
  0x800'3a2c: 0x2000'2430     DC32     __tx_free_memory_start
  //     END
  0x800'3a30: 0x2000'244c     DC32     _tx_initialize_unused_memory
  //     END
  0x800'3a34: 0xe000'1000     DC32     0xe000'1000            ; '....'
  //     END
  0x800'3a38: 0x0800'0000     DC32     __vector_table
  //     END
  0x800'3a3c: 0x2000'2450     DC32     _tx_thread_system_stack_ptr
  //     END
  0x800'3a40: 0x0002'903f     DC32     SYSTICK_CYCLES
  //     END
  0x800'3a44: 0xff00'0000     DC32     0xff00'0000            ; '....'
  //     END
  0x800'3a48: 0x40ff'0000     DC32     0x40ff'0000            ; '...@'
                $t:
                `.text25`:
                _tx_initialize_high_level:
  // VOID    _tx_initialize_high_level(VOID)
  // {
  0x800'3a4c: 0xb580          PUSH     {R7, LR}
  //     _tx_thread_initialize();
  0x800'3a4e: 0xf000 0xf8bf   BL       _tx_thread_initialize  ; 0x800'3bd0
  //     _tx_timer_initialize();
  0x800'3a52: 0xf000 0xf8cd   BL       _tx_timer_initialize   ; 0x800'3bf0
  // }
  0x800'3a56: 0xbd01          POP      {R0, PC}
                `.text6`:
                _tx_thread_schedule:
  //     MOV     r0, #0                                  // Build value for TX_FALSE
  0x800'3a58: 0xf04f 0x0000   MOV.W    R0, #0
  //     LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  0x800'3a5c: 0x4a2a          LDR.N    R2, [PC, #0xa8]        ; _tx_thread_preempt_disable
  //     STR     r0, [r2, #0]                            // Clear preempt disable flag
  0x800'3a5e: 0x6010          STR      R0, [R2]
  //     MRS     r0, CONTROL                             // Pickup current CONTROL register
  0x800'3a60: 0xf3ef 0x8014   MRS      R0, CONTROL
  //     BIC     r0, r0, #4                              // Clear the FPCA bit
  0x800'3a64: 0xf020 0x0004   BIC.W    R0, R0, #4
  //     MSR     CONTROL, r0                             // Setup new CONTROL register
  0x800'3a68: 0xf380 0x8814   MSR      CONTROL, R0
  //     CPSIE   i
  0x800'3a6c: 0xb662          CPSIE    i
  //     MOV     r0, #0x10000000                         // Load PENDSVSET bit
  0x800'3a6e: 0xf04f 0x5080   MOV.W    R0, #268435456         ; 0x1000'0000
  //     MOV     r1, #0xE000E000                         // Load NVIC base
  0x800'3a72: 0xf04f 0x21e0   MOV.W    R1, #-536813568        ; 0xe000'e000
  //     STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
  0x800'3a76: 0xf8c1 0x0d04   STR.W    R0, [R1, #0xd04]
  //     DSB                                             // Complete all memory accesses
  0x800'3a7a: 0xf3bf 0x8f4f   DSB
  //     ISB                                             // Flush pipeline
  0x800'3a7e: 0xf3bf 0x8f6f   ISB
                __tx_wait_here:
  //     B       __tx_wait_here                          // Wait for the PendSV to happen
  0x800'3a82: 0xe7fe          B.N      __tx_wait_here         ; 0x800'3a82
                __tx_ts_handler:
                PendSV_Handler:
                __tx_PendSVHandler:
  //     LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  0x800'3a84: 0x4821          LDR.N    R0, [PC, #0x84]        ; _tx_thread_current_ptr
  //     LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  0x800'3a86: 0x4a22          LDR.N    R2, [PC, #0x88]        ; _tx_thread_execute_ptr
  //     MOV     r3, #0                                  // Build NULL value
  0x800'3a88: 0xf04f 0x0300   MOV.W    R3, #0
  //     LDR     r1, [r0]                                // Pickup current thread pointer
  0x800'3a8c: 0x6801          LDR      R1, [R0]
  //     CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
  0x800'3a8e: 0xb191          CBZ      R1, __tx_ts_new        ; 0x800'3ab6
  //     STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
  0x800'3a90: 0x6003          STR      R3, [R0]
  //     MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
  0x800'3a92: 0xf3ef 0x8c09   MRS      R12, PSP
  //     STMDB   r12!, {r4-r11}                          // Save its remaining registers
  0x800'3a96: 0xe92c 0x0ff0   STMDB    R12!, {R4-R11}
  //     TST     LR, #0x10                               // Determine if the VFP extended frame is present
  0x800'3a9a: 0xf01e 0x0f10   TST.W    LR, #16                ; 0x10
  //     BNE     _skip_vfp_save
  0x800'3a9e: 0xd101          BNE.N    _skip_vfp_save         ; 0x800'3aa4
  //     VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
  0x800'3aa0: 0xed2c 0x8a10   VSTMDB   R12!, {S16-S31}
                _skip_vfp_save:
  //     LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  0x800'3aa4: 0x4c1b          LDR.N    R4, [PC, #0x6c]        ; _tx_timer_time_slice
  //     STMDB   r12!, {LR}                              // Save LR on the stack
  0x800'3aa6: 0xf84c 0xed04   STR.W    LR, [R12, #-0x4]!
  //     LDR     r5, [r4]                                // Pickup current time-slice
  0x800'3aaa: 0x6825          LDR      R5, [R4]
  //     STR     r12, [r1, #8]                           // Save the thread stack pointer
  0x800'3aac: 0xf8c1 0xc008   STR.W    R12, [R1, #0x8]
  //     CBZ     r5, __tx_ts_new                         // If not active, skip processing
  0x800'3ab0: 0xb10d          CBZ      R5, __tx_ts_new        ; 0x800'3ab6
  //     STR     r5, [r1, #24]                           // Save current time-slice
  0x800'3ab2: 0x618d          STR      R5, [R1, #0x18]
  //     STR     r3, [r4]                                // Clear time-slice
  0x800'3ab4: 0x6023          STR      R3, [R4]
                __tx_ts_new:
  //     CPSID   i                                       // Disable interrupts
  0x800'3ab6: 0xb672          CPSID    i
  //     LDR     r1, [r2]                                // Is there another thread ready to execute?
  0x800'3ab8: 0x6811          LDR      R1, [R2]
  //     CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
  0x800'3aba: 0xb1b1          CBZ      R1, __tx_ts_wait       ; 0x800'3aea
  //     STR     r1, [r0]                                // Setup the current thread pointer to the new thread
  0x800'3abc: 0x6001          STR      R1, [R0]
  //     CPSIE   i                                       // Enable interrupts
  0x800'3abe: 0xb662          CPSIE    i
                __tx_ts_restore:
  //     LDR     r7, [r1, #4]                            // Pickup the current thread run count
  0x800'3ac0: 0x684f          LDR      R7, [R1, #0x4]
  //     LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  0x800'3ac2: 0x4c14          LDR.N    R4, [PC, #0x50]        ; _tx_timer_time_slice
  //     LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
  0x800'3ac4: 0x698d          LDR      R5, [R1, #0x18]
  //     ADD     r7, r7, #1                              // Increment the thread run count
  0x800'3ac6: 0xf107 0x0701   ADD.W    R7, R7, #1
  //     STR     r7, [r1, #4]                            // Store the new run count
  0x800'3aca: 0x604f          STR      R7, [R1, #0x4]
  //     STR     r5, [r4]                                // Setup global time-slice
  0x800'3acc: 0x6025          STR      R5, [R4]
  //     LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
  0x800'3ace: 0xf8d1 0xc008   LDR.W    R12, [R1, #0x8]
  //     LDMIA   r12!, {LR}                              // Pickup LR
  0x800'3ad2: 0xf85c 0xeb04   LDR.W    LR, [R12], #0x4
  //     TST     LR, #0x10                               // Determine if the VFP extended frame is present
  0x800'3ad6: 0xf01e 0x0f10   TST.W    LR, #16                ; 0x10
  //     BNE     _skip_vfp_restore                       // If not, skip VFP restore
  0x800'3ada: 0xd101          BNE.N    _skip_vfp_restore      ; 0x800'3ae0
  //     VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
  0x800'3adc: 0xecbc 0x8a10   VLDM     R12!,{S16-S31}
                _skip_vfp_restore:
  //     LDMIA   r12!, {r4-r11}                          // Recover thread's registers
  0x800'3ae0: 0xe8bc 0x0ff0   LDM      R12!, {R4-R11}
  //     MSR     PSP, r12                                // Setup the thread's stack pointer
  0x800'3ae4: 0xf38c 0x8809   MSR      PSP, R12
  //     BX      lr                                      // Return to thread!
  0x800'3ae8: 0x4770          BX       LR
                __tx_ts_wait:
  //     CPSID   i                                       // Disable interrupts
  0x800'3aea: 0xb672          CPSID    i
  //     LDR     r1, [r2]                                // Pickup the next thread to execute pointer
  0x800'3aec: 0x6811          LDR      R1, [R2]
  //     STR     r1, [r0]                                // Store it in the current pointer
  0x800'3aee: 0x6001          STR      R1, [R0]
  //     CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
  0x800'3af0: 0xb909          CBNZ     R1, __tx_ts_ready      ; 0x800'3af6
  //     CPSIE   i                                       // Enable interrupts
  0x800'3af2: 0xb662          CPSIE    i
  //     B       __tx_ts_wait                            // Loop to continue waiting
  0x800'3af4: 0xe7f9          B.N      __tx_ts_wait           ; 0x800'3aea
                __tx_ts_ready:
  //     MOV     r7, #0x08000000                         // Build clear PendSV value
  0x800'3af6: 0xf04f 0x6700   MOV.W    R7, #134217728         ; 0x800'0000
  //     MOV     r8, #0xE000E000                         // Build base NVIC address
  0x800'3afa: 0xf04f 0x28e0   MOV.W    R8, #-536813568        ; 0xe000'e000
  //     STR     r7, [r8, #0xD04]                        // Clear any PendSV
  0x800'3afe: 0xf8c8 0x7d04   STR.W    R7, [R8, #0xd04]
  //     CPSIE   i                                       // Enable interrupts
  0x800'3b02: 0xb662          CPSIE    i
  //     B       __tx_ts_restore                         // Restore the thread
  0x800'3b04: 0xe7dc          B.N      __tx_ts_restore        ; 0x800'3ac0
                tx_thread_fpu_enable:
                tx_thread_fpu_disable:
  //     BX      LR                                      // Return to caller
  0x800'3b06: 0x4770          BX       LR
                `$d.32`:
  //     END
  0x800'3b08: 0x2000'246c     DC32     _tx_thread_preempt_disable
  //     END
  0x800'3b0c: 0x2000'2454     DC32     _tx_thread_current_ptr
  //     END
  0x800'3b10: 0x2000'2458     DC32     _tx_thread_execute_ptr
  //     END
  0x800'3b14: 0x2000'24d4     DC32     _tx_timer_time_slice
                $t:
                `.text6`:
                _tx_timer_interrupt:
  //     LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
  0x800'3b18: 0x4921          LDR.N    R1, [PC, #0x84]        ; _tx_timer_system_clock
  //     LDR     r0, [r1, #0]                            // Pickup system clock
  0x800'3b1a: 0x6808          LDR      R0, [R1]
  //     ADD     r0, r0, #1                              // Increment system clock
  0x800'3b1c: 0xf100 0x0001   ADD.W    R0, R0, #1
  //     STR     r0, [r1, #0]                            // Store new system clock
  0x800'3b20: 0x6008          STR      R0, [R1]
  //     LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
  0x800'3b22: 0x4b20          LDR.N    R3, [PC, #0x80]        ; _tx_timer_time_slice
  //     LDR     r2, [r3, #0]                            // Pickup time-slice
  0x800'3b24: 0x681a          LDR      R2, [R3]
  //     CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
  0x800'3b26: 0xb13a          CBZ      R2, __tx_timer_no_time_slice
                                                              ; 0x800'3b38
  //     SUB     r2, r2, #1                              // Decrement the time-slice
  0x800'3b28: 0xf1a2 0x0201   SUB.W    R2, R2, #1
  //     STR     r2, [r3, #0]                            // Store new time-slice value
  0x800'3b2c: 0x601a          STR      R2, [R3]
  //     CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
  0x800'3b2e: 0xb91a          CBNZ     R2, __tx_timer_no_time_slice
                                                              ; 0x800'3b38
  //     LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
  0x800'3b30: 0x4b1d          LDR.N    R3, [PC, #0x74]        ; _tx_timer_expired_time_slice
  //     MOV     r0, #1                                  // Build expired value
  0x800'3b32: 0xf04f 0x0001   MOV.W    R0, #1
  //     STR     r0, [r3, #0]                            // Set time-slice expiration flag
  0x800'3b36: 0x6018          STR      R0, [R3]
                __tx_timer_no_time_slice:
  //     LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
  0x800'3b38: 0x491c          LDR.N    R1, [PC, #0x70]        ; _tx_timer_current_ptr
  //     LDR     r0, [r1, #0]                            // Pickup current timer
  0x800'3b3a: 0x6808          LDR      R0, [R1]
  //     LDR     r2, [r0, #0]                            // Pickup timer list entry
  0x800'3b3c: 0x6802          LDR      R2, [R0]
  //     CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
  0x800'3b3e: 0xb122          CBZ      R2, __tx_timer_no_timer
                                                              ; 0x800'3b4a
  //     LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
  0x800'3b40: 0x4b1b          LDR.N    R3, [PC, #0x6c]        ; _tx_timer_expired
  //     MOV     r2, #1                                  // Build expired value
  0x800'3b42: 0xf04f 0x0201   MOV.W    R2, #1
  //     STR     r2, [r3, #0]                            // Set expired flag
  0x800'3b46: 0x601a          STR      R2, [R3]
  //     B       __tx_timer_done                         // Finished timer processing
  0x800'3b48: 0xe008          B.N      __tx_timer_done        ; 0x800'3b5c
                __tx_timer_no_timer:
  //     ADD     r0, r0, #4                              // Move to next timer
  0x800'3b4a: 0xf100 0x0004   ADD.W    R0, R0, #4
  //     LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
  0x800'3b4e: 0x4b19          LDR.N    R3, [PC, #0x64]        ; _tx_timer_list_end
  //     LDR     r2, [r3, #0]                            // Pickup list end
  0x800'3b50: 0x681a          LDR      R2, [R3]
  //     CMP     r0, r2                                  // Are we at list end?
  0x800'3b52: 0x4290          CMP      R0, R2
  //     BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
  0x800'3b54: 0xd101          BNE.N    __tx_timer_skip_wrap   ; 0x800'3b5a
  //     LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
  0x800'3b56: 0x4b18          LDR.N    R3, [PC, #0x60]        ; _tx_timer_list_start
  //     LDR     r0, [r3, #0]                            // Set current pointer to list start
  0x800'3b58: 0x6818          LDR      R0, [R3]
                __tx_timer_skip_wrap:
  //     STR     r0, [r1, #0]                            // Store new current timer pointer
  0x800'3b5a: 0x6008          STR      R0, [R1]
                __tx_timer_done:
  //     LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
  0x800'3b5c: 0x4b12          LDR.N    R3, [PC, #0x48]        ; _tx_timer_expired_time_slice
  //     LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
  0x800'3b5e: 0x681a          LDR      R2, [R3]
  //     CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
  0x800'3b60: 0xb912          CBNZ     R2, __tx_something_expired
                                                              ; 0x800'3b68
  //     LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
  0x800'3b62: 0x4913          LDR.N    R1, [PC, #0x4c]        ; _tx_timer_expired
  //     LDR     r0, [r1, #0]                            // Pickup timer expired flag
  0x800'3b64: 0x6808          LDR      R0, [R1]
  //     CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
  0x800'3b66: 0xb1c0          CBZ      R0, __tx_timer_nothing_expired
                                                              ; 0x800'3b9a
                __tx_something_expired:
  //     STMDB   sp!, {r0, lr}                           // Save the lr register on the stack
  0x800'3b68: 0xb501          PUSH     {R0, LR}
  //     LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
  0x800'3b6a: 0x4911          LDR.N    R1, [PC, #0x44]        ; _tx_timer_expired
  //     LDR     r0, [r1, #0]                            // Pickup timer expired flag
  0x800'3b6c: 0x6808          LDR      R0, [R1]
  //     CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
  0x800'3b6e: 0xb108          CBZ      R0, __tx_timer_dont_activate
                                                              ; 0x800'3b74
  //     BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
  0x800'3b70: 0xf000 0xf884   BL       _tx_timer_expiration_process
                                                              ; 0x800'3c7c
                __tx_timer_dont_activate:
  //     LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
  0x800'3b74: 0x4b0c          LDR.N    R3, [PC, #0x30]        ; _tx_timer_expired_time_slice
  //     LDR     r2, [r3, #0]                            // Pickup the actual flag
  0x800'3b76: 0x681a          LDR      R2, [R3]
  //     CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
  0x800'3b78: 0xb16a          CBZ      R2, __tx_timer_skip_time_slice
                                                              ; 0x800'3b96
  //     BL      _tx_thread_time_slice                   // Call time-slice processing
  0x800'3b7a: 0xf7ff 0xf921   BL       _tx_thread_time_slice  ; 0x800'2dc0
  //     LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  0x800'3b7e: 0x480f          LDR.N    R0, [PC, #0x3c]        ; _tx_thread_preempt_disable
  //     LDR     r1, [r0]                                // Is the preempt disable flag set?
  0x800'3b80: 0x6801          LDR      R1, [R0]
  //     CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
  0x800'3b82: 0xb941          CBNZ     R1, __tx_timer_skip_time_slice
                                                              ; 0x800'3b96
  //     LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  0x800'3b84: 0x480e          LDR.N    R0, [PC, #0x38]        ; _tx_thread_current_ptr
  //     LDR     r1, [r0]                                // Pickup the current thread pointer
  0x800'3b86: 0x6801          LDR      R1, [R0]
  //     LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  0x800'3b88: 0x4a0e          LDR.N    R2, [PC, #0x38]        ; _tx_thread_execute_ptr
  //     LDR     r3, [r2]                                // Pickup the execute thread pointer
  0x800'3b8a: 0x6813          LDR      R3, [R2]
  //     LDR     r0, =0xE000ED04                         // Build address of control register
  0x800'3b8c: 0x480e          LDR.N    R0, [PC, #0x38]        ; 0xe000'ed04
  //     LDR     r2, =0x10000000                         // Build value for PendSV bit
  0x800'3b8e: 0x4a0f          LDR.N    R2, [PC, #0x3c]        ; 0x1000'0000
  //     CMP     r1, r3                                  // Are they the same?
  0x800'3b90: 0x4299          CMP      R1, R3
  //     BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
  0x800'3b92: 0xd000          BEQ.N    __tx_timer_skip_time_slice
                                                              ; 0x800'3b96
  //     STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
  0x800'3b94: 0x6002          STR      R2, [R0]
                __tx_timer_not_ts_expiration:
                __tx_timer_skip_time_slice:
  //     LDMIA   sp!, {r0, lr}                           // Recover lr register (r0 is just there for
  0x800'3b96: 0xe8bd 0x4001   POP.W    {R0, LR}
                __tx_timer_nothing_expired:
  //     DSB                                             // Complete all memory access
  0x800'3b9a: 0xf3bf 0x8f4f   DSB
  //     BX      lr                                      // Return to caller
  0x800'3b9e: 0x4770          BX       LR
                `$d.32`:
  //     END
  0x800'3ba0: 0x2000'24a0     DC32     _tx_timer_system_clock
  //     END
  0x800'3ba4: 0x2000'24d4     DC32     _tx_timer_time_slice
  //     END
  0x800'3ba8: 0x2000'24a4     DC32     _tx_timer_expired_time_slice
  //     END
  0x800'3bac: 0x2000'24b0     DC32     _tx_timer_current_ptr
  //     END
  0x800'3bb0: 0x2000'24b4     DC32     _tx_timer_expired
  //     END
  0x800'3bb4: 0x2000'24ac     DC32     _tx_timer_list_end
  //     END
  0x800'3bb8: 0x2000'24a8     DC32     _tx_timer_list_start
  //     END
  0x800'3bbc: 0x2000'246c     DC32     _tx_thread_preempt_disable
  //     END
  0x800'3bc0: 0x2000'2454     DC32     _tx_thread_current_ptr
  //     END
  0x800'3bc4: 0x2000'2458     DC32     _tx_thread_execute_ptr
  //     END
  0x800'3bc8: 0xe000'ed04     DC32     0xe000'ed04            ; '....'
  //     END
  0x800'3bcc: 0x1000'0000     DC32     0x1000'0000            ; '....'
                $t:
                `.text36`:
                _tx_thread_initialize:
  //     _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
  0x800'3bd0: 0x2120          MOVS     R1, #32                ; 0x20
  0x800'3bd2: 0x4804          LDR.N    R0, ??_tx_thread_initialize_0
                                                              ; _tx_thread_highest_priority
  0x800'3bd4: 0x6001          STR      R1, [R0]
  //     _tx_build_options =  _tx_build_options
  //                             | (((ULONG) (TX_MAX_PRIORITIES/32)) << 24)
  // #ifdef TX_NOT_INTERRUPTABLE
  //                             | (((ULONG) 1) << 31)
  // #endif
  // #ifdef TX_INLINE_THREAD_RESUME_SUSPEND
  //                             | (((ULONG) 1) << 30)
  // #endif
  // #ifdef TX_TIMER_PROCESS_IN_ISR
  //                             | (((ULONG) 1) << 23)
  // #endif
  // #ifdef TX_REACTIVATE_INLINE
  //                             | (((ULONG) 1) << 22)
  // #endif
  // #ifdef TX_DISABLE_STACK_FILLING
  //                             | (((ULONG) 1) << 21)
  // #endif
  // #ifdef TX_ENABLE_STACK_CHECKING
  //                             | (((ULONG) 1) << 20)
  // #endif
  // #ifdef TX_DISABLE_PREEMPTION_THRESHOLD
  //                             | (((ULONG) 1) << 19)
  // #endif
  // #ifdef TX_DISABLE_REDUNDANT_CLEARING
  //                             | (((ULONG) 1) << 18)
  // #endif
  // #ifdef TX_DISABLE_NOTIFY_CALLBACKS
  //                             | (((ULONG) 1) << 17)
  // #endif
  // #ifdef TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 16)
  // #endif
  // #ifdef TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 15)
  // #endif
  // #ifdef TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 14)
  // #endif
  // #ifdef TX_MUTEX_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 13)
  // #endif
  // #ifdef TX_QUEUE_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 12)
  // #endif
  // #ifdef TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 11)
  // #endif
  // #ifdef TX_THREAD_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 10)
  // #endif
  // #ifdef TX_TIMER_ENABLE_PERFORMANCE_INFO
  //                             | (((ULONG) 1) << 9)
  // #endif
  // #ifdef TX_ENABLE_EVENT_TRACE
  //                             | (((ULONG) 1) << 8)
  // #endif
  // #if defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE)
  //                             | (((ULONG) 1) << 7)
  // #endif
  // #if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
  //                             | TX_PORT_SPECIFIC_BUILD_OPTIONS
  // #endif
  //                             ;
  0x800'3bd6: 0x4a04          LDR.N    R2, [PC, #0x10]        ; _tx_build_options
  0x800'3bd8: 0x6811          LDR      R1, [R2]
  0x800'3bda: 0x4804          LDR.N    R0, [PC, #0x10]        ; 0xc15e'0e00
  0x800'3bdc: 0x4301          ORRS     R1, R1, R0
  0x800'3bde: 0x6011          STR      R1, [R2]
  // }
  0x800'3be0: 0x4770          BX       LR
  0x800'3be2: 0xbf00          NOP
                `$d.32`:
                ??_tx_thread_initialize_0:
  0x800'3be4: 0x2000'2468     DC32     _tx_thread_highest_priority
  0x800'3be8: 0x2000'2474     DC32     _tx_build_options
  0x800'3bec: 0xc15e'0e00     DC32     0xc15e'0e00            ; '..^.'
                $t:
                `.text29`:
                _tx_timer_initialize:
  // VOID  _tx_timer_initialize(VOID)
  // {
  0x800'3bf0: 0xb5f8          PUSH     {R3-R7, LR}
  0x800'3bf2: 0xb086          SUB      SP, SP, #0x18
  //     _tx_timer_list_start =   &_tx_timer_list[0];
  0x800'3bf4: 0x4915          LDR.N    R1, ??_tx_timer_initialize_0
                                                              ; _tx_timer_list
  0x800'3bf6: 0x4816          LDR.N    R0, [PC, #0x58]        ; _tx_timer_list_start
  0x800'3bf8: 0x6001          STR      R1, [R0]
  //     _tx_timer_current_ptr =  &_tx_timer_list[0];
  0x800'3bfa: 0x4816          LDR.N    R0, [PC, #0x58]        ; _tx_timer_current_ptr
  0x800'3bfc: 0x6001          STR      R1, [R0]
  //     _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
  0x800'3bfe: 0x4816          LDR.N    R0, [PC, #0x58]        ; _tx_timer_list_end
  0x800'3c00: 0x317c          ADDS     R1, R1, #124           ; 0x7c
  0x800'3c02: 0x6001          STR      R1, [R0]
  //     _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
  0x800'3c04: 0x6801          LDR      R1, [R0]
  0x800'3c06: 0x1d09          ADDS     R1, R1, #4
  0x800'3c08: 0x6001          STR      R1, [R0]
  //     _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
  0x800'3c0a: 0x4d14          LDR.N    R5, [PC, #0x50]        ; _tx_timer_stack_start
  0x800'3c0c: 0x4814          LDR.N    R0, [PC, #0x50]        ; _tx_timer_thread_stack_area
  0x800'3c0e: 0x6028          STR      R0, [R5]
  //     _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
  0x800'3c10: 0x4e14          LDR.N    R6, [PC, #0x50]        ; _tx_timer_stack_size
  0x800'3c12: 0xf44f 0x5080   MOV.W    R0, #4096              ; 0x1000
  0x800'3c16: 0x6030          STR      R0, [R6]
  //     _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
  0x800'3c18: 0x4f13          LDR.N    R7, [PC, #0x4c]        ; _tx_timer_priority
  0x800'3c1a: 0x2005          MOVS     R0, #5
  0x800'3c1c: 0x6038          STR      R0, [R7]
                ??_tx_timer_initialize_1:
  //         status =  _tx_thread_create(&_tx_timer_thread,
  //                                     TX_CONST_CHAR_TO_CHAR_POINTER_CONVERT("System Timer Thread"),
  //                                     _tx_timer_thread_entry,
  //                                     ((ULONG) TX_TIMER_ID),
  //                                     _tx_timer_stack_start, _tx_timer_stack_size,
  //                                     _tx_timer_priority, _tx_timer_priority, TX_NO_TIME_SLICE, TX_DONT_START);
  0x800'3c1e: 0x2000          MOVS     R0, #0
  0x800'3c20: 0x9005          STR      R0, [SP, #0x14]
  0x800'3c22: 0x2000          MOVS     R0, #0
  0x800'3c24: 0x9004          STR      R0, [SP, #0x10]
  0x800'3c26: 0x6838          LDR      R0, [R7]
  0x800'3c28: 0x9003          STR      R0, [SP, #0xc]
  0x800'3c2a: 0x6838          LDR      R0, [R7]
  0x800'3c2c: 0x9002          STR      R0, [SP, #0x8]
  0x800'3c2e: 0x6830          LDR      R0, [R6]
  0x800'3c30: 0x9001          STR      R0, [SP, #0x4]
  0x800'3c32: 0x6828          LDR      R0, [R5]
  0x800'3c34: 0x9000          STR      R0, [SP]
  0x800'3c36: 0x4b0d          LDR.N    R3, [PC, #0x34]        ; 0x4154'494d
  0x800'3c38: 0x4a0d          LDR.N    R2, [PC, #0x34]        ; _tx_timer_thread_entry
  0x800'3c3a: 0x490e          LDR.N    R1, [PC, #0x38]        ; ?_0
  0x800'3c3c: 0x480e          LDR.N    R0, [PC, #0x38]        ; _tx_timer_thread
  0x800'3c3e: 0xf7fe 0xfe9d   BL       _tx_thread_create      ; 0x800'297c
  0x800'3c42: 0x0004          MOVS     R4, R0
  //     } while (status != TX_SUCCESS);
  0x800'3c44: 0x2c00          CMP      R4, #0
  0x800'3c46: 0xd1ea          BNE.N    ??_tx_timer_initialize_1
                                                              ; 0x800'3c1e
  // }
  0x800'3c48: 0xb007          ADD      SP, SP, #0x1c
  0x800'3c4a: 0xbdf0          POP      {R4-R7, PC}
                `$d.32`:
                ??_tx_timer_initialize_0:
  0x800'3c4c: 0x2000'22cc     DC32     _tx_timer_list
  0x800'3c50: 0x2000'24a8     DC32     _tx_timer_list_start
  0x800'3c54: 0x2000'24b0     DC32     _tx_timer_current_ptr
  0x800'3c58: 0x2000'24ac     DC32     _tx_timer_list_end
  0x800'3c5c: 0x2000'24bc     DC32     _tx_timer_stack_start
  0x800'3c60: 0x2000'1018     DC32     _tx_timer_thread_stack_area
  0x800'3c64: 0x2000'24c0     DC32     _tx_timer_stack_size
  0x800'3c68: 0x2000'24c4     DC32     _tx_timer_priority
  0x800'3c6c: 0x4154'494d     DC32     0x4154'494d            ; 'MITA'
  0x800'3c70: 0x0800'2719     DC32     _tx_timer_thread_entry
  0x800'3c74: 0x0800'4030     DC32     ?_0
  0x800'3c78: 0x2000'20f0     DC32     _tx_timer_thread
                $t:
                `.text8`:
                _tx_timer_expiration_process:
  // VOID  _tx_timer_expiration_process(VOID)
  // {
  0x800'3c7c: 0xb510          PUSH     {R4, LR}
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3c7e: 0xf3ef 0x8410   MRS      R4, PRIMASK
  //     return(posture);
  0x800'3c82: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3c84: 0x4803          LDR.N    R0, ??_tx_timer_expiration_process_0
                                                              ; _tx_timer_thread
  0x800'3c86: 0xf7fe 0xf941   BL       _tx_thread_system_ni_resume
                                                              ; 0x800'1f0c
  //     TX_RESTORE
  0x800'3c8a: 0x0020          MOVS     R0, R4
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3c8c: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'3c90: 0xbd10          POP      {R4, PC}
  0x800'3c92: 0xbf00          NOP
                `$d.32`:
                ??_tx_timer_expiration_process_0:
  0x800'3c94: 0x2000'20f0     DC32     _tx_timer_thread
                $t:
                `.text8`:
                _tx_byte_pool_cleanup:
  // VOID  _tx_byte_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
  // {
  0x800'3c98: 0xe92d 0x43f8   PUSH.W   {R3-R9, LR}
  0x800'3c9c: 0x0005          MOVS     R5, R0
  0x800'3c9e: 0x000e          MOVS     R6, R1
  //                         pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
  0x800'3ca0: 0xf8d5 0x906c   LDR.W    R9, [R5, #0x6c]
  //                         thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
  0x800'3ca4: 0x2000          MOVS     R0, #0
  0x800'3ca6: 0x66a8          STR      R0, [R5, #0x68]
  //                         pool_ptr -> tx_byte_pool_suspended_count--;
  0x800'3ca8: 0xf8d9 0x0028   LDR.W    R0, [R9, #0x28]
  0x800'3cac: 0x1e40          SUBS     R0, R0, #1
  0x800'3cae: 0xf8c9 0x0028   STR.W    R0, [R9, #0x28]
  //                         suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
  0x800'3cb2: 0xf8d9 0x4028   LDR.W    R4, [R9, #0x28]
  //                         if (suspended_count == TX_NO_SUSPENSIONS)
  0x800'3cb6: 0x2c00          CMP      R4, #0
  0x800'3cb8: 0xd103          BNE.N    ??_tx_byte_pool_cleanup_0
                                                              ; 0x800'3cc2
  //                             pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
  0x800'3cba: 0x2000          MOVS     R0, #0
  0x800'3cbc: 0xf8c9 0x0024   STR.W    R0, [R9, #0x24]
  0x800'3cc0: 0xe00d          B.N      ??_tx_byte_pool_cleanup_1
                                                              ; 0x800'3cde
                ??_tx_byte_pool_cleanup_0:
  //                             next_thread =                                   thread_ptr -> tx_thread_suspended_next;
  0x800'3cc2: 0x6f28          LDR      R0, [R5, #0x70]
  0x800'3cc4: 0x0007          MOVS     R7, R0
  //                             previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
  0x800'3cc6: 0x6f68          LDR      R0, [R5, #0x74]
  0x800'3cc8: 0x4680          MOV      R8, R0
  //                             next_thread -> tx_thread_suspended_previous =   previous_thread;
  0x800'3cca: 0xf8c7 0x8074   STR.W    R8, [R7, #0x74]
  //                             previous_thread -> tx_thread_suspended_next =   next_thread;
  0x800'3cce: 0xf8c8 0x7070   STR.W    R7, [R8, #0x70]
  //                             if (pool_ptr -> tx_byte_pool_suspension_list == thread_ptr)
  0x800'3cd2: 0xf8d9 0x0024   LDR.W    R0, [R9, #0x24]
  0x800'3cd6: 0x42a8          CMP      R0, R5
  0x800'3cd8: 0xd101          BNE.N    ??_tx_byte_pool_cleanup_1
                                                              ; 0x800'3cde
  //                                 pool_ptr -> tx_byte_pool_suspension_list =      next_thread;
  0x800'3cda: 0xf8c9 0x7024   STR.W    R7, [R9, #0x24]
                ??_tx_byte_pool_cleanup_1:
  //                         if (thread_ptr -> tx_thread_state == TX_BYTE_MEMORY)
  0x800'3cde: 0x6b28          LDR      R0, [R5, #0x30]
  0x800'3ce0: 0x2809          CMP      R0, #9
  0x800'3ce2: 0xd105          BNE.N    ??_tx_byte_pool_cleanup_2
                                                              ; 0x800'3cf0
  //                             thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
  0x800'3ce4: 0x2010          MOVS     R0, #16                ; 0x10
  0x800'3ce6: 0xf8c5 0x0084   STR.W    R0, [R5, #0x84]
  //                             _tx_thread_system_ni_resume(thread_ptr);
  0x800'3cea: 0x0028          MOVS     R0, R5
  0x800'3cec: 0xf7fe 0xf90e   BL       _tx_thread_system_ni_resume
                                                              ; 0x800'1f0c
                ??_tx_byte_pool_cleanup_2:
  // }
  0x800'3cf0: 0xe8bd 0x83f1   POP.W    {R0, R4-R9, PC}
                `.text8`:
                _tx_thread_timeout:
  // VOID  _tx_thread_timeout(ULONG timeout_input)
  // {
  0x800'3cf4: 0xe92d 0x41f0   PUSH.W   {R4-R8, LR}
  0x800'3cf8: 0x0004          MOVS     R4, R0
  //     TX_THREAD_TIMEOUT_POINTER_SETUP(thread_ptr)
  0x800'3cfa: 0x0027          MOVS     R7, R4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3cfc: 0xf3ef 0x8810   MRS      R8, PRIMASK
  //     return(posture);
  0x800'3d00: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3d02: 0x6b38          LDR      R0, [R7, #0x30]
  0x800'3d04: 0x2804          CMP      R0, #4
  0x800'3d06: 0xd106          BNE.N    ??_tx_thread_timeout_1 ; 0x800'3d16
  //         _tx_thread_system_ni_resume(thread_ptr);
  0x800'3d08: 0x0038          MOVS     R0, R7
  0x800'3d0a: 0xf7fe 0xf8ff   BL       _tx_thread_system_ni_resume
                                                              ; 0x800'1f0c
  //         TX_RESTORE
  0x800'3d0e: 0x4640          MOV      R0, R8
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3d10: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'3d14: 0xe015          B.N      ??_tx_thread_timeout_2 ; 0x800'3d42
                ??_tx_thread_timeout_1:
  //         _tx_thread_performance_timeout_count++;
  0x800'3d16: 0x490c          LDR.N    R1, ??_tx_thread_timeout_0
                                                              ; _tx_thread_performance_timeout_count
  0x800'3d18: 0x6808          LDR      R0, [R1]
  0x800'3d1a: 0x1c40          ADDS     R0, R0, #1
  0x800'3d1c: 0x6008          STR      R0, [R1]
  //         thread_ptr -> tx_thread_performance_timeout_count++;
  0x800'3d1e: 0xf8d7 0x00c4   LDR.W    R0, [R7, #0xc4]
  0x800'3d22: 0x1c40          ADDS     R0, R0, #1
  0x800'3d24: 0xf8c7 0x00c4   STR.W    R0, [R7, #0xc4]
  //         suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
  0x800'3d28: 0x6eb8          LDR      R0, [R7, #0x68]
  0x800'3d2a: 0x0005          MOVS     R5, R0
  //         suspension_sequence =  ((ULONG) 0);
  0x800'3d2c: 0x2000          MOVS     R0, #0
  0x800'3d2e: 0x0006          MOVS     R6, R0
  //         if (suspend_cleanup != TX_NULL)
  0x800'3d30: 0x0028          MOVS     R0, R5
  0x800'3d32: 0x2800          CMP      R0, #0
  0x800'3d34: 0xd002          BEQ.N    ??_tx_thread_timeout_3 ; 0x800'3d3c
  //             (suspend_cleanup)(thread_ptr, suspension_sequence);
  0x800'3d36: 0x0031          MOVS     R1, R6
  0x800'3d38: 0x0038          MOVS     R0, R7
  0x800'3d3a: 0x47a8          BLX      R5
                ??_tx_thread_timeout_3:
  //         TX_RESTORE
  0x800'3d3c: 0x4640          MOV      R0, R8
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3d3e: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_timeout_2:
  // }
  0x800'3d42: 0xe8bd 0x81f0   POP.W    {R4-R8, PC}
  0x800'3d46: 0xbf00          NOP
                `$d.32`:
                ??_tx_thread_timeout_0:
  0x800'3d48: 0x2000'2490     DC32     _tx_thread_performance_timeout_count
                $t:
                `.text8`:
                _tx_thread_shell_entry:
  // VOID  _tx_thread_shell_entry(VOID)
  // {
  0x800'3d4c: 0xb570          PUSH     {R4-R6, LR}
  //     TX_THREAD_GET_CURRENT(thread_ptr)
  0x800'3d4e: 0x480f          LDR.N    R0, ??_tx_thread_shell_entry_0
                                                              ; _tx_thread_current_ptr
  0x800'3d50: 0x6804          LDR      R4, [R0]
  //     (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
  0x800'3d52: 0x6ca0          LDR      R0, [R4, #0x48]
  0x800'3d54: 0x6c61          LDR      R1, [R4, #0x44]
  0x800'3d56: 0x4788          BLX      R1
  //     if (_tx_thread_mutex_release != TX_NULL)
  0x800'3d58: 0x490d          LDR.N    R1, [PC, #0x34]        ; _tx_thread_mutex_release
  0x800'3d5a: 0x6808          LDR      R0, [R1]
  0x800'3d5c: 0x2800          CMP      R0, #0
  0x800'3d5e: 0xd002          BEQ.N    ??_tx_thread_shell_entry_1
                                                              ; 0x800'3d66
  //         (_tx_thread_mutex_release)(thread_ptr);
  0x800'3d60: 0x0020          MOVS     R0, R4
  0x800'3d62: 0x6809          LDR      R1, [R1]
  0x800'3d64: 0x4788          BLX      R1
                ??_tx_thread_shell_entry_1:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'3d66: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'3d6a: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'3d6c: 0x2001          MOVS     R0, #1
  0x800'3d6e: 0x6320          STR      R0, [R4, #0x30]
  //     TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
  0x800'3d70: 0xf3ef 0x8614   MRS      R6, CONTROL
  //     TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
  0x800'3d74: 0xf036 0x0604   BICS.W   R6, R6, #4
  //     TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
  0x800'3d78: 0xf386 0x8814   MSR      CONTROL, R6
  //     _tx_thread_system_ni_suspend(thread_ptr, ((ULONG) 0));
  0x800'3d7c: 0x2100          MOVS     R1, #0
  0x800'3d7e: 0x0020          MOVS     R0, R4
  0x800'3d80: 0xf7fe 0xfafc   BL       _tx_thread_system_ni_suspend
                                                              ; 0x800'237c
  //     TX_RESTORE
  0x800'3d84: 0x0028          MOVS     R0, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'3d86: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'3d8a: 0xbd70          POP      {R4-R6, PC}
                `$d.32`:
                ??_tx_thread_shell_entry_0:
  0x800'3d8c: 0x2000'2454     DC32     _tx_thread_current_ptr
  0x800'3d90: 0x2000'2470     DC32     _tx_thread_mutex_release
                `$d.8`:
                ?_0:
  0x800'3d94: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'3da8: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'3dbc: 0x32 0x66 0x34  DC8      "2f4xx_hal_uart.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x75 0x61
              0x72 0x74 0x2e
              0x63 0x00
                $d:
  0x800'3dcd: 0x00            DC8      0                      ; '.'
  0x800'3dce: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                ?_0:
  0x800'3dd0: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'3de4: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'3df8: 0x32 0x66 0x34  DC8      "2f4xx_hal_gpio.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x67 0x70
              0x69 0x6f 0x2e
              0x63 0x00
                $d:
  0x800'3e09: 0x00            DC8      0                      ; '.'
  0x800'3e0a: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                ?_0:
  0x800'3e0c: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'3e20: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'3e34: 0x32 0x66 0x34  DC8      "2f4xx_hal_cortex.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x63 0x6f
              0x72 0x74 0x65
              0x78 0x2e 0x63
              0x00
  0x800'3e47: 0x00            DC8      0                      ; '.'
                ?_0:
  0x800'3e48: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'3e5c: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'3e70: 0x32 0x66 0x34  DC8      "2f4xx_hal_tim.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x74 0x69
              0x6d 0x2e 0x63
              0x00
                $t:
                `.text7`:
                __iar_zero_init3:
  0x800'3e80: 0xb430          PUSH     {R4, R5}
  0x800'3e82: 0x2400          MOVS     R4, #0
  0x800'3e84: 0xe012          B.N      ??__iar_zero_init3_1   ; 0x800'3eac
                ??__iar_zero_init3_3:
  0x800'3e86: 0xf850 0x3b04   LDR.W    R3, [R0], #0x4
  0x800'3e8a: 0x07da          LSLS     R2, R3, #31
  0x800'3e8c: 0xbf44          ITT      MI
  0x800'3e8e: 0x444b          ADDMI    R3, R3, R9
  0x800'3e90: 0x1e5b          SUBMI    R3, R3, #1
                ??__iar_zero_init3_2:
  0x800'3e92: 0x1f09          SUBS     R1, R1, #4
  0x800'3e94: 0x2904          CMP      R1, #4
  0x800'3e96: 0xf843 0x4b04   STR.W    R4, [R3], #0x4
  0x800'3e9a: 0xd2fa          BCS.N    ??__iar_zero_init3_2   ; 0x800'3e92
  0x800'3e9c: 0x461a          MOV      R2, R3
  0x800'3e9e: 0x078d          LSLS     R5, R1, #30
  0x800'3ea0: 0xbf44          ITT      MI
  0x800'3ea2: 0x801c          STRHMI   R4, [R3]
  0x800'3ea4: 0x1c92          ADDMI    R2, R2, #2
  0x800'3ea6: 0x07cb          LSLS     R3, R1, #31
  0x800'3ea8: 0xbf48          IT       MI
  0x800'3eaa: 0x7014          STRBMI   R4, [R2]
                ??__iar_zero_init3_1:
  0x800'3eac: 0xf850 0x1b04   LDR.W    R1, [R0], #0x4
  0x800'3eb0: 0x2900          CMP      R1, #0
  0x800'3eb2: 0xd1e8          BNE.N    ??__iar_zero_init3_3   ; 0x800'3e86
  0x800'3eb4: 0xbc30          POP      {R4, R5}
  0x800'3eb6: 0x4770          BX       LR
                `.text6`:
                __iar_data_init3:
  0x800'3eb8: 0xb510          PUSH     {R4, LR}
  0x800'3eba: 0x4a03          LDR.N    R2, ??__iar_data_init3_0
                                                              ; 0x40 (64)
  0x800'3ebc: 0x447a          ADD      R2, R2, PC
  0x800'3ebe: 0x3208          ADDS     R2, R2, #8
  0x800'3ec0: 0x4c02          LDR.N    R4, [PC, #0x8]         ; 0x60 (96)
  0x800'3ec2: 0x447c          ADD      R4, R4, PC
  0x800'3ec4: 0x1da4          ADDS     R4, R4, #6
  0x800'3ec6: 0xe003          B.N      ?Subroutine0           ; 0x800'3ed0
                `$d.32`:
                ??__iar_data_init3_0:
  0x800'3ec8: 0x0000'0040     DC32     64                     ; '@...'
  0x800'3ecc: 0x0000'0060     DC32     96                     ; '`...'
                $t:
                `.text_4`:
                ?Subroutine0:
  0x800'3ed0: 0xe004          B.N      ??Subroutine0_0        ; 0x800'3edc
                ??Subroutine0_1:
  0x800'3ed2: 0x6811          LDR      R1, [R2]
  0x800'3ed4: 0x1d10          ADDS     R0, R2, #4
  0x800'3ed6: 0x4411          ADD      R1, R1, R2
  0x800'3ed8: 0x4788          BLX      R1
  0x800'3eda: 0x4602          MOV      R2, R0
                ??Subroutine0_0:
  0x800'3edc: 0x42a2          CMP      R2, R4
  0x800'3ede: 0xd1f8          BNE.N    ??Subroutine0_1        ; 0x800'3ed2
  0x800'3ee0: 0xbd10          POP      {R4, PC}
  0x800'3ee2: 0x0000          MOVS     R0, R0
                `.text6`:
                __iar_init_vfp:
  0x800'3ee4: 0xf64e 0x5188   MOVW     R1, #60808             ; 0xed88
  0x800'3ee8: 0xf2ce 0x0100   MOVT     R1, #57344             ; 0xe000
  0x800'3eec: 0x6808          LDR      R0, [R1]
  0x800'3eee: 0xf440 0x0070   ORR.W    R0, R0, #15728640      ; 0xf0'0000
  0x800'3ef2: 0x6008          STR      R0, [R1]
  0x800'3ef4: 0xf3bf 0x8f4f   DSB
  0x800'3ef8: 0xf3bf 0x8f6f   ISB
  0x800'3efc: 0xf04f 0x7001   MOV.W    R0, #33816576          ; 0x204'0000
  0x800'3f00: 0xeee1 0x0a10   VMSR     FPSCR, R0
  0x800'3f04: 0x4770          BX       LR
  0x800'3f06: 0x0000          MOVS     R0, R0
                $d:
                Region$$Table$$Base:
                `.iar.init_table$$Base`:
  0x800'3f08: 0xffff'ff79     DC32     -135                   ; 'y...'
  0x800'3f0c: 0x0000'24c0     DC32     9408                   ; '.$..'
  0x800'3f10: 0x2000'0018     DC32     `tx_application_define::tx_memory`
  0x800'3f14: 0x0000'0000     DC32     0                      ; '....'
  0x800'3f18: 0xffff'd8ab     DC32     -10069                 ; '....'
  0x800'3f1c: 0x0000'0018     DC32     24                     ; '....'
  0x800'3f20: 0x0000'00a8     DC32     168                    ; '....'
  0x800'3f24: 0x2000'0000     DC32     uwTickPrio
  0x800'3f28: 0x0000'0000     DC32     0                      ; '....'
                $t:
                `.text6`:
                Region$$Table$$Limit:
                `.iar.init_table$$Limit`:
                putchar:
  0x800'3f2c: 0xb580          PUSH     {R7, LR}
  0x800'3f2e: 0xf88d 0x0000   STRB.W   R0, [SP]
  0x800'3f32: 0x2201          MOVS     R2, #1
  0x800'3f34: 0x4669          MOV      R1, SP
  0x800'3f36: 0x2001          MOVS     R0, #1
  0x800'3f38: 0xf7ff 0xface   BL       __write                ; 0x800'34d8
  0x800'3f3c: 0x2801          CMP      R0, #1
  0x800'3f3e: 0xd102          BNE.N    ??putchar_0            ; 0x800'3f46
  0x800'3f40: 0xf89d 0x0000   LDRB.W   R0, [SP]
  0x800'3f44: 0xbd02          POP      {R1, PC}
                ??putchar_0:
  0x800'3f46: 0xf04f 0x30ff   MOV.W    R0, #-1                ; 0xffff'ffff
  0x800'3f4a: 0xbd02          POP      {R1, PC}
                `.text8`:
                __cmain:
                ?main:
  0x800'3f4c: 0xf000 0xf80d   BL       __low_level_init       ; 0x800'3f6a
  0x800'3f50: 0x2800          CMP      R0, #0
  0x800'3f52: 0xd001          BEQ.N    _call_main             ; 0x800'3f58
  0x800'3f54: 0xf7ff 0xffb0   BL       __iar_data_init3       ; 0x800'3eb8
                `.text_3`:
                _call_main:
  0x800'3f58: 0xf3af 0x8000   NOP.W
  0x800'3f5c: 0x2000          MOVS     R0, #0
  0x800'3f5e: 0xf3af 0x8000   NOP.W
  0x800'3f62: 0xf7ff 0xfb09   BL       main                   ; 0x800'3578
  0x800'3f66: 0xf000 0xf802   BL       exit                   ; 0x800'3f6e
                `.text6`:
                __low_level_init:
  0x800'3f6a: 0x2001          MOVS     R0, #1
  0x800'3f6c: 0x4770          BX       LR
                `.text6`:
                exit:
  0x800'3f6e: 0xf000 0xb801   B.W      _exit                  ; 0x800'3f74
  0x800'3f72: 0x0000          MOVS     R0, R0
                `.text6`:
                _exit:
  0x800'3f74: 0x4607          MOV      R7, R0
                `.text_4`:
                @8003f76:
  0x800'3f76: 0x4638          MOV      R0, R7
  0x800'3f78: 0xf000 0xf802   BL       __exit                 ; 0x800'3f80
  0x800'3f7c: 0xe7fb          B.N      @8003f76
  0x800'3f7e: 0x0000          MOVS     R0, R0
                `.text6`:
                __exit:
  0x800'3f80: 0xb580          PUSH     {R7, LR}
  0x800'3f82: 0xf3af 0x8000   NOP.W
  0x800'3f86: 0x4a02          LDR.N    R2, ??__exit_1         ; 0x2'0026
                ??__exit_0:
  0x800'3f88: 0x0011          MOVS     R1, R2
  0x800'3f8a: 0x2018          MOVS     R0, #24                ; 0x18
  0x800'3f8c: 0xbeab          BKPT     #0xab
  0x800'3f8e: 0xe7fb          B.N      ??__exit_0             ; 0x800'3f88
                `$d.32`:
                ??__exit_1:
  0x800'3f90: 0x0002'0026     DC32     0x2'0026               ; '&...'
                $t:
                `.text6`:
                __iar_program_start:
  0x800'3f94: 0x4805          LDR.N    R0, [PC, #0x14]        ; 0xfef5'eda5
  0x800'3f96: 0x4601          MOV      R1, R0
  0x800'3f98: 0xb403          PUSH     {R0, R1}
  0x800'3f9a: 0x4668          MOV      R0, SP
  0x800'3f9c: 0xf380 0x8809   MSR      PSP, R0
  0x800'3fa0: 0xf3af 0x8000   NOP.W
  0x800'3fa4: 0xf7ff 0xff9e   BL       __iar_init_vfp         ; 0x800'3ee4
  0x800'3fa8: 0xf7ff 0xffd0   BL       ?main                  ; 0x800'3f4c
                `$d.32`:
  0x800'3fac: 0xfef5'eda5     DC32     0xfef5'eda5            ; '....'
                $t:
                `.text6`:
                _Prout:
  0x800'3fb0: 0xb538          PUSH     {R3-R5, LR}
  0x800'3fb2: 0x4605          MOV      R5, R0
  0x800'3fb4: 0x460c          MOV      R4, R1
  0x800'3fb6: 0x4620          MOV      R0, R4
  0x800'3fb8: 0xf7ff 0xffb8   BL       putchar                ; 0x800'3f2c
  0x800'3fbc: 0x42a0          CMP      R0, R4
  0x800'3fbe: 0xbf18          IT       NE
  0x800'3fc0: 0x2500          MOVNE    R5, #0
  0x800'3fc2: 0x4628          MOV      R0, R5
  0x800'3fc4: 0xbd32          POP      {R1, R4, R5, PC}
  0x800'3fc6: 0x0000          MOVS     R0, R0
                $d:
  0x800'3fc8: 0x0000'0010     DC32     16                     ; '....'
  0x800'3fcc: 0x00f4'2400     DC32     0xf4'2400              ; '.$..'
  0x800'3fd0: 0xf0f0'f0f0     DC32     0xf0f0'f0f0            ; '....'
  0x800'3fd4: 0x0000'0000     DC32     0                      ; '....'
  0x800'3fd8: 0x0000'0001     DC32     1                      ; '....'
  0x800'3fdc: 0x0000'0001     DC32     1                      ; '....'
                `$d.8`:
                ?_1:
  0x800'3fe0: 0x68 0x65 0x6c  DC8      'hello threadx %d\r\n'
              0x6c 0x6f 0x20
              0x74 0x68 0x72
              0x65 0x61 0x64
              0x78 0x20 0x25
              0x64 0x0d 0x0a
  0x800'3ff2: 0x00 0x00       DC8      0, 0                   ; '..'
                `MemManage_Handler::__func__`:
  0x800'3ff4: 0x4d 0x65 0x6d  DC8      "MemManage_Handler"
              0x4d 0x61 0x6e
              0x61 0x67 0x65
              0x5f 0x48 0x61
              0x6e 0x64 0x6c
              0x65 0x72 0x00
                `$d.16`:
  0x800'4006: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `BusFault_Handler::__func__`:
  0x800'4008: 0x42 0x75 0x73  DC8      "BusFault_Handler"
              0x46 0x61 0x75
              0x6c 0x74 0x5f
              0x48 0x61 0x6e
              0x64 0x6c 0x65
              0x72 0x00
                $d:
  0x800'4019: 0x00            DC8      0                      ; '.'
  0x800'401a: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `UsageFault_Handler::__func__`:
  0x800'401c: 0x55 0x73 0x61  DC8      "UsageFault_Handler"
              0x67 0x65 0x46
              0x61 0x75 0x6c
              0x74 0x5f 0x48
              0x61 0x6e 0x64
              0x6c 0x65 0x72
              0x00
  0x800'402f: 0x00            DC8      0                      ; '.'
                ?_0:
  0x800'4030: 0x53 0x79 0x73  DC8      "System Timer Thread"
              0x74 0x65 0x6d
              0x20 0x54 0x69
              0x6d 0x65 0x72
              0x20 0x54 0x68
              0x72 0x65 0x61
              0x64 0x00
                ?_4:
  0x800'4044: 0x68 0x65 0x6c  DC8      "hello qemu.\r\n"
              0x6c 0x6f 0x20
              0x71 0x65 0x6d
              0x75 0x2e 0x0d
              0x0a 0x00
                `$d.16`:
  0x800'4052: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                ?_0:
  0x800'4054: 0x74 0x68 0x69  DC8      "this is %s.\r\n"
              0x73 0x20 0x69
              0x73 0x20 0x25
              0x73 0x2e 0x0d
              0x0a 0x00
                `$d.16`:
  0x800'4062: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `Error_Handler::__func__`:
  0x800'4064: 0x45 0x72 0x72  DC8      "Error_Handler"
              0x6f 0x72 0x5f
              0x48 0x61 0x6e
              0x64 0x6c 0x65
              0x72 0x00
                `$d.16`:
  0x800'4072: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `assert_failed::__func__`:
  0x800'4074: 0x61 0x73 0x73  DC8      "assert_failed"
              0x65 0x72 0x74
              0x5f 0x66 0x61
              0x69 0x6c 0x65
              0x64 0x00
                `$d.16`:
  0x800'4082: 0x0000          DC16     0                      ; '..'
                $t:
                `.text11`:
                SystemInit:
  //     SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  0x800'4084: 0x4902          LDR.N    R1, ??DataTable1       ; 0xe000'ed88
  0x800'4086: 0x6808          LDR      R0, [R1]
  0x800'4088: 0xf450 0x0070   ORRS.W   R0, R0, #15728640      ; 0xf0'0000
  0x800'408c: 0x6008          STR      R0, [R1]
  // }
  0x800'408e: 0x4770          BX       LR
                `$d.32`:
                ??DataTable1:
  0x800'4090: 0xe000'ed88     DC32     0xe000'ed88            ; '....'
                $t:
                `.text8`:
                Reset_Handler:
  //         LDR     R0, =SystemInit
  0x800'4094: 0x4801          LDR.N    R0, [PC, #0x4]         ; SystemInit
  //         BLX     R0
  0x800'4096: 0x4780          BLX      R0
  //         LDR     R0, =__iar_program_start
  0x800'4098: 0x4801          LDR.N    R0, [PC, #0x4]         ; __iar_program_start
  //         BX      R0
  0x800'409a: 0x4700          BX       R0
                `$d.32`:
  //         SECTION .text:CODE:REORDER:NOROOT(1)
  0x800'409c: 0x0800'4085     DC32     SystemInit
  //         SECTION .text:CODE:REORDER:NOROOT(1)
  0x800'40a0: 0x0800'3f95     DC32     __iar_program_start
                `$d.8`:
                `NMI_Handler::__func__`:
  0x800'40a4: 0x4e 0x4d 0x49  DC8      "NMI_Handler"
              0x5f 0x48 0x61
              0x6e 0x64 0x6c
              0x65 0x72 0x00
                ?_2:
  0x800'40b0: 0x74 0x78 0x5f  DC8      "tx_pool"
              0x70 0x6f 0x6f
              0x6c 0x00
                ?_3:
  0x800'40b8: 0x74 0x78 0x5f  DC8      "tx_task"
              0x74 0x61 0x73
              0x6b 0x00
                `.rodata10`:
                APBPrescTable:
  0x800'40c0: 0x00 0x00 0x00  DC8      0, 0, 0, 0, 1, 2, 3, 4 ; '........'
              0x00 0x01 0x02
              0x03 0x04
                $t:
                `.text10`:
                HardFault_Handler:
  //         B HardFault_Handler
  0x800'40c8: 0xf7ff 0xbffe   B.W      HardFault_Handler      ; 0x800'40c8
                `.text18`:
                WWDG_IRQHandler:
  //         B WWDG_IRQHandler
  0x800'40cc: 0xf7ff 0xbffe   B.W      WWDG_IRQHandler        ; 0x800'40cc
                `.text19`:
                PVD_IRQHandler:
  //         B PVD_IRQHandler
  0x800'40d0: 0xf7ff 0xbffe   B.W      PVD_IRQHandler         ; 0x800'40d0
                `.text20`:
                TAMP_STAMP_IRQHandler:
  //         B TAMP_STAMP_IRQHandler
  0x800'40d4: 0xf7ff 0xbffe   B.W      TAMP_STAMP_IRQHandler  ; 0x800'40d4
                `.text21`:
                RTC_WKUP_IRQHandler:
  //         B RTC_WKUP_IRQHandler
  0x800'40d8: 0xf7ff 0xbffe   B.W      RTC_WKUP_IRQHandler    ; 0x800'40d8
                `.text22`:
                FLASH_IRQHandler:
  //         B FLASH_IRQHandler
  0x800'40dc: 0xf7ff 0xbffe   B.W      FLASH_IRQHandler       ; 0x800'40dc
                `.text23`:
                RCC_IRQHandler:
  //         B RCC_IRQHandler
  0x800'40e0: 0xf7ff 0xbffe   B.W      RCC_IRQHandler         ; 0x800'40e0
                `.text24`:
                EXTI0_IRQHandler:
  //         B EXTI0_IRQHandler
  0x800'40e4: 0xf7ff 0xbffe   B.W      EXTI0_IRQHandler       ; 0x800'40e4
                `.text25`:
                EXTI1_IRQHandler:
  //         B EXTI1_IRQHandler
  0x800'40e8: 0xf7ff 0xbffe   B.W      EXTI1_IRQHandler       ; 0x800'40e8
                `.text26`:
                EXTI2_IRQHandler:
  //         B EXTI2_IRQHandler
  0x800'40ec: 0xf7ff 0xbffe   B.W      EXTI2_IRQHandler       ; 0x800'40ec
                `.text27`:
                EXTI3_IRQHandler:
  //         B EXTI3_IRQHandler
  0x800'40f0: 0xf7ff 0xbffe   B.W      EXTI3_IRQHandler       ; 0x800'40f0
                `.text28`:
                EXTI4_IRQHandler:
  //         B EXTI4_IRQHandler
  0x800'40f4: 0xf7ff 0xbffe   B.W      EXTI4_IRQHandler       ; 0x800'40f4
                `.text29`:
                DMA1_Stream0_IRQHandler:
  //         B DMA1_Stream0_IRQHandler
  0x800'40f8: 0xf7ff 0xbffe   B.W      DMA1_Stream0_IRQHandler
                                                              ; 0x800'40f8
                `.text30`:
                DMA1_Stream1_IRQHandler:
  //         B DMA1_Stream1_IRQHandler
  0x800'40fc: 0xf7ff 0xbffe   B.W      DMA1_Stream1_IRQHandler
                                                              ; 0x800'40fc
                `.text31`:
                DMA1_Stream2_IRQHandler:
  //         B DMA1_Stream2_IRQHandler
  0x800'4100: 0xf7ff 0xbffe   B.W      DMA1_Stream2_IRQHandler
                                                              ; 0x800'4100
                `.text32`:
                DMA1_Stream3_IRQHandler:
  //         B DMA1_Stream3_IRQHandler
  0x800'4104: 0xf7ff 0xbffe   B.W      DMA1_Stream3_IRQHandler
                                                              ; 0x800'4104
                `.text33`:
                DMA1_Stream4_IRQHandler:
  //         B DMA1_Stream4_IRQHandler
  0x800'4108: 0xf7ff 0xbffe   B.W      DMA1_Stream4_IRQHandler
                                                              ; 0x800'4108
                `.text34`:
                DMA1_Stream5_IRQHandler:
  //         B DMA1_Stream5_IRQHandler
  0x800'410c: 0xf7ff 0xbffe   B.W      DMA1_Stream5_IRQHandler
                                                              ; 0x800'410c
                `.text35`:
                DMA1_Stream6_IRQHandler:
  //         B DMA1_Stream6_IRQHandler
  0x800'4110: 0xf7ff 0xbffe   B.W      DMA1_Stream6_IRQHandler
                                                              ; 0x800'4110
                `.text36`:
                ADC_IRQHandler:
  //         B ADC_IRQHandler
  0x800'4114: 0xf7ff 0xbffe   B.W      ADC_IRQHandler         ; 0x800'4114
                `.text37`:
                CAN1_TX_IRQHandler:
  //         B CAN1_TX_IRQHandler
  0x800'4118: 0xf7ff 0xbffe   B.W      CAN1_TX_IRQHandler     ; 0x800'4118
                `.text38`:
                CAN1_RX0_IRQHandler:
  //         B CAN1_RX0_IRQHandler
  0x800'411c: 0xf7ff 0xbffe   B.W      CAN1_RX0_IRQHandler    ; 0x800'411c
                `.text39`:
                CAN1_RX1_IRQHandler:
  //         B CAN1_RX1_IRQHandler
  0x800'4120: 0xf7ff 0xbffe   B.W      CAN1_RX1_IRQHandler    ; 0x800'4120
                `.text40`:
                CAN1_SCE_IRQHandler:
  //         B CAN1_SCE_IRQHandler
  0x800'4124: 0xf7ff 0xbffe   B.W      CAN1_SCE_IRQHandler    ; 0x800'4124
                `.text41`:
                EXTI9_5_IRQHandler:
  //         B EXTI9_5_IRQHandler
  0x800'4128: 0xf7ff 0xbffe   B.W      EXTI9_5_IRQHandler     ; 0x800'4128
                `.text42`:
                TIM1_BRK_TIM9_IRQHandler:
  //         B TIM1_BRK_TIM9_IRQHandler
  0x800'412c: 0xf7ff 0xbffe   B.W      TIM1_BRK_TIM9_IRQHandler
                                                              ; 0x800'412c
                `.text43`:
                TIM1_UP_TIM10_IRQHandler:
  //         B TIM1_UP_TIM10_IRQHandler
  0x800'4130: 0xf7ff 0xbffe   B.W      TIM1_UP_TIM10_IRQHandler
                                                              ; 0x800'4130
                `.text44`:
                TIM1_TRG_COM_TIM11_IRQHandler:
  //         B TIM1_TRG_COM_TIM11_IRQHandler
  0x800'4134: 0xf7ff 0xbffe   B.W      TIM1_TRG_COM_TIM11_IRQHandler
                                                              ; 0x800'4134
                `.text45`:
                TIM1_CC_IRQHandler:
  //         B TIM1_CC_IRQHandler
  0x800'4138: 0xf7ff 0xbffe   B.W      TIM1_CC_IRQHandler     ; 0x800'4138
                `.text47`:
                TIM3_IRQHandler:
  //         B TIM3_IRQHandler
  0x800'413c: 0xf7ff 0xbffe   B.W      TIM3_IRQHandler        ; 0x800'413c
                `.text48`:
                TIM4_IRQHandler:
  //         B TIM4_IRQHandler
  0x800'4140: 0xf7ff 0xbffe   B.W      TIM4_IRQHandler        ; 0x800'4140
                `.text49`:
                I2C1_EV_IRQHandler:
  //         B I2C1_EV_IRQHandler
  0x800'4144: 0xf7ff 0xbffe   B.W      I2C1_EV_IRQHandler     ; 0x800'4144
                `.text50`:
                I2C1_ER_IRQHandler:
  //         B I2C1_ER_IRQHandler
  0x800'4148: 0xf7ff 0xbffe   B.W      I2C1_ER_IRQHandler     ; 0x800'4148
                `.text51`:
                I2C2_EV_IRQHandler:
  //         B I2C2_EV_IRQHandler
  0x800'414c: 0xf7ff 0xbffe   B.W      I2C2_EV_IRQHandler     ; 0x800'414c
                `.text52`:
                I2C2_ER_IRQHandler:
  //         B I2C2_ER_IRQHandler
  0x800'4150: 0xf7ff 0xbffe   B.W      I2C2_ER_IRQHandler     ; 0x800'4150
                `.text53`:
                SPI1_IRQHandler:
  //         B SPI1_IRQHandler
  0x800'4154: 0xf7ff 0xbffe   B.W      SPI1_IRQHandler        ; 0x800'4154
                `.text54`:
                SPI2_IRQHandler:
  //         B SPI2_IRQHandler
  0x800'4158: 0xf7ff 0xbffe   B.W      SPI2_IRQHandler        ; 0x800'4158
                `.text56`:
                USART2_IRQHandler:
  //         B USART2_IRQHandler
  0x800'415c: 0xf7ff 0xbffe   B.W      USART2_IRQHandler      ; 0x800'415c
                `.text57`:
                USART3_IRQHandler:
  //         B USART3_IRQHandler
  0x800'4160: 0xf7ff 0xbffe   B.W      USART3_IRQHandler      ; 0x800'4160
                `.text58`:
                EXTI15_10_IRQHandler:
  //         B EXTI15_10_IRQHandler
  0x800'4164: 0xf7ff 0xbffe   B.W      EXTI15_10_IRQHandler   ; 0x800'4164
                `.text59`:
                RTC_Alarm_IRQHandler:
  //         B RTC_Alarm_IRQHandler
  0x800'4168: 0xf7ff 0xbffe   B.W      RTC_Alarm_IRQHandler   ; 0x800'4168
                `.text60`:
                OTG_FS_WKUP_IRQHandler:
  //         B OTG_FS_WKUP_IRQHandler
  0x800'416c: 0xf7ff 0xbffe   B.W      OTG_FS_WKUP_IRQHandler ; 0x800'416c
                `.text61`:
                TIM8_BRK_TIM12_IRQHandler:
  //         B TIM8_BRK_TIM12_IRQHandler
  0x800'4170: 0xf7ff 0xbffe   B.W      TIM8_BRK_TIM12_IRQHandler
                                                              ; 0x800'4170
                `.text62`:
                TIM8_UP_TIM13_IRQHandler:
  //         B TIM8_UP_TIM13_IRQHandler
  0x800'4174: 0xf7ff 0xbffe   B.W      TIM8_UP_TIM13_IRQHandler
                                                              ; 0x800'4174
                `.text63`:
                TIM8_TRG_COM_TIM14_IRQHandler:
  //         B TIM8_TRG_COM_TIM14_IRQHandler
  0x800'4178: 0xf7ff 0xbffe   B.W      TIM8_TRG_COM_TIM14_IRQHandler
                                                              ; 0x800'4178
                `.text64`:
                TIM8_CC_IRQHandler:
  //         B TIM8_CC_IRQHandler
  0x800'417c: 0xf7ff 0xbffe   B.W      TIM8_CC_IRQHandler     ; 0x800'417c
                `.text65`:
                DMA1_Stream7_IRQHandler:
  //         B DMA1_Stream7_IRQHandler
  0x800'4180: 0xf7ff 0xbffe   B.W      DMA1_Stream7_IRQHandler
                                                              ; 0x800'4180
                `.text66`:
                FSMC_IRQHandler:
  //         B FSMC_IRQHandler
  0x800'4184: 0xf7ff 0xbffe   B.W      FSMC_IRQHandler        ; 0x800'4184
                `.text67`:
                SDIO_IRQHandler:
  //         B SDIO_IRQHandler
  0x800'4188: 0xf7ff 0xbffe   B.W      SDIO_IRQHandler        ; 0x800'4188
                `.text68`:
                TIM5_IRQHandler:
  //         B TIM5_IRQHandler
  0x800'418c: 0xf7ff 0xbffe   B.W      TIM5_IRQHandler        ; 0x800'418c
                `.text69`:
                SPI3_IRQHandler:
  //         B SPI3_IRQHandler
  0x800'4190: 0xf7ff 0xbffe   B.W      SPI3_IRQHandler        ; 0x800'4190
                `.text70`:
                UART4_IRQHandler:
  //         B UART4_IRQHandler
  0x800'4194: 0xf7ff 0xbffe   B.W      UART4_IRQHandler       ; 0x800'4194
                `.text71`:
                UART5_IRQHandler:
  //         B UART5_IRQHandler
  0x800'4198: 0xf7ff 0xbffe   B.W      UART5_IRQHandler       ; 0x800'4198
                `.text72`:
                TIM6_DAC_IRQHandler:
  //         B TIM6_DAC_IRQHandler
  0x800'419c: 0xf7ff 0xbffe   B.W      TIM6_DAC_IRQHandler    ; 0x800'419c
                `.text73`:
                TIM7_IRQHandler:
  //         B TIM7_IRQHandler
  0x800'41a0: 0xf7ff 0xbffe   B.W      TIM7_IRQHandler        ; 0x800'41a0
                `.text74`:
                DMA2_Stream0_IRQHandler:
  //         B DMA2_Stream0_IRQHandler
  0x800'41a4: 0xf7ff 0xbffe   B.W      DMA2_Stream0_IRQHandler
                                                              ; 0x800'41a4
                `.text75`:
                DMA2_Stream1_IRQHandler:
  //         B DMA2_Stream1_IRQHandler
  0x800'41a8: 0xf7ff 0xbffe   B.W      DMA2_Stream1_IRQHandler
                                                              ; 0x800'41a8
                `.text76`:
                DMA2_Stream2_IRQHandler:
  //         B DMA2_Stream2_IRQHandler
  0x800'41ac: 0xf7ff 0xbffe   B.W      DMA2_Stream2_IRQHandler
                                                              ; 0x800'41ac
                `.text77`:
                DMA2_Stream3_IRQHandler:
  //         B DMA2_Stream3_IRQHandler
  0x800'41b0: 0xf7ff 0xbffe   B.W      DMA2_Stream3_IRQHandler
                                                              ; 0x800'41b0
                `.text78`:
                DMA2_Stream4_IRQHandler:
  //         B DMA2_Stream4_IRQHandler
  0x800'41b4: 0xf7ff 0xbffe   B.W      DMA2_Stream4_IRQHandler
                                                              ; 0x800'41b4
                `.text79`:
                CAN2_TX_IRQHandler:
  //         B CAN2_TX_IRQHandler
  0x800'41b8: 0xf7ff 0xbffe   B.W      CAN2_TX_IRQHandler     ; 0x800'41b8
                `.text80`:
                CAN2_RX0_IRQHandler:
  //         B CAN2_RX0_IRQHandler
  0x800'41bc: 0xf7ff 0xbffe   B.W      CAN2_RX0_IRQHandler    ; 0x800'41bc
                `.text81`:
                CAN2_RX1_IRQHandler:
  //         B CAN2_RX1_IRQHandler
  0x800'41c0: 0xf7ff 0xbffe   B.W      CAN2_RX1_IRQHandler    ; 0x800'41c0
                `.text82`:
                CAN2_SCE_IRQHandler:
  //         B CAN2_SCE_IRQHandler
  0x800'41c4: 0xf7ff 0xbffe   B.W      CAN2_SCE_IRQHandler    ; 0x800'41c4
                `.text83`:
                OTG_FS_IRQHandler:
  //         B OTG_FS_IRQHandler
  0x800'41c8: 0xf7ff 0xbffe   B.W      OTG_FS_IRQHandler      ; 0x800'41c8
                `.text84`:
                DMA2_Stream5_IRQHandler:
  //         B DMA2_Stream5_IRQHandler
  0x800'41cc: 0xf7ff 0xbffe   B.W      DMA2_Stream5_IRQHandler
                                                              ; 0x800'41cc
                `.text85`:
                DMA2_Stream6_IRQHandler:
  //         B DMA2_Stream6_IRQHandler
  0x800'41d0: 0xf7ff 0xbffe   B.W      DMA2_Stream6_IRQHandler
                                                              ; 0x800'41d0
                `.text86`:
                DMA2_Stream7_IRQHandler:
  //         B DMA2_Stream7_IRQHandler
  0x800'41d4: 0xf7ff 0xbffe   B.W      DMA2_Stream7_IRQHandler
                                                              ; 0x800'41d4
                `.text87`:
                USART6_IRQHandler:
  //         B USART6_IRQHandler
  0x800'41d8: 0xf7ff 0xbffe   B.W      USART6_IRQHandler      ; 0x800'41d8
                `.text88`:
                I2C3_EV_IRQHandler:
  //         B I2C3_EV_IRQHandler
  0x800'41dc: 0xf7ff 0xbffe   B.W      I2C3_EV_IRQHandler     ; 0x800'41dc
                `.text89`:
                I2C3_ER_IRQHandler:
  //         B I2C3_ER_IRQHandler
  0x800'41e0: 0xf7ff 0xbffe   B.W      I2C3_ER_IRQHandler     ; 0x800'41e0
                `.text90`:
                OTG_HS_EP1_OUT_IRQHandler:
  //         B OTG_HS_EP1_OUT_IRQHandler
  0x800'41e4: 0xf7ff 0xbffe   B.W      OTG_HS_EP1_OUT_IRQHandler
                                                              ; 0x800'41e4
                `.text91`:
                OTG_HS_EP1_IN_IRQHandler:
  //         B OTG_HS_EP1_IN_IRQHandler
  0x800'41e8: 0xf7ff 0xbffe   B.W      OTG_HS_EP1_IN_IRQHandler
                                                              ; 0x800'41e8
                `.text92`:
                OTG_HS_WKUP_IRQHandler:
  //         B OTG_HS_WKUP_IRQHandler
  0x800'41ec: 0xf7ff 0xbffe   B.W      OTG_HS_WKUP_IRQHandler ; 0x800'41ec
                `.text93`:
                OTG_HS_IRQHandler:
  //         B OTG_HS_IRQHandler
  0x800'41f0: 0xf7ff 0xbffe   B.W      OTG_HS_IRQHandler      ; 0x800'41f0
                `.text94`:
                HASH_RNG_IRQHandler:
  //         B HASH_RNG_IRQHandler
  0x800'41f4: 0xf7ff 0xbffe   B.W      HASH_RNG_IRQHandler    ; 0x800'41f4
                `.text95`:
                FPU_IRQHandler:
  //         B FPU_IRQHandler
  0x800'41f8: 0xf7ff 0xbffe   B.W      FPU_IRQHandler         ; 0x800'41f8
                __iar_SB:

Errors: none
Warnings: none
