###############################################################################
#
# IAR ELF Dumper V9.50.2.385 for ARM                      22/Aug/2024  21:40:01
# Copyright 2007-2024 IAR Systems AB.
#
#    Input file   =
#        C:\Users\xidon\code\github\qemu-simulator\boards\stm32f405rg\threadx\build\iar\stm32-qemu.out
#    Output file  =
#        C:\Users\xidon\code\github\qemu-simulator\boards\stm32f405rg\threadx\build\iar\objdump.txt
#    Command line =
#        --source --code .\build\iar/stm32-qemu.out -o .\build\iar/objdump.txt
#
###############################################################################



Section #4 A0:

                $d:
                `.intvec7`:
                __vector_table:
  0x800'0000: 0x2000'0a80  DC32 CSTACK$$Limit
  0x800'0004: 0x0800'2be5  DC32 Reset_Handler
  0x800'0008: 0x0800'0ced  DC32 NMI_Handler
  0x800'000c: 0x0800'2c19  DC32 HardFault_Handler
  0x800'0010: 0x0800'0cf9  DC32 MemManage_Handler
  0x800'0014: 0x0800'0d05  DC32 BusFault_Handler
  0x800'0018: 0x0800'0d11  DC32 UsageFault_Handler
  0x800'001c: 0x0000'0000  DC32 0                      ; '....'
  0x800'0020: 0x0000'0000  DC32 0                      ; '....'
  0x800'0024: 0x0000'0000  DC32 0                      ; '....'
  0x800'0028: 0x0000'0000  DC32 0                      ; '....'
  0x800'002c: 0x0800'0d1d  DC32 SVC_Handler
  0x800'0030: 0x0800'0d1f  DC32 DebugMon_Handler
  0x800'0034: 0x0000'0000  DC32 0                      ; '....'
  0x800'0038: 0x0800'2611  DC32 __tx_PendSVHandler
  0x800'003c: 0x0800'27bf  DC32 __tx_SysTickHandler
  0x800'0040: 0x0800'2c1d  DC32 WWDG_IRQHandler
  0x800'0044: 0x0800'2c21  DC32 PVD_IRQHandler
  0x800'0048: 0x0800'2c25  DC32 TAMP_STAMP_IRQHandler
  0x800'004c: 0x0800'2c29  DC32 RTC_WKUP_IRQHandler
  0x800'0050: 0x0800'2c2d  DC32 FLASH_IRQHandler
  0x800'0054: 0x0800'2c31  DC32 RCC_IRQHandler
  0x800'0058: 0x0800'2c35  DC32 EXTI0_IRQHandler
  0x800'005c: 0x0800'2c39  DC32 EXTI1_IRQHandler
  0x800'0060: 0x0800'2c3d  DC32 EXTI2_IRQHandler
  0x800'0064: 0x0800'2c41  DC32 EXTI3_IRQHandler
  0x800'0068: 0x0800'2c45  DC32 EXTI4_IRQHandler
  0x800'006c: 0x0800'2c49  DC32 DMA1_Stream0_IRQHandler
  0x800'0070: 0x0800'2c4d  DC32 DMA1_Stream1_IRQHandler
  0x800'0074: 0x0800'2c51  DC32 DMA1_Stream2_IRQHandler
  0x800'0078: 0x0800'2c55  DC32 DMA1_Stream3_IRQHandler
  0x800'007c: 0x0800'2c59  DC32 DMA1_Stream4_IRQHandler
  0x800'0080: 0x0800'2c5d  DC32 DMA1_Stream5_IRQHandler
  0x800'0084: 0x0800'2c61  DC32 DMA1_Stream6_IRQHandler
  0x800'0088: 0x0800'2c65  DC32 ADC_IRQHandler
  0x800'008c: 0x0800'2c69  DC32 CAN1_TX_IRQHandler
  0x800'0090: 0x0800'2c6d  DC32 CAN1_RX0_IRQHandler
  0x800'0094: 0x0800'2c71  DC32 CAN1_RX1_IRQHandler
  0x800'0098: 0x0800'2c75  DC32 CAN1_SCE_IRQHandler
  0x800'009c: 0x0800'2c79  DC32 EXTI9_5_IRQHandler
  0x800'00a0: 0x0800'2c7d  DC32 TIM1_BRK_TIM9_IRQHandler
  0x800'00a4: 0x0800'2c81  DC32 TIM1_UP_TIM10_IRQHandler
  0x800'00a8: 0x0800'2c85  DC32 TIM1_TRG_COM_TIM11_IRQHandler
  0x800'00ac: 0x0800'2c89  DC32 TIM1_CC_IRQHandler
  0x800'00b0: 0x0800'0d21  DC32 TIM2_IRQHandler
  0x800'00b4: 0x0800'2c8d  DC32 TIM3_IRQHandler
  0x800'00b8: 0x0800'2c91  DC32 TIM4_IRQHandler
  0x800'00bc: 0x0800'2c95  DC32 I2C1_EV_IRQHandler
  0x800'00c0: 0x0800'2c99  DC32 I2C1_ER_IRQHandler
  0x800'00c4: 0x0800'2c9d  DC32 I2C2_EV_IRQHandler
  0x800'00c8: 0x0800'2ca1  DC32 I2C2_ER_IRQHandler
  0x800'00cc: 0x0800'2ca5  DC32 SPI1_IRQHandler
  0x800'00d0: 0x0800'2ca9  DC32 SPI2_IRQHandler
  0x800'00d4: 0x0800'0d2f  DC32 USART1_IRQHandler
  0x800'00d8: 0x0800'2cad  DC32 USART2_IRQHandler
  0x800'00dc: 0x0800'2cb1  DC32 USART3_IRQHandler
  0x800'00e0: 0x0800'2cb5  DC32 EXTI15_10_IRQHandler
  0x800'00e4: 0x0800'2cb9  DC32 RTC_Alarm_IRQHandler
  0x800'00e8: 0x0800'2cbd  DC32 OTG_FS_WKUP_IRQHandler
  0x800'00ec: 0x0800'2cc1  DC32 TIM8_BRK_TIM12_IRQHandler
  0x800'00f0: 0x0800'2cc5  DC32 TIM8_UP_TIM13_IRQHandler
  0x800'00f4: 0x0800'2cc9  DC32 TIM8_TRG_COM_TIM14_IRQHandler
  0x800'00f8: 0x0800'2ccd  DC32 TIM8_CC_IRQHandler
  0x800'00fc: 0x0800'2cd1  DC32 DMA1_Stream7_IRQHandler
  0x800'0100: 0x0800'2cd5  DC32 FSMC_IRQHandler
  0x800'0104: 0x0800'2cd9  DC32 SDIO_IRQHandler
  0x800'0108: 0x0800'2cdd  DC32 TIM5_IRQHandler
  0x800'010c: 0x0800'2ce1  DC32 SPI3_IRQHandler
  0x800'0110: 0x0800'2ce5  DC32 UART4_IRQHandler
  0x800'0114: 0x0800'2ce9  DC32 UART5_IRQHandler
  0x800'0118: 0x0800'2ced  DC32 TIM6_DAC_IRQHandler
  0x800'011c: 0x0800'2cf1  DC32 TIM7_IRQHandler
  0x800'0120: 0x0800'2cf5  DC32 DMA2_Stream0_IRQHandler
  0x800'0124: 0x0800'2cf9  DC32 DMA2_Stream1_IRQHandler
  0x800'0128: 0x0800'2cfd  DC32 DMA2_Stream2_IRQHandler
  0x800'012c: 0x0800'2d01  DC32 DMA2_Stream3_IRQHandler
  0x800'0130: 0x0800'2d05  DC32 DMA2_Stream4_IRQHandler
  0x800'0134: 0x0000'0000  DC32 0                      ; '....'
  0x800'0138: 0x0000'0000  DC32 0                      ; '....'
  0x800'013c: 0x0800'2d09  DC32 CAN2_TX_IRQHandler
  0x800'0140: 0x0800'2d0d  DC32 CAN2_RX0_IRQHandler
  0x800'0144: 0x0800'2d11  DC32 CAN2_RX1_IRQHandler
  0x800'0148: 0x0800'2d15  DC32 CAN2_SCE_IRQHandler
  0x800'014c: 0x0800'2d19  DC32 OTG_FS_IRQHandler
  0x800'0150: 0x0800'2d1d  DC32 DMA2_Stream5_IRQHandler
  0x800'0154: 0x0800'2d21  DC32 DMA2_Stream6_IRQHandler
  0x800'0158: 0x0800'2d25  DC32 DMA2_Stream7_IRQHandler
  0x800'015c: 0x0800'2d29  DC32 USART6_IRQHandler
  0x800'0160: 0x0800'2d2d  DC32 I2C3_EV_IRQHandler
  0x800'0164: 0x0800'2d31  DC32 I2C3_ER_IRQHandler
  0x800'0168: 0x0800'2d35  DC32 OTG_HS_EP1_OUT_IRQHandler
  0x800'016c: 0x0800'2d39  DC32 OTG_HS_EP1_IN_IRQHandler
  0x800'0170: 0x0800'2d3d  DC32 OTG_HS_WKUP_IRQHandler
  0x800'0174: 0x0800'2d41  DC32 OTG_HS_IRQHandler
  0x800'0178: 0x0000'0000  DC32 0                      ; '....'
  0x800'017c: 0x0000'0000  DC32 0                      ; '....'
  0x800'0180: 0x0800'2d45  DC32 HASH_RNG_IRQHandler
  0x800'0184: 0x0800'2d49  DC32 FPU_IRQHandler
  // HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
  // {


-------------------------------------------------------------------------------
Section #5 P1:

  // HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
  // {
                $t:
                `.text8`:
                HAL_UART_Init:
  0x800'0188: 0xb510          PUSH     {R4, LR}
  0x800'018a: 0x0004          MOVS     R4, R0
  //   if (huart == NULL)
  0x800'018c: 0x2c00          CMP      R4, #0
  0x800'018e: 0xd101          BNE.N    ??HAL_UART_Init_0      ; 0x800'0194
  //     return HAL_ERROR;
  0x800'0190: 0x2001          MOVS     R0, #1
  0x800'0192: 0xe0a3          B.N      ??HAL_UART_Init_1      ; 0x800'02dc
                ??HAL_UART_Init_0:
  //   if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
  0x800'0194: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'0196: 0x2800          CMP      R0, #0
  0x800'0198: 0xd02f          BEQ.N    ??HAL_UART_Init_2      ; 0x800'01fa
  //     assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
  0x800'019a: 0x6821          LDR      R1, [R4]
  0x800'019c: 0xf8df 0x021c   LDR.W    R0, ??DataTable5       ; 0x4001'1000
  0x800'01a0: 0x4281          CMP      R1, R0
  0x800'01a2: 0xd014          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01a4: 0x6821          LDR      R1, [R4]
  0x800'01a6: 0xf8df 0x0218   LDR.W    R0, ??DataTable5_1     ; 0x4000'4400
  0x800'01aa: 0x4281          CMP      R1, R0
  0x800'01ac: 0xd00f          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01ae: 0x6821          LDR      R1, [R4]
  0x800'01b0: 0xf8df 0x0210   LDR.W    R0, ??DataTable5_2     ; 0x4000'4800
  0x800'01b4: 0x4281          CMP      R1, R0
  0x800'01b6: 0xd00a          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01b8: 0x6821          LDR      R1, [R4]
  0x800'01ba: 0xf8df 0x020c   LDR.W    R0, ??DataTable5_3     ; 0x4001'1400
  0x800'01be: 0x4281          CMP      R1, R0
  0x800'01c0: 0xd005          BEQ.N    ??HAL_UART_Init_3      ; 0x800'01ce
  0x800'01c2: 0xf240 0x1173   MOVW     R1, #371               ; 0x173
  0x800'01c6: 0xf8df 0x0204   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'01ca: 0xf000 0xfdbc   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_3:
  //     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
  0x800'01ce: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01d0: 0x2800          CMP      R0, #0
  0x800'01d2: 0xd036          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01d4: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01d6: 0xf5b0 0x7f80   CMP.W    R0, #256               ; 0x100
  0x800'01da: 0xd032          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01dc: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01de: 0xf5b0 0x7f00   CMP.W    R0, #512               ; 0x200
  0x800'01e2: 0xd02e          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01e4: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'01e6: 0xf5b0 0x7f40   CMP.W    R0, #768               ; 0x300
  0x800'01ea: 0xd02a          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'01ec: 0xf44f 0x71ba   MOV.W    R1, #372               ; 0x174
  0x800'01f0: 0xf8df 0x01d8   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'01f4: 0xf000 0xfda7   BL       assert_failed          ; 0x800'0d46
  0x800'01f8: 0xe023          B.N      ??HAL_UART_Init_4      ; 0x800'0242
                ??HAL_UART_Init_2:
  //     assert_param(IS_UART_INSTANCE(huart->Instance));
  0x800'01fa: 0x6821          LDR      R1, [R4]
  0x800'01fc: 0xf8df 0x01bc   LDR.W    R0, ??DataTable5       ; 0x4001'1000
  0x800'0200: 0x4281          CMP      R1, R0
  0x800'0202: 0xd01e          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0204: 0x6821          LDR      R1, [R4]
  0x800'0206: 0xf8df 0x01b8   LDR.W    R0, ??DataTable5_1     ; 0x4000'4400
  0x800'020a: 0x4281          CMP      R1, R0
  0x800'020c: 0xd019          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'020e: 0x6821          LDR      R1, [R4]
  0x800'0210: 0xf8df 0x01b0   LDR.W    R0, ??DataTable5_2     ; 0x4000'4800
  0x800'0214: 0x4281          CMP      R1, R0
  0x800'0216: 0xd014          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0218: 0x6821          LDR      R1, [R4]
  0x800'021a: 0xf8df 0x01b4   LDR.W    R0, ??DataTable5_5     ; 0x4000'4c00
  0x800'021e: 0x4281          CMP      R1, R0
  0x800'0220: 0xd00f          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0222: 0x6821          LDR      R1, [R4]
  0x800'0224: 0xf8df 0x01ac   LDR.W    R0, ??DataTable5_6     ; 0x4000'5000
  0x800'0228: 0x4281          CMP      R1, R0
  0x800'022a: 0xd00a          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'022c: 0x6821          LDR      R1, [R4]
  0x800'022e: 0xf8df 0x0198   LDR.W    R0, ??DataTable5_3     ; 0x4001'1400
  0x800'0232: 0x4281          CMP      R1, R0
  0x800'0234: 0xd005          BEQ.N    ??HAL_UART_Init_4      ; 0x800'0242
  0x800'0236: 0xf44f 0x71bc   MOV.W    R1, #376               ; 0x178
  0x800'023a: 0xf8df 0x0190   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'023e: 0xf000 0xfd82   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_4:
  //   assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  0x800'0242: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'0244: 0x2800          CMP      R0, #0
  0x800'0246: 0xd009          BEQ.N    ??HAL_UART_Init_5      ; 0x800'025c
  0x800'0248: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'024a: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'024e: 0xd005          BEQ.N    ??HAL_UART_Init_5      ; 0x800'025c
  0x800'0250: 0xf44f 0x71bd   MOV.W    R1, #378               ; 0x17a
  0x800'0254: 0xf8df 0x0174   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'0258: 0xf000 0xfd75   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_5:
  //   assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  0x800'025c: 0x69e0          LDR      R0, [R4, #0x1c]
  0x800'025e: 0x2800          CMP      R0, #0
  0x800'0260: 0xd009          BEQ.N    ??HAL_UART_Init_6      ; 0x800'0276
  0x800'0262: 0x69e0          LDR      R0, [R4, #0x1c]
  0x800'0264: 0xf5b0 0x4f00   CMP.W    R0, #32768             ; 0x8000
  0x800'0268: 0xd005          BEQ.N    ??HAL_UART_Init_6      ; 0x800'0276
  0x800'026a: 0xf240 0x117b   MOVW     R1, #379               ; 0x17b
  0x800'026e: 0xf8df 0x015c   LDR.W    R0, ??DataTable5_4     ; ?_0
  0x800'0272: 0xf000 0xfd68   BL       assert_failed          ; 0x800'0d46
                ??HAL_UART_Init_6:
  //   if (huart->gState == HAL_UART_STATE_RESET)
  0x800'0276: 0xf894 0x0041   LDRB.W   R0, [R4, #0x41]
  0x800'027a: 0x2800          CMP      R0, #0
  0x800'027c: 0xd105          BNE.N    ??HAL_UART_Init_7      ; 0x800'028a
  //     huart->Lock = HAL_UNLOCKED;
  0x800'027e: 0x2000          MOVS     R0, #0
  0x800'0280: 0xf884 0x0040   STRB.W   R0, [R4, #0x40]
  //     HAL_UART_MspInit(huart);
  0x800'0284: 0x0020          MOVS     R0, R4
  0x800'0286: 0xf000 0xfd93   BL       HAL_UART_MspInit       ; 0x800'0db0
                ??HAL_UART_Init_7:
  //   huart->gState = HAL_UART_STATE_BUSY;
  0x800'028a: 0x2024          MOVS     R0, #36                ; 0x24
  0x800'028c: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   __HAL_UART_DISABLE(huart);
  0x800'0290: 0x6820          LDR      R0, [R4]
  0x800'0292: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'0294: 0xf431 0x5100   BICS.W   R1, R1, #8192          ; 0x2000
  0x800'0298: 0x6820          LDR      R0, [R4]
  0x800'029a: 0x60c1          STR      R1, [R0, #0xc]
  //   UART_SetConfig(huart);
  0x800'029c: 0x0020          MOVS     R0, R4
  0x800'029e: 0xf000 0xfb71   BL       UART_SetConfig         ; 0x800'0984
  //   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  0x800'02a2: 0x6820          LDR      R0, [R4]
  0x800'02a4: 0x6901          LDR      R1, [R0, #0x10]
  0x800'02a6: 0xf431 0x4190   BICS.W   R1, R1, #18432         ; 0x4800
  0x800'02aa: 0x6820          LDR      R0, [R4]
  0x800'02ac: 0x6101          STR      R1, [R0, #0x10]
  //   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
  0x800'02ae: 0x6820          LDR      R0, [R4]
  0x800'02b0: 0x6941          LDR      R1, [R0, #0x14]
  0x800'02b2: 0xf031 0x012a   BICS.W   R1, R1, #42            ; 0x2a
  0x800'02b6: 0x6820          LDR      R0, [R4]
  0x800'02b8: 0x6141          STR      R1, [R0, #0x14]
  //   __HAL_UART_ENABLE(huart);
  0x800'02ba: 0x6820          LDR      R0, [R4]
  0x800'02bc: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'02be: 0xf451 0x5100   ORRS.W   R1, R1, #8192          ; 0x2000
  0x800'02c2: 0x6820          LDR      R0, [R4]
  0x800'02c4: 0x60c1          STR      R1, [R0, #0xc]
  //   huart->ErrorCode = HAL_UART_ERROR_NONE;
  0x800'02c6: 0x2000          MOVS     R0, #0
  0x800'02c8: 0x6460          STR      R0, [R4, #0x44]
  //   huart->gState = HAL_UART_STATE_READY;
  0x800'02ca: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'02cc: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   huart->RxState = HAL_UART_STATE_READY;
  0x800'02d0: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'02d2: 0xf884 0x0042   STRB.W   R0, [R4, #0x42]
  //   huart->RxEventType = HAL_UART_RXEVENT_TC;
  0x800'02d6: 0x2000          MOVS     R0, #0
  0x800'02d8: 0x6360          STR      R0, [R4, #0x34]
  //   return HAL_OK;
  0x800'02da: 0x2000          MOVS     R0, #0
                ??HAL_UART_Init_1:
  0x800'02dc: 0xbd10          POP      {R4, PC}
                `.text_8`:
                HAL_UART_Transmit:
  // HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
  // {
  0x800'02de: 0xe92d 0x47fc   PUSH.W   {R2-R10, LR}
  0x800'02e2: 0x4681          MOV      R9, R0
  0x800'02e4: 0x000d          MOVS     R5, R1
  0x800'02e6: 0x0016          MOVS     R6, R2
  0x800'02e8: 0x001f          MOVS     R7, R3
  //   uint32_t tickstart = 0U;
  0x800'02ea: 0x2400          MOVS     R4, #0
  //   if (huart->gState == HAL_UART_STATE_READY)
  0x800'02ec: 0xf899 0x0041   LDRB.W   R0, [R9, #0x41]
  0x800'02f0: 0x2820          CMP      R0, #32                ; 0x20
  0x800'02f2: 0xd15f          BNE.N    ??HAL_UART_Transmit_0  ; 0x800'03b4
  //     if ((pData == NULL) || (Size == 0U))
  0x800'02f4: 0x2d00          CMP      R5, #0
  0x800'02f6: 0xd003          BEQ.N    ??HAL_UART_Transmit_1  ; 0x800'0300
  0x800'02f8: 0x0030          MOVS     R0, R6
  0x800'02fa: 0xb280          UXTH     R0, R0
  0x800'02fc: 0x2800          CMP      R0, #0
  0x800'02fe: 0xd101          BNE.N    ??HAL_UART_Transmit_2  ; 0x800'0304
                ??HAL_UART_Transmit_1:
  //       return  HAL_ERROR;
  0x800'0300: 0x2001          MOVS     R0, #1
  0x800'0302: 0xe058          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_2:
  //     huart->ErrorCode = HAL_UART_ERROR_NONE;
  0x800'0304: 0x2000          MOVS     R0, #0
  0x800'0306: 0xf8c9 0x0044   STR.W    R0, [R9, #0x44]
  //     huart->gState = HAL_UART_STATE_BUSY_TX;
  0x800'030a: 0x2021          MOVS     R0, #33                ; 0x21
  0x800'030c: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //     tickstart = HAL_GetTick();
  0x800'0310: 0xf000 0xfd96   BL       HAL_GetTick            ; 0x800'0e40
  0x800'0314: 0x4680          MOV      R8, R0
  //     huart->TxXferSize = Size;
  0x800'0316: 0xf8a9 0x6024   STRH.W   R6, [R9, #0x24]
  //     huart->TxXferCount = Size;
  0x800'031a: 0xf8a9 0x6026   STRH.W   R6, [R9, #0x26]
  //     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  0x800'031e: 0xf8d9 0x0008   LDR.W    R0, [R9, #0x8]
  0x800'0322: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'0326: 0xd106          BNE.N    ??HAL_UART_Transmit_4  ; 0x800'0336
  0x800'0328: 0xf8d9 0x0010   LDR.W    R0, [R9, #0x10]
  0x800'032c: 0x2800          CMP      R0, #0
  0x800'032e: 0xd102          BNE.N    ??HAL_UART_Transmit_4  ; 0x800'0336
  //       pdata8bits  = NULL;
  0x800'0330: 0x2400          MOVS     R4, #0
  //       pdata16bits = (const uint16_t *) pData;
  0x800'0332: 0x46aa          MOV      R10, R5
  0x800'0334: 0xe002          B.N      ??HAL_UART_Transmit_5  ; 0x800'033c
                ??HAL_UART_Transmit_4:
  //       pdata8bits  = pData;
  0x800'0336: 0x002c          MOVS     R4, R5
  //       pdata16bits = NULL;
  0x800'0338: 0xf05f 0x0a00   MOVS.W   R10, #0
                ??HAL_UART_Transmit_5:
  //     while (huart->TxXferCount > 0U)
  0x800'033c: 0xf8b9 0x0026   LDRH.W   R0, [R9, #0x26]
  0x800'0340: 0x2800          CMP      R0, #0
  0x800'0342: 0xd024          BEQ.N    ??HAL_UART_Transmit_6  ; 0x800'038e
  //       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
  0x800'0344: 0x9700          STR      R7, [SP]
  0x800'0346: 0x4643          MOV      R3, R8
  0x800'0348: 0x2200          MOVS     R2, #0
  0x800'034a: 0x2180          MOVS     R1, #128               ; 0x80
  0x800'034c: 0x4648          MOV      R0, R9
  0x800'034e: 0xf000 0xf9d3   BL       UART_WaitOnFlagUntilTimeout
                                                              ; 0x800'06f8
  0x800'0352: 0x2800          CMP      R0, #0
  0x800'0354: 0xd004          BEQ.N    ??HAL_UART_Transmit_7  ; 0x800'0360
  //         huart->gState = HAL_UART_STATE_READY;
  0x800'0356: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0358: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //         return HAL_TIMEOUT;
  0x800'035c: 0x2003          MOVS     R0, #3
  0x800'035e: 0xe02a          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_7:
  //       if (pdata8bits == NULL)
  0x800'0360: 0x2c00          CMP      R4, #0
  0x800'0362: 0xd109          BNE.N    ??HAL_UART_Transmit_8  ; 0x800'0378
  //         huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
  0x800'0364: 0xf8ba 0x1000   LDRH.W   R1, [R10]
  0x800'0368: 0x05c9          LSLS     R1, R1, #23
  0x800'036a: 0x0dc9          LSRS     R1, R1, #23
  0x800'036c: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'0370: 0x6041          STR      R1, [R0, #0x4]
  //         pdata16bits++;
  0x800'0372: 0xf11a 0x0a02   ADDS.W   R10, R10, #2
  0x800'0376: 0xe004          B.N      ??HAL_UART_Transmit_9  ; 0x800'0382
                ??HAL_UART_Transmit_8:
  //         huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
  0x800'0378: 0x7821          LDRB     R1, [R4]
  0x800'037a: 0xf8d9 0x0000   LDR.W    R0, [R9]
  0x800'037e: 0x6041          STR      R1, [R0, #0x4]
  //         pdata8bits++;
  0x800'0380: 0x1c64          ADDS     R4, R4, #1
                ??HAL_UART_Transmit_9:
  //       huart->TxXferCount--;
  0x800'0382: 0xf8b9 0x0026   LDRH.W   R0, [R9, #0x26]
  0x800'0386: 0x1e40          SUBS     R0, R0, #1
  0x800'0388: 0xf8a9 0x0026   STRH.W   R0, [R9, #0x26]
  0x800'038c: 0xe7d6          B.N      ??HAL_UART_Transmit_5  ; 0x800'033c
                ??HAL_UART_Transmit_6:
  //     if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
  0x800'038e: 0x9700          STR      R7, [SP]
  0x800'0390: 0x4643          MOV      R3, R8
  0x800'0392: 0x2200          MOVS     R2, #0
  0x800'0394: 0x2140          MOVS     R1, #64                ; 0x40
  0x800'0396: 0x4648          MOV      R0, R9
  0x800'0398: 0xf000 0xf9ae   BL       UART_WaitOnFlagUntilTimeout
                                                              ; 0x800'06f8
  0x800'039c: 0x2800          CMP      R0, #0
  0x800'039e: 0xd004          BEQ.N    ??HAL_UART_Transmit_10 ; 0x800'03aa
  //       huart->gState = HAL_UART_STATE_READY;
  0x800'03a0: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'03a2: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //       return HAL_TIMEOUT;
  0x800'03a6: 0x2003          MOVS     R0, #3
  0x800'03a8: 0xe005          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_10:
  //     huart->gState = HAL_UART_STATE_READY;
  0x800'03aa: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'03ac: 0xf889 0x0041   STRB.W   R0, [R9, #0x41]
  //     return HAL_OK;
  0x800'03b0: 0x2000          MOVS     R0, #0
  0x800'03b2: 0xe000          B.N      ??HAL_UART_Transmit_3  ; 0x800'03b6
                ??HAL_UART_Transmit_0:
  //     return HAL_BUSY;
  0x800'03b4: 0x2002          MOVS     R0, #2
                ??HAL_UART_Transmit_3:
  0x800'03b6: 0xe8bd 0x87f6   POP.W    {R1, R2, R4-R10, PC}
  0x800'03ba: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable5:
  0x800'03bc: 0x4001'1000     DC32     0x4001'1000            ; '...@'
                ??DataTable5_1:
  0x800'03c0: 0x4000'4400     DC32     0x4000'4400            ; '.D.@'
                ??DataTable5_2:
  0x800'03c4: 0x4000'4800     DC32     0x4000'4800            ; '.H.@'
                ??DataTable5_3:
  0x800'03c8: 0x4001'1400     DC32     0x4001'1400            ; '...@'
                ??DataTable5_4:
  0x800'03cc: 0x0800'2924     DC32     ?_0
                ??DataTable5_5:
  0x800'03d0: 0x4000'4c00     DC32     0x4000'4c00            ; '.L.@'
                ??DataTable5_6:
  0x800'03d4: 0x4000'5000     DC32     0x4000'5000            ; '.P.@'
                $t:
                `.text_37`:
                HAL_UART_IRQHandler:
  // void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
  // {
  0x800'03d8: 0xe92d 0x47fc   PUSH.W   {R2-R10, LR}
  0x800'03dc: 0x4682          MOV      R10, R0
  //   uint32_t isrflags   = READ_REG(huart->Instance->SR);
  0x800'03de: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'03e2: 0x6806          LDR      R6, [R0]
  //   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
  0x800'03e4: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'03e8: 0x68c7          LDR      R7, [R0, #0xc]
  //   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
  0x800'03ea: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'03ee: 0xf8d0 0x8014   LDR.W    R8, [R0, #0x14]
  //   uint32_t errorflags = 0x00U;
  0x800'03f2: 0x2000          MOVS     R0, #0
  //   uint32_t dmarequest = 0x00U;
  0x800'03f4: 0x2500          MOVS     R5, #0
  //   errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  0x800'03f6: 0xf016 0x040f   ANDS.W   R4, R6, #15            ; 0xf
  //   if (errorflags == RESET)
  0x800'03fa: 0x2c00          CMP      R4, #0
  0x800'03fc: 0xd107          BNE.N    ??HAL_UART_IRQHandler_0
                                                              ; 0x800'040e
  //     if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
  0x800'03fe: 0x06b0          LSLS     R0, R6, #26
  0x800'0400: 0xd505          BPL.N    ??HAL_UART_IRQHandler_0
                                                              ; 0x800'040e
  0x800'0402: 0x06b8          LSLS     R0, R7, #26
  0x800'0404: 0xd503          BPL.N    ??HAL_UART_IRQHandler_0
                                                              ; 0x800'040e
  //       UART_Receive_IT(huart);
  0x800'0406: 0x4650          MOV      R0, R10
  0x800'0408: 0xf000 0xfa41   BL       UART_Receive_IT        ; 0x800'088e
  //       return;
  0x800'040c: 0xe172          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_0:
  //   if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
  //                                 || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
  0x800'040e: 0x2c00          CMP      R4, #0
  0x800'0410: 0xf000 0x808a   BEQ.W    ??HAL_UART_IRQHandler_2
                                                              ; 0x800'0528
  0x800'0414: 0xea5f 0x70c8   LSLS.W   R0, R8, #31
  0x800'0418: 0xd403          BMI.N    ??HAL_UART_IRQHandler_3
                                                              ; 0x800'0422
  0x800'041a: 0xf417 0x7f90   TST.W    R7, #288               ; 0x120
  0x800'041e: 0xf000 0x8083   BEQ.W    ??HAL_UART_IRQHandler_2
                                                              ; 0x800'0528
                ??HAL_UART_IRQHandler_3:
  //     if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
  0x800'0422: 0x0030          MOVS     R0, R6
  0x800'0424: 0x07c0          LSLS     R0, R0, #31
  0x800'0426: 0xd507          BPL.N    ??HAL_UART_IRQHandler_4
                                                              ; 0x800'0438
  0x800'0428: 0x05f8          LSLS     R0, R7, #23
  0x800'042a: 0xd505          BPL.N    ??HAL_UART_IRQHandler_4
                                                              ; 0x800'0438
  //       huart->ErrorCode |= HAL_UART_ERROR_PE;
  0x800'042c: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0430: 0xf050 0x0001   ORRS.W   R0, R0, #1
  0x800'0434: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_4:
  //     if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
  0x800'0438: 0x0770          LSLS     R0, R6, #29
  0x800'043a: 0xd508          BPL.N    ??HAL_UART_IRQHandler_5
                                                              ; 0x800'044e
  0x800'043c: 0x4640          MOV      R0, R8
  0x800'043e: 0x07c0          LSLS     R0, R0, #31
  0x800'0440: 0xd505          BPL.N    ??HAL_UART_IRQHandler_5
                                                              ; 0x800'044e
  //       huart->ErrorCode |= HAL_UART_ERROR_NE;
  0x800'0442: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0446: 0xf050 0x0002   ORRS.W   R0, R0, #2
  0x800'044a: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_5:
  //     if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
  0x800'044e: 0x07b0          LSLS     R0, R6, #30
  0x800'0450: 0xd508          BPL.N    ??HAL_UART_IRQHandler_6
                                                              ; 0x800'0464
  0x800'0452: 0x4640          MOV      R0, R8
  0x800'0454: 0x07c0          LSLS     R0, R0, #31
  0x800'0456: 0xd505          BPL.N    ??HAL_UART_IRQHandler_6
                                                              ; 0x800'0464
  //       huart->ErrorCode |= HAL_UART_ERROR_FE;
  0x800'0458: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'045c: 0xf050 0x0004   ORRS.W   R0, R0, #4
  0x800'0460: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_6:
  //     if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
  //                                                  || ((cr3its & USART_CR3_EIE) != RESET)))
  0x800'0464: 0x0730          LSLS     R0, R6, #28
  0x800'0466: 0xd50a          BPL.N    ??HAL_UART_IRQHandler_7
                                                              ; 0x800'047e
  0x800'0468: 0x06b8          LSLS     R0, R7, #26
  0x800'046a: 0xd402          BMI.N    ??HAL_UART_IRQHandler_8
                                                              ; 0x800'0472
  0x800'046c: 0x4640          MOV      R0, R8
  0x800'046e: 0x07c0          LSLS     R0, R0, #31
  0x800'0470: 0xd505          BPL.N    ??HAL_UART_IRQHandler_7
                                                              ; 0x800'047e
                ??HAL_UART_IRQHandler_8:
  //       huart->ErrorCode |= HAL_UART_ERROR_ORE;
  0x800'0472: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0476: 0xf050 0x0008   ORRS.W   R0, R0, #8
  0x800'047a: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_7:
  //     if (huart->ErrorCode != HAL_UART_ERROR_NONE)
  0x800'047e: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'0482: 0x2800          CMP      R0, #0
  0x800'0484: 0xd04f          BEQ.N    ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
  //       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
  0x800'0486: 0x06b0          LSLS     R0, R6, #26
  0x800'0488: 0xd504          BPL.N    ??HAL_UART_IRQHandler_10
                                                              ; 0x800'0494
  0x800'048a: 0x06b8          LSLS     R0, R7, #26
  0x800'048c: 0xd502          BPL.N    ??HAL_UART_IRQHandler_10
                                                              ; 0x800'0494
  //         UART_Receive_IT(huart);
  0x800'048e: 0x4650          MOV      R0, R10
  0x800'0490: 0xf000 0xf9fd   BL       UART_Receive_IT        ; 0x800'088e
                ??HAL_UART_IRQHandler_10:
  //       dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'0494: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0498: 0x6940          LDR      R0, [R0, #0x14]
  0x800'049a: 0x0980          LSRS     R0, R0, #6
  0x800'049c: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'04a0: 0x0005          MOVS     R5, R0
  //       if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
  0x800'04a2: 0xf8da 0x0044   LDR.W    R0, [R10, #0x44]
  0x800'04a6: 0x0700          LSLS     R0, R0, #28
  0x800'04a8: 0xd401          BMI.N    ??HAL_UART_IRQHandler_11
                                                              ; 0x800'04ae
  0x800'04aa: 0x2d00          CMP      R5, #0
  0x800'04ac: 0xd035          BEQ.N    ??HAL_UART_IRQHandler_12
                                                              ; 0x800'051a
                ??HAL_UART_IRQHandler_11:
  //         UART_EndRxTransfer(huart);
  0x800'04ae: 0x4650          MOV      R0, R10
  0x800'04b0: 0xf000 0xf969   BL       UART_EndRxTransfer     ; 0x800'0786
  //         if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  0x800'04b4: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'04b8: 0x6940          LDR      R0, [R0, #0x14]
  0x800'04ba: 0x0640          LSLS     R0, R0, #25
  0x800'04bc: 0xd529          BPL.N    ??HAL_UART_IRQHandler_13
                                                              ; 0x800'0512
                ??HAL_UART_IRQHandler_14:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'04be: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'04c2: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'04c4: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'04c8: 0xf030 0x0040   BICS.W   R0, R0, #64            ; 0x40
  0x800'04cc: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'04ce: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'04d2: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'04d6: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'04da: 0x2800          CMP      R0, #0
  0x800'04dc: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_14
                                                              ; 0x800'04be
  //           if (huart->hdmarx != NULL)
  0x800'04de: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'04e2: 0x2800          CMP      R0, #0
  0x800'04e4: 0xd011          BEQ.N    ??HAL_UART_IRQHandler_15
                                                              ; 0x800'050a
  //             huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
  0x800'04e6: 0xf20f 0x3109   ADR.W    R1, UART_DMAAbortOnError
                                                              ; 0x800'07f1
  0x800'04ea: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'04ee: 0x6501          STR      R1, [R0, #0x50]
  //             if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
  0x800'04f0: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'04f4: 0xf000 0xfcf8   BL       HAL_DMA_Abort_IT       ; 0x800'0ee8
  0x800'04f8: 0x2800          CMP      R0, #0
  0x800'04fa: 0xd014          BEQ.N    ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
  //               huart->hdmarx->XferAbortCallback(huart->hdmarx);
  0x800'04fc: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'0500: 0xf8da 0x103c   LDR.W    R1, [R10, #0x3c]
  0x800'0504: 0x6d09          LDR      R1, [R1, #0x50]
  0x800'0506: 0x4788          BLX      R1
  0x800'0508: 0xe00d          B.N      ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
                ??HAL_UART_IRQHandler_15:
  //             HAL_UART_ErrorCallback(huart);
  0x800'050a: 0x4650          MOV      R0, R10
  0x800'050c: 0xf000 0xfd00   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  0x800'0510: 0xe009          B.N      ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
                ??HAL_UART_IRQHandler_13:
  //           HAL_UART_ErrorCallback(huart);
  0x800'0512: 0x4650          MOV      R0, R10
  0x800'0514: 0xf000 0xfcfc   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  0x800'0518: 0xe005          B.N      ??HAL_UART_IRQHandler_9
                                                              ; 0x800'0526
                ??HAL_UART_IRQHandler_12:
  //         HAL_UART_ErrorCallback(huart);
  0x800'051a: 0x4650          MOV      R0, R10
  0x800'051c: 0xf000 0xfcf8   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  //         huart->ErrorCode = HAL_UART_ERROR_NONE;
  0x800'0520: 0x2000          MOVS     R0, #0
  0x800'0522: 0xf8ca 0x0044   STR.W    R0, [R10, #0x44]
                ??HAL_UART_IRQHandler_9:
  //     return;
  0x800'0526: 0xe0e5          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_2:
  //   if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  //       && ((isrflags & USART_SR_IDLE) != 0U)
  //       && ((cr1its & USART_SR_IDLE) != 0U))
  0x800'0528: 0xf8da 0x0030   LDR.W    R0, [R10, #0x30]
  0x800'052c: 0x2801          CMP      R0, #1
  0x800'052e: 0xf040 0x80d1   BNE.W    ??HAL_UART_IRQHandler_16
                                                              ; 0x800'06d4
  0x800'0532: 0x06f0          LSLS     R0, R6, #27
  0x800'0534: 0xf140 0x80ce   BPL.W    ??HAL_UART_IRQHandler_16
                                                              ; 0x800'06d4
  0x800'0538: 0x06f8          LSLS     R0, R7, #27
  0x800'053a: 0xf140 0x80cb   BPL.W    ??HAL_UART_IRQHandler_16
                                                              ; 0x800'06d4
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'053e: 0x2000          MOVS     R0, #0
  0x800'0540: 0x9000          STR      R0, [SP]
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0542: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0546: 0x6800          LDR      R0, [R0]
  0x800'0548: 0x9000          STR      R0, [SP]
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'054a: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'054e: 0x6840          LDR      R0, [R0, #0x4]
  0x800'0550: 0x9000          STR      R0, [SP]
  //     __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0552: 0x9800          LDR      R0, [SP]
  //     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  0x800'0554: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0558: 0x6940          LDR      R0, [R0, #0x14]
  0x800'055a: 0x0640          LSLS     R0, R0, #25
  0x800'055c: 0xd56d          BPL.N    ??HAL_UART_IRQHandler_17
                                                              ; 0x800'063a
  //       uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
  0x800'055e: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'0562: 0x6800          LDR      R0, [R0]
  0x800'0564: 0xf8d0 0x9004   LDR.W    R9, [R0, #0x4]
  //       if ((nb_remaining_rx_data > 0U)
  //           && (nb_remaining_rx_data < huart->RxXferSize))
  0x800'0568: 0x4648          MOV      R0, R9
  0x800'056a: 0xb280          UXTH     R0, R0
  0x800'056c: 0x2800          CMP      R0, #0
  0x800'056e: 0xd063          BEQ.N    ??HAL_UART_IRQHandler_18
                                                              ; 0x800'0638
  0x800'0570: 0x4649          MOV      R1, R9
  0x800'0572: 0xf8ba 0x002c   LDRH.W   R0, [R10, #0x2c]
  0x800'0576: 0xb289          UXTH     R1, R1
  0x800'0578: 0x4281          CMP      R1, R0
  0x800'057a: 0xd25d          BCS.N    ??HAL_UART_IRQHandler_18
                                                              ; 0x800'0638
  //         huart->RxXferCount = nb_remaining_rx_data;
  0x800'057c: 0xf8aa 0x902e   STRH.W   R9, [R10, #0x2e]
  //         if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
  0x800'0580: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'0584: 0x69c0          LDR      R0, [R0, #0x1c]
  0x800'0586: 0xf5b0 0x7f80   CMP.W    R0, #256               ; 0x100
  0x800'058a: 0xd049          BEQ.N    ??HAL_UART_IRQHandler_19
                                                              ; 0x800'0620
                ??HAL_UART_IRQHandler_20:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  0x800'058c: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'0590: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'0592: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0596: 0xf430 0x7080   BICS.W   R0, R0, #256           ; 0x100
  0x800'059a: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  0x800'059c: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05a0: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'05a4: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'05a8: 0x2800          CMP      R0, #0
  0x800'05aa: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_20
                                                              ; 0x800'058c
                ??HAL_UART_IRQHandler_21:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'05ac: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05b0: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'05b2: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'05b6: 0x0840          LSRS     R0, R0, #1
  0x800'05b8: 0x0040          LSLS     R0, R0, #1
  0x800'05ba: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'05bc: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05c0: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'05c4: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'05c8: 0x2800          CMP      R0, #0
  0x800'05ca: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_21
                                                              ; 0x800'05ac
                ??HAL_UART_IRQHandler_22:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'05cc: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05d0: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'05d2: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'05d6: 0xf030 0x0040   BICS.W   R0, R0, #64            ; 0x40
  0x800'05da: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  0x800'05dc: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05e0: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'05e4: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'05e8: 0x2800          CMP      R0, #0
  0x800'05ea: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_22
                                                              ; 0x800'05cc
  //           huart->RxState = HAL_UART_STATE_READY;
  0x800'05ec: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'05ee: 0xf88a 0x0042   STRB.W   R0, [R10, #0x42]
  //           huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'05f2: 0x2000          MOVS     R0, #0
  0x800'05f4: 0xf8ca 0x0030   STR.W    R0, [R10, #0x30]
                ??HAL_UART_IRQHandler_23:
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'05f8: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'05fc: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'05fe: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0602: 0xf030 0x0010   BICS.W   R0, R0, #16            ; 0x10
  0x800'0606: 0x0001          MOVS     R1, R0
  //           ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'0608: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'060c: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'0610: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'0614: 0x2800          CMP      R0, #0
  0x800'0616: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_23
                                                              ; 0x800'05f8
  //           (void)HAL_DMA_Abort(huart->hdmarx);
  0x800'0618: 0xf8da 0x003c   LDR.W    R0, [R10, #0x3c]
  0x800'061c: 0xf000 0xfc16   BL       HAL_DMA_Abort          ; 0x800'0e4c
                ??HAL_UART_IRQHandler_19:
  //         huart->RxEventType = HAL_UART_RXEVENT_IDLE;
  0x800'0620: 0x2002          MOVS     R0, #2
  0x800'0622: 0xf8ca 0x0034   STR.W    R0, [R10, #0x34]
  //         HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
  0x800'0626: 0xf8ba 0x102c   LDRH.W   R1, [R10, #0x2c]
  0x800'062a: 0xf8ba 0x002e   LDRH.W   R0, [R10, #0x2e]
  0x800'062e: 0x1a09          SUBS     R1, R1, R0
  0x800'0630: 0xb289          UXTH     R1, R1
  0x800'0632: 0x4650          MOV      R0, R10
  0x800'0634: 0xf000 0xfc6d   BL       HAL_UARTEx_RxEventCallback
                                                              ; 0x800'0f12
                ??HAL_UART_IRQHandler_18:
  //       return;
  0x800'0638: 0xe05c          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_17:
  //       uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
  0x800'063a: 0xf8ba 0x902c   LDRH.W   R9, [R10, #0x2c]
  0x800'063e: 0xf8ba 0x002e   LDRH.W   R0, [R10, #0x2e]
  0x800'0642: 0xebb9 0x0900   SUBS.W   R9, R9, R0
  //       if ((huart->RxXferCount > 0U)
  //           && (nb_rx_data > 0U))
  0x800'0646: 0xf8ba 0x002e   LDRH.W   R0, [R10, #0x2e]
  0x800'064a: 0x2800          CMP      R0, #0
  0x800'064c: 0xd041          BEQ.N    ??HAL_UART_IRQHandler_24
                                                              ; 0x800'06d2
  0x800'064e: 0x4648          MOV      R0, R9
  0x800'0650: 0xb280          UXTH     R0, R0
  0x800'0652: 0x2800          CMP      R0, #0
  0x800'0654: 0xd03d          BEQ.N    ??HAL_UART_IRQHandler_24
                                                              ; 0x800'06d2
                ??HAL_UART_IRQHandler_25:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0656: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'065a: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'065c: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0660: 0xf430 0x7090   BICS.W   R0, R0, #288           ; 0x120
  0x800'0664: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0666: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'066a: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'066e: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'0672: 0x2800          CMP      R0, #0
  0x800'0674: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_25
                                                              ; 0x800'0656
                ??HAL_UART_IRQHandler_26:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'0676: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'067a: 0x3014          ADDS     R0, R0, #20            ; 0x14
  0x800'067c: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'0680: 0x0840          LSRS     R0, R0, #1
  0x800'0682: 0x0040          LSLS     R0, R0, #1
  0x800'0684: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'0686: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'068a: 0xf110 0x0214   ADDS.W   R2, R0, #20            ; 0x14
  0x800'068e: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'0692: 0x2800          CMP      R0, #0
  0x800'0694: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_26
                                                              ; 0x800'0676
  //         huart->RxState = HAL_UART_STATE_READY;
  0x800'0696: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0698: 0xf88a 0x0042   STRB.W   R0, [R10, #0x42]
  //         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'069c: 0x2000          MOVS     R0, #0
  0x800'069e: 0xf8ca 0x0030   STR.W    R0, [R10, #0x30]
                ??HAL_UART_IRQHandler_27:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'06a2: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'06a6: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'06a8: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'06ac: 0xf030 0x0010   BICS.W   R0, R0, #16            ; 0x10
  0x800'06b0: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'06b2: 0xf8da 0x0000   LDR.W    R0, [R10]
  0x800'06b6: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'06ba: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'06be: 0x2800          CMP      R0, #0
  0x800'06c0: 0xd1ef          BNE.N    ??HAL_UART_IRQHandler_27
                                                              ; 0x800'06a2
  //         huart->RxEventType = HAL_UART_RXEVENT_IDLE;
  0x800'06c2: 0x2002          MOVS     R0, #2
  0x800'06c4: 0xf8ca 0x0034   STR.W    R0, [R10, #0x34]
  //         HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
  0x800'06c8: 0x4649          MOV      R1, R9
  0x800'06ca: 0xb289          UXTH     R1, R1
  0x800'06cc: 0x4650          MOV      R0, R10
  0x800'06ce: 0xf000 0xfc20   BL       HAL_UARTEx_RxEventCallback
                                                              ; 0x800'0f12
                ??HAL_UART_IRQHandler_24:
  //       return;
  0x800'06d2: 0xe00f          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_16:
  //   if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
  0x800'06d4: 0x0630          LSLS     R0, R6, #24
  0x800'06d6: 0xd505          BPL.N    ??HAL_UART_IRQHandler_28
                                                              ; 0x800'06e4
  0x800'06d8: 0x0638          LSLS     R0, R7, #24
  0x800'06da: 0xd503          BPL.N    ??HAL_UART_IRQHandler_28
                                                              ; 0x800'06e4
  //     UART_Transmit_IT(huart);
  0x800'06dc: 0x4650          MOV      R0, R10
  0x800'06de: 0xf000 0xf893   BL       UART_Transmit_IT       ; 0x800'0808
  //     return;
  0x800'06e2: 0xe007          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_28:
  //   if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  0x800'06e4: 0x0670          LSLS     R0, R6, #25
  0x800'06e6: 0xd505          BPL.N    ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
  0x800'06e8: 0x0678          LSLS     R0, R7, #25
  0x800'06ea: 0xd503          BPL.N    ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
  //     UART_EndTransmit_IT(huart);
  0x800'06ec: 0x4650          MOV      R0, R10
  0x800'06ee: 0xf000 0xf8be   BL       UART_EndTransmit_IT    ; 0x800'086e
  //     return;
  0x800'06f2: 0xe7ff          B.N      ??HAL_UART_IRQHandler_29
                                                              ; 0x800'06f4
                ??HAL_UART_IRQHandler_1:
                ??HAL_UART_IRQHandler_29:
  // }
  0x800'06f4: 0xe8bd 0x87f3   POP.W    {R0, R1, R4-R10, PC}
                `.text_50`:
                UART_WaitOnFlagUntilTimeout:
  // static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
  //                                                      uint32_t Tickstart, uint32_t Timeout)
  // {
  0x800'06f8: 0xe92d 0x41fc   PUSH.W   {R2-R8, LR}
  0x800'06fc: 0x4680          MOV      R8, R0
  0x800'06fe: 0x000d          MOVS     R5, R1
  0x800'0700: 0x0016          MOVS     R6, R2
  0x800'0702: 0x001f          MOVS     R7, R3
  0x800'0704: 0x9c08          LDR      R4, [SP, #0x20]
                ??UART_WaitOnFlagUntilTimeout_0:
  //   while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  0x800'0706: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'070a: 0x6800          LDR      R0, [R0]
  0x800'070c: 0x4028          ANDS     R0, R0, R5
  0x800'070e: 0x42a8          CMP      R0, R5
  0x800'0710: 0xd101          BNE.N    ??UART_WaitOnFlagUntilTimeout_1
                                                              ; 0x800'0716
  0x800'0712: 0x2101          MOVS     R1, #1
  0x800'0714: 0xe000          B.N      ??UART_WaitOnFlagUntilTimeout_2
                                                              ; 0x800'0718
                ??UART_WaitOnFlagUntilTimeout_1:
  0x800'0716: 0x2100          MOVS     R1, #0
                ??UART_WaitOnFlagUntilTimeout_2:
  0x800'0718: 0x0030          MOVS     R0, R6
  0x800'071a: 0xb2c0          UXTB     R0, R0
  0x800'071c: 0x4281          CMP      R1, R0
  0x800'071e: 0xd12f          BNE.N    ??UART_WaitOnFlagUntilTimeout_3
                                                              ; 0x800'0780
  //     if (Timeout != HAL_MAX_DELAY)
  0x800'0720: 0xf114 0x0f01   CMN.W    R4, #1
  0x800'0724: 0xd0ef          BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  //       if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
  0x800'0726: 0xf000 0xfb8b   BL       HAL_GetTick            ; 0x800'0e40
  0x800'072a: 0x1bc0          SUBS     R0, R0, R7
  0x800'072c: 0x4284          CMP      R4, R0
  0x800'072e: 0xd301          BCC.N    ??UART_WaitOnFlagUntilTimeout_4
                                                              ; 0x800'0734
  0x800'0730: 0x2c00          CMP      R4, #0
  0x800'0732: 0xd101          BNE.N    ??UART_WaitOnFlagUntilTimeout_5
                                                              ; 0x800'0738
                ??UART_WaitOnFlagUntilTimeout_4:
  //         return HAL_TIMEOUT;
  0x800'0734: 0x2003          MOVS     R0, #3
  0x800'0736: 0xe024          B.N      ??UART_WaitOnFlagUntilTimeout_6
                                                              ; 0x800'0782
                ??UART_WaitOnFlagUntilTimeout_5:
  //       if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
  0x800'0738: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'073c: 0x68c0          LDR      R0, [R0, #0xc]
  0x800'073e: 0x0740          LSLS     R0, R0, #29
  0x800'0740: 0xd5e1          BPL.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  0x800'0742: 0x2d80          CMP      R5, #128               ; 0x80
  0x800'0744: 0xd0df          BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  0x800'0746: 0x2d40          CMP      R5, #64                ; 0x40
  0x800'0748: 0xd0dd          BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  //         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
  0x800'074a: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'074e: 0x6800          LDR      R0, [R0]
  0x800'0750: 0x0700          LSLS     R0, R0, #28
  0x800'0752: 0xd5d8          BPL.N    ??UART_WaitOnFlagUntilTimeout_0
                                                              ; 0x800'0706
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0754: 0x2000          MOVS     R0, #0
  0x800'0756: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0758: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'075c: 0x6800          LDR      R0, [R0]
  0x800'075e: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0760: 0xf8d8 0x0000   LDR.W    R0, [R8]
  0x800'0764: 0x6840          LDR      R0, [R0, #0x4]
  0x800'0766: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_OREFLAG(huart);
  0x800'0768: 0x9800          LDR      R0, [SP]
  //           UART_EndRxTransfer(huart);
  0x800'076a: 0x4640          MOV      R0, R8
  0x800'076c: 0xf000 0xf80b   BL       UART_EndRxTransfer     ; 0x800'0786
  //           huart->ErrorCode = HAL_UART_ERROR_ORE;
  0x800'0770: 0x2008          MOVS     R0, #8
  0x800'0772: 0xf8c8 0x0044   STR.W    R0, [R8, #0x44]
  //           __HAL_UNLOCK(huart);
  0x800'0776: 0x2000          MOVS     R0, #0
  0x800'0778: 0xf888 0x0040   STRB.W   R0, [R8, #0x40]
  //           return HAL_ERROR;
  0x800'077c: 0x2001          MOVS     R0, #1
  0x800'077e: 0xe000          B.N      ??UART_WaitOnFlagUntilTimeout_6
                                                              ; 0x800'0782
                ??UART_WaitOnFlagUntilTimeout_3:
  //   return HAL_OK;
  0x800'0780: 0x2000          MOVS     R0, #0
                ??UART_WaitOnFlagUntilTimeout_6:
  0x800'0782: 0xe8bd 0x81f6   POP.W    {R1, R2, R4-R8, PC}
                `.text_54`:
                ??UART_EndRxTransfer_0:
                UART_EndRxTransfer:
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0786: 0x6801          LDR      R1, [R0]
  0x800'0788: 0x310c          ADDS     R1, R1, #12            ; 0xc
  0x800'078a: 0xe851 0x1f00   LDREX    R1, [R1]
  0x800'078e: 0xf431 0x7190   BICS.W   R1, R1, #288           ; 0x120
  0x800'0792: 0x000a          MOVS     R2, R1
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  0x800'0794: 0x6801          LDR      R1, [R0]
  0x800'0796: 0xf111 0x030c   ADDS.W   R3, R1, #12            ; 0xc
  0x800'079a: 0xe843 0x2100   STREX    R1, R2, [R3]
  0x800'079e: 0x2900          CMP      R1, #0
  0x800'07a0: 0xd1f1          BNE.N    UART_EndRxTransfer     ; 0x800'0786
                ??UART_EndRxTransfer_1:
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'07a2: 0x6801          LDR      R1, [R0]
  0x800'07a4: 0x3114          ADDS     R1, R1, #20            ; 0x14
  0x800'07a6: 0xe851 0x1f00   LDREX    R1, [R1]
  0x800'07aa: 0x0849          LSRS     R1, R1, #1
  0x800'07ac: 0x0049          LSLS     R1, R1, #1
  0x800'07ae: 0x000a          MOVS     R2, R1
  //   ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  0x800'07b0: 0x6801          LDR      R1, [R0]
  0x800'07b2: 0xf111 0x0314   ADDS.W   R3, R1, #20            ; 0x14
  0x800'07b6: 0xe843 0x2100   STREX    R1, R2, [R3]
  0x800'07ba: 0x2900          CMP      R1, #0
  0x800'07bc: 0xd1f1          BNE.N    ??UART_EndRxTransfer_1 ; 0x800'07a2
  //   if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  0x800'07be: 0x6b01          LDR      R1, [R0, #0x30]
  0x800'07c0: 0x2901          CMP      R1, #1
  0x800'07c2: 0xd10d          BNE.N    ??UART_EndRxTransfer_2 ; 0x800'07e0
                ??UART_EndRxTransfer_3:
  //     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'07c4: 0x6801          LDR      R1, [R0]
  0x800'07c6: 0x310c          ADDS     R1, R1, #12            ; 0xc
  0x800'07c8: 0xe851 0x1f00   LDREX    R1, [R1]
  0x800'07cc: 0xf031 0x0110   BICS.W   R1, R1, #16            ; 0x10
  0x800'07d0: 0x000a          MOVS     R2, R1
  //     ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'07d2: 0x6801          LDR      R1, [R0]
  0x800'07d4: 0xf111 0x030c   ADDS.W   R3, R1, #12            ; 0xc
  0x800'07d8: 0xe843 0x2100   STREX    R1, R2, [R3]
  0x800'07dc: 0x2900          CMP      R1, #0
  0x800'07de: 0xd1f1          BNE.N    ??UART_EndRxTransfer_3 ; 0x800'07c4
                ??UART_EndRxTransfer_2:
  //   huart->RxState = HAL_UART_STATE_READY;
  0x800'07e0: 0x2120          MOVS     R1, #32                ; 0x20
  0x800'07e2: 0xf880 0x1042   STRB.W   R1, [R0, #0x42]
  //   huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'07e6: 0x2100          MOVS     R1, #0
  0x800'07e8: 0x6301          STR      R1, [R0, #0x30]
  // }
  0x800'07ea: 0x4770          BX       LR
  0x800'07ec: 0x0000          MOVS     R0, R0
  0x800'07ee: 0x0000          MOVS     R0, R0
                `.text_55`:
                UART_DMAAbortOnError:
  // static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
  // {
  0x800'07f0: 0xb538          PUSH     {R3-R5, LR}
  0x800'07f2: 0x0004          MOVS     R4, R0
  //   UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
  0x800'07f4: 0x6ba5          LDR      R5, [R4, #0x38]
  //   huart->RxXferCount = 0x00U;
  0x800'07f6: 0x2000          MOVS     R0, #0
  0x800'07f8: 0x85e8          STRH     R0, [R5, #0x2e]
  //   huart->TxXferCount = 0x00U;
  0x800'07fa: 0x2000          MOVS     R0, #0
  0x800'07fc: 0x84e8          STRH     R0, [R5, #0x26]
  //   HAL_UART_ErrorCallback(huart);
  0x800'07fe: 0x0028          MOVS     R0, R5
  0x800'0800: 0xf000 0xfb86   BL       HAL_UART_ErrorCallback ; 0x800'0f10
  // }
  0x800'0804: 0xbd31          POP      {R0, R4, R5, PC}
  0x800'0806: 0x0000          MOVS     R0, R0
                `.text_60`:
                UART_Transmit_IT:
  // static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
  // {
  0x800'0808: 0x0001          MOVS     R1, R0
  //   if (huart->gState == HAL_UART_STATE_BUSY_TX)
  0x800'080a: 0xf891 0x0041   LDRB.W   R0, [R1, #0x41]
  0x800'080e: 0x2821          CMP      R0, #33                ; 0x21
  0x800'0810: 0xd12b          BNE.N    ??UART_Transmit_IT_0   ; 0x800'086a
  //     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  0x800'0812: 0x6888          LDR      R0, [R1, #0x8]
  0x800'0814: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'0818: 0xd10d          BNE.N    ??UART_Transmit_IT_1   ; 0x800'0836
  0x800'081a: 0x6908          LDR      R0, [R1, #0x10]
  0x800'081c: 0x2800          CMP      R0, #0
  0x800'081e: 0xd10a          BNE.N    ??UART_Transmit_IT_1   ; 0x800'0836
  //       tmp = (const uint16_t *) huart->pTxBuffPtr;
  0x800'0820: 0x6a08          LDR      R0, [R1, #0x20]
  0x800'0822: 0x0002          MOVS     R2, R0
  //       huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
  0x800'0824: 0x8813          LDRH     R3, [R2]
  0x800'0826: 0x05db          LSLS     R3, R3, #23
  0x800'0828: 0x0ddb          LSRS     R3, R3, #23
  0x800'082a: 0x6808          LDR      R0, [R1]
  0x800'082c: 0x6043          STR      R3, [R0, #0x4]
  //       huart->pTxBuffPtr += 2U;
  0x800'082e: 0x6a08          LDR      R0, [R1, #0x20]
  0x800'0830: 0x1c80          ADDS     R0, R0, #2
  0x800'0832: 0x6208          STR      R0, [R1, #0x20]
  0x800'0834: 0xe005          B.N      ??UART_Transmit_IT_2   ; 0x800'0842
                ??UART_Transmit_IT_1:
  //       huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
  0x800'0836: 0x6a0b          LDR      R3, [R1, #0x20]
  0x800'0838: 0x1c58          ADDS     R0, R3, #1
  0x800'083a: 0x6208          STR      R0, [R1, #0x20]
  0x800'083c: 0x781b          LDRB     R3, [R3]
  0x800'083e: 0x6808          LDR      R0, [R1]
  0x800'0840: 0x6043          STR      R3, [R0, #0x4]
                ??UART_Transmit_IT_2:
  //     if (--huart->TxXferCount == 0U)
  0x800'0842: 0x8cc8          LDRH     R0, [R1, #0x26]
  0x800'0844: 0x1e40          SUBS     R0, R0, #1
  0x800'0846: 0x84c8          STRH     R0, [R1, #0x26]
  0x800'0848: 0xb280          UXTH     R0, R0
  0x800'084a: 0x2800          CMP      R0, #0
  0x800'084c: 0xd10b          BNE.N    ??UART_Transmit_IT_3   ; 0x800'0866
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
  0x800'084e: 0x6808          LDR      R0, [R1]
  0x800'0850: 0x68c3          LDR      R3, [R0, #0xc]
  0x800'0852: 0xf033 0x0380   BICS.W   R3, R3, #128           ; 0x80
  0x800'0856: 0x6808          LDR      R0, [R1]
  0x800'0858: 0x60c3          STR      R3, [R0, #0xc]
  //       __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
  0x800'085a: 0x6808          LDR      R0, [R1]
  0x800'085c: 0x68c3          LDR      R3, [R0, #0xc]
  0x800'085e: 0xf053 0x0340   ORRS.W   R3, R3, #64            ; 0x40
  0x800'0862: 0x6808          LDR      R0, [R1]
  0x800'0864: 0x60c3          STR      R3, [R0, #0xc]
                ??UART_Transmit_IT_3:
  //     return HAL_OK;
  0x800'0866: 0x2000          MOVS     R0, #0
  0x800'0868: 0xe000          B.N      ??UART_Transmit_IT_4   ; 0x800'086c
                ??UART_Transmit_IT_0:
  //     return HAL_BUSY;
  0x800'086a: 0x2002          MOVS     R0, #2
                ??UART_Transmit_IT_4:
  0x800'086c: 0x4770          BX       LR
                `.text_61`:
                UART_EndTransmit_IT:
  // static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
  // {
  0x800'086e: 0xb510          PUSH     {R4, LR}
  0x800'0870: 0x0004          MOVS     R4, R0
  //   __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
  0x800'0872: 0x6820          LDR      R0, [R4]
  0x800'0874: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'0876: 0xf031 0x0140   BICS.W   R1, R1, #64            ; 0x40
  0x800'087a: 0x6820          LDR      R0, [R4]
  0x800'087c: 0x60c1          STR      R1, [R0, #0xc]
  //   huart->gState = HAL_UART_STATE_READY;
  0x800'087e: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0880: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   HAL_UART_TxCpltCallback(huart);
  0x800'0884: 0x0020          MOVS     R0, R4
  0x800'0886: 0xf000 0xfb45   BL       HAL_UART_TxCpltCallback
                                                              ; 0x800'0f14
  //   return HAL_OK;
  0x800'088a: 0x2000          MOVS     R0, #0
  0x800'088c: 0xbd10          POP      {R4, PC}
                `.text_62`:
                UART_Receive_IT:
  // static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
  // {
  0x800'088e: 0xb57c          PUSH     {R2-R6, LR}
  0x800'0890: 0x0004          MOVS     R4, R0
  //   if (huart->RxState == HAL_UART_STATE_BUSY_RX)
  0x800'0892: 0xf894 0x0042   LDRB.W   R0, [R4, #0x42]
  0x800'0896: 0x2822          CMP      R0, #34                ; 0x22
  0x800'0898: 0xd172          BNE.N    ??UART_Receive_IT_0    ; 0x800'0980
  //     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  0x800'089a: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'089c: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'08a0: 0xd10d          BNE.N    ??UART_Receive_IT_1    ; 0x800'08be
  0x800'08a2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'08a4: 0x2800          CMP      R0, #0
  0x800'08a6: 0xd10a          BNE.N    ??UART_Receive_IT_1    ; 0x800'08be
  //       pdata8bits  = NULL;
  0x800'08a8: 0x2600          MOVS     R6, #0
  //       pdata16bits = (uint16_t *) huart->pRxBuffPtr;
  0x800'08aa: 0x6aa5          LDR      R5, [R4, #0x28]
  //       *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
  0x800'08ac: 0x6820          LDR      R0, [R4]
  0x800'08ae: 0x6840          LDR      R0, [R0, #0x4]
  0x800'08b0: 0x05c0          LSLS     R0, R0, #23
  0x800'08b2: 0x0dc0          LSRS     R0, R0, #23
  0x800'08b4: 0x8028          STRH     R0, [R5]
  //       huart->pRxBuffPtr += 2U;
  0x800'08b6: 0x6aa0          LDR      R0, [R4, #0x28]
  0x800'08b8: 0x1c80          ADDS     R0, R0, #2
  0x800'08ba: 0x62a0          STR      R0, [R4, #0x28]
  0x800'08bc: 0xe017          B.N      ??UART_Receive_IT_2    ; 0x800'08ee
                ??UART_Receive_IT_1:
  //       pdata8bits = (uint8_t *) huart->pRxBuffPtr;
  0x800'08be: 0x6aa6          LDR      R6, [R4, #0x28]
  //       pdata16bits  = NULL;
  0x800'08c0: 0x2500          MOVS     R5, #0
  //       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
  0x800'08c2: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'08c4: 0xf5b0 0x5f80   CMP.W    R0, #4096              ; 0x1000
  0x800'08c8: 0xd005          BEQ.N    ??UART_Receive_IT_3    ; 0x800'08d6
  0x800'08ca: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'08cc: 0x2800          CMP      R0, #0
  0x800'08ce: 0xd106          BNE.N    ??UART_Receive_IT_4    ; 0x800'08de
  0x800'08d0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'08d2: 0x2800          CMP      R0, #0
  0x800'08d4: 0xd103          BNE.N    ??UART_Receive_IT_4    ; 0x800'08de
                ??UART_Receive_IT_3:
  //         *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
  0x800'08d6: 0x6820          LDR      R0, [R4]
  0x800'08d8: 0x6840          LDR      R0, [R0, #0x4]
  0x800'08da: 0x7030          STRB     R0, [R6]
  0x800'08dc: 0xe004          B.N      ??UART_Receive_IT_5    ; 0x800'08e8
                ??UART_Receive_IT_4:
  //         *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
  0x800'08de: 0x6820          LDR      R0, [R4]
  0x800'08e0: 0x6840          LDR      R0, [R0, #0x4]
  0x800'08e2: 0xf010 0x007f   ANDS.W   R0, R0, #127           ; 0x7f
  0x800'08e6: 0x7030          STRB     R0, [R6]
                ??UART_Receive_IT_5:
  //       huart->pRxBuffPtr += 1U;
  0x800'08e8: 0x6aa0          LDR      R0, [R4, #0x28]
  0x800'08ea: 0x1c40          ADDS     R0, R0, #1
  0x800'08ec: 0x62a0          STR      R0, [R4, #0x28]
                ??UART_Receive_IT_2:
  //     if (--huart->RxXferCount == 0U)
  0x800'08ee: 0x8de0          LDRH     R0, [R4, #0x2e]
  0x800'08f0: 0x1e40          SUBS     R0, R0, #1
  0x800'08f2: 0x85e0          STRH     R0, [R4, #0x2e]
  0x800'08f4: 0xb280          UXTH     R0, R0
  0x800'08f6: 0x2800          CMP      R0, #0
  0x800'08f8: 0xd140          BNE.N    ??UART_Receive_IT_6    ; 0x800'097c
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
  0x800'08fa: 0x6820          LDR      R0, [R4]
  0x800'08fc: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'08fe: 0xf031 0x0120   BICS.W   R1, R1, #32            ; 0x20
  0x800'0902: 0x6820          LDR      R0, [R4]
  0x800'0904: 0x60c1          STR      R1, [R0, #0xc]
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
  0x800'0906: 0x6820          LDR      R0, [R4]
  0x800'0908: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'090a: 0xf431 0x7180   BICS.W   R1, R1, #256           ; 0x100
  0x800'090e: 0x6820          LDR      R0, [R4]
  0x800'0910: 0x60c1          STR      R1, [R0, #0xc]
  //       __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
  0x800'0912: 0x6820          LDR      R0, [R4]
  0x800'0914: 0x6940          LDR      R0, [R0, #0x14]
  0x800'0916: 0x0840          LSRS     R0, R0, #1
  0x800'0918: 0x0040          LSLS     R0, R0, #1
  0x800'091a: 0x6821          LDR      R1, [R4]
  0x800'091c: 0x6148          STR      R0, [R1, #0x14]
  //       huart->RxState = HAL_UART_STATE_READY;
  0x800'091e: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0920: 0xf884 0x0042   STRB.W   R0, [R4, #0x42]
  //       huart->RxEventType = HAL_UART_RXEVENT_TC;
  0x800'0924: 0x2000          MOVS     R0, #0
  0x800'0926: 0x6360          STR      R0, [R4, #0x34]
  //       if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  0x800'0928: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'092a: 0x2801          CMP      R0, #1
  0x800'092c: 0xd121          BNE.N    ??UART_Receive_IT_7    ; 0x800'0972
  //         huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  0x800'092e: 0x2000          MOVS     R0, #0
  0x800'0930: 0x6320          STR      R0, [R4, #0x30]
                ??UART_Receive_IT_8:
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'0932: 0x6820          LDR      R0, [R4]
  0x800'0934: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'0936: 0xe850 0x0f00   LDREX    R0, [R0]
  0x800'093a: 0xf030 0x0010   BICS.W   R0, R0, #16            ; 0x10
  0x800'093e: 0x0001          MOVS     R1, R0
  //         ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  0x800'0940: 0x6820          LDR      R0, [R4]
  0x800'0942: 0xf110 0x020c   ADDS.W   R2, R0, #12            ; 0xc
  0x800'0946: 0xe842 0x1000   STREX    R0, R1, [R2]
  0x800'094a: 0x2800          CMP      R0, #0
  0x800'094c: 0xd1f1          BNE.N    ??UART_Receive_IT_8    ; 0x800'0932
  //         if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
  0x800'094e: 0x6820          LDR      R0, [R4]
  0x800'0950: 0x6800          LDR      R0, [R0]
  0x800'0952: 0x06c0          LSLS     R0, R0, #27
  0x800'0954: 0xd508          BPL.N    ??UART_Receive_IT_9    ; 0x800'0968
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0956: 0x2000          MOVS     R0, #0
  0x800'0958: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'095a: 0x6820          LDR      R0, [R4]
  0x800'095c: 0x6800          LDR      R0, [R0]
  0x800'095e: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0960: 0x6820          LDR      R0, [R4]
  0x800'0962: 0x6840          LDR      R0, [R0, #0x4]
  0x800'0964: 0x9000          STR      R0, [SP]
  //           __HAL_UART_CLEAR_IDLEFLAG(huart);
  0x800'0966: 0x9800          LDR      R0, [SP]
                ??UART_Receive_IT_9:
  //         HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
  0x800'0968: 0x8da1          LDRH     R1, [R4, #0x2c]
  0x800'096a: 0x0020          MOVS     R0, R4
  0x800'096c: 0xf000 0xfad1   BL       HAL_UARTEx_RxEventCallback
                                                              ; 0x800'0f12
  0x800'0970: 0xe002          B.N      ??UART_Receive_IT_10   ; 0x800'0978
                ??UART_Receive_IT_7:
  //         HAL_UART_RxCpltCallback(huart);
  0x800'0972: 0x0020          MOVS     R0, R4
  0x800'0974: 0xf000 0xfacf   BL       HAL_UART_RxCpltCallback
                                                              ; 0x800'0f16
                ??UART_Receive_IT_10:
  //       return HAL_OK;
  0x800'0978: 0x2000          MOVS     R0, #0
  0x800'097a: 0xe002          B.N      ??UART_Receive_IT_11   ; 0x800'0982
                ??UART_Receive_IT_6:
  //     return HAL_OK;
  0x800'097c: 0x2000          MOVS     R0, #0
  0x800'097e: 0xe000          B.N      ??UART_Receive_IT_11   ; 0x800'0982
                ??UART_Receive_IT_0:
  //     return HAL_BUSY;
  0x800'0980: 0x2002          MOVS     R0, #2
                ??UART_Receive_IT_11:
  0x800'0982: 0xbd76          POP      {R1, R2, R4-R6, PC}
                `.text_63`:
                UART_SetConfig:
  // static void UART_SetConfig(UART_HandleTypeDef *huart)
  // {
  0x800'0984: 0xe92d 0x4ff8   PUSH.W   {R3-R11, LR}
  0x800'0988: 0xb084          SUB      SP, SP, #0x10
  0x800'098a: 0x0005          MOVS     R5, R0
  //   assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  0x800'098c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'098e: 0x49d5          LDR.N    R1, ??DataTable10_10   ; 0xa0'37a1
  0x800'0990: 0x4288          CMP      R0, R1
  0x800'0992: 0xd304          BCC.N    ??UART_SetConfig_0     ; 0x800'099e
  0x800'0994: 0xf640 0x6175   MOVW     R1, #3701              ; 0xe75
  0x800'0998: 0x48d1          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'099a: 0xf000 0xf9d4   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_0:
  //   assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  0x800'099e: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'09a0: 0x2800          CMP      R0, #0
  0x800'09a2: 0xd008          BEQ.N    ??UART_SetConfig_1     ; 0x800'09b6
  0x800'09a4: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'09a6: 0xf5b0 0x5f00   CMP.W    R0, #8192              ; 0x2000
  0x800'09aa: 0xd004          BEQ.N    ??UART_SetConfig_1     ; 0x800'09b6
  0x800'09ac: 0xf640 0x6176   MOVW     R1, #3702              ; 0xe76
  0x800'09b0: 0x48cb          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'09b2: 0xf000 0xf9c8   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_1:
  //   assert_param(IS_UART_PARITY(huart->Init.Parity));
  0x800'09b6: 0x6928          LDR      R0, [R5, #0x10]
  0x800'09b8: 0x2800          CMP      R0, #0
  0x800'09ba: 0xd00c          BEQ.N    ??UART_SetConfig_2     ; 0x800'09d6
  0x800'09bc: 0x6928          LDR      R0, [R5, #0x10]
  0x800'09be: 0xf5b0 0x6f80   CMP.W    R0, #1024              ; 0x400
  0x800'09c2: 0xd008          BEQ.N    ??UART_SetConfig_2     ; 0x800'09d6
  0x800'09c4: 0x6928          LDR      R0, [R5, #0x10]
  0x800'09c6: 0xf5b0 0x6fc0   CMP.W    R0, #1536              ; 0x600
  0x800'09ca: 0xd004          BEQ.N    ??UART_SetConfig_2     ; 0x800'09d6
  0x800'09cc: 0xf640 0x6177   MOVW     R1, #3703              ; 0xe77
  0x800'09d0: 0x48c3          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'09d2: 0xf000 0xf9b8   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_2:
  //   assert_param(IS_UART_MODE(huart->Init.Mode));
  0x800'09d6: 0x6969          LDR      R1, [R5, #0x14]
  0x800'09d8: 0xf64f 0x70f3   MOVW     R0, #65523             ; 0xfff3
  0x800'09dc: 0x4201          TST      R1, R0
  0x800'09de: 0xd102          BNE.N    ??UART_SetConfig_3     ; 0x800'09e6
  0x800'09e0: 0x6968          LDR      R0, [R5, #0x14]
  0x800'09e2: 0x2800          CMP      R0, #0
  0x800'09e4: 0xd104          BNE.N    ??UART_SetConfig_4     ; 0x800'09f0
                ??UART_SetConfig_3:
  0x800'09e6: 0xf640 0x6178   MOVW     R1, #3704              ; 0xe78
  0x800'09ea: 0x48bd          LDR.N    R0, ??DataTable10_6    ; ?_0
  0x800'09ec: 0xf000 0xf9ab   BL       assert_failed          ; 0x800'0d46
                ??UART_SetConfig_4:
  //   MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
  0x800'09f0: 0x6828          LDR      R0, [R5]
  0x800'09f2: 0x6901          LDR      R1, [R0, #0x10]
  0x800'09f4: 0xf431 0x5140   BICS.W   R1, R1, #12288         ; 0x3000
  0x800'09f8: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'09fa: 0x4301          ORRS     R1, R1, R0
  0x800'09fc: 0x6828          LDR      R0, [R5]
  0x800'09fe: 0x6101          STR      R1, [R0, #0x10]
  //   tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  0x800'0a00: 0x68a9          LDR      R1, [R5, #0x8]
  0x800'0a02: 0x6928          LDR      R0, [R5, #0x10]
  0x800'0a04: 0x4301          ORRS     R1, R1, R0
  0x800'0a06: 0x6968          LDR      R0, [R5, #0x14]
  0x800'0a08: 0x4301          ORRS     R1, R1, R0
  0x800'0a0a: 0x69e8          LDR      R0, [R5, #0x1c]
  0x800'0a0c: 0x4301          ORRS     R1, R1, R0
  0x800'0a0e: 0x9103          STR      R1, [SP, #0xc]
  //   MODIFY_REG(huart->Instance->CR1,
  //              (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
  //              tmpreg);
  0x800'0a10: 0x6828          LDR      R0, [R5]
  0x800'0a12: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'0a14: 0x48b4          LDR.N    R0, ??DataTable10_11   ; 0xffff'69f3
  0x800'0a16: 0x4001          ANDS     R1, R1, R0
  0x800'0a18: 0x9803          LDR      R0, [SP, #0xc]
  0x800'0a1a: 0x4301          ORRS     R1, R1, R0
  0x800'0a1c: 0x6828          LDR      R0, [R5]
  0x800'0a1e: 0x60c1          STR      R1, [R0, #0xc]
  //   MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
  0x800'0a20: 0x6828          LDR      R0, [R5]
  0x800'0a22: 0x6941          LDR      R1, [R0, #0x14]
  0x800'0a24: 0xf431 0x7140   BICS.W   R1, R1, #768           ; 0x300
  0x800'0a28: 0x69a8          LDR      R0, [R5, #0x18]
  0x800'0a2a: 0x4301          ORRS     R1, R1, R0
  0x800'0a2c: 0x6828          LDR      R0, [R5]
  0x800'0a2e: 0x6141          STR      R1, [R0, #0x14]
  //     if ((huart->Instance == USART1) || (huart->Instance == USART6))
  0x800'0a30: 0x6829          LDR      R1, [R5]
  0x800'0a32: 0x48a9          LDR.N    R0, ??DataTable10      ; 0x4001'1000
  0x800'0a34: 0x4281          CMP      R1, R0
  0x800'0a36: 0xd003          BEQ.N    ??UART_SetConfig_5     ; 0x800'0a40
  0x800'0a38: 0x6829          LDR      R1, [R5]
  0x800'0a3a: 0x48a8          LDR.N    R0, ??DataTable10_5    ; 0x4001'1400
  0x800'0a3c: 0x4281          CMP      R1, R0
  0x800'0a3e: 0xd103          BNE.N    ??UART_SetConfig_6     ; 0x800'0a48
                ??UART_SetConfig_5:
  //       pclk = HAL_RCC_GetPCLK2Freq();
  0x800'0a40: 0xf000 0xfa78   BL       HAL_RCC_GetPCLK2Freq   ; 0x800'0f34
  0x800'0a44: 0x0004          MOVS     R4, R0
  0x800'0a46: 0xe002          B.N      ??UART_SetConfig_7     ; 0x800'0a4e
                ??UART_SetConfig_6:
  //       pclk = HAL_RCC_GetPCLK1Freq();
  0x800'0a48: 0xf000 0xfa69   BL       HAL_RCC_GetPCLK1Freq   ; 0x800'0f1e
  0x800'0a4c: 0x0004          MOVS     R4, R0
                ??UART_SetConfig_7:
  //   if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  0x800'0a4e: 0x69e8          LDR      R0, [R5, #0x1c]
  0x800'0a50: 0xf5b0 0x4f00   CMP.W    R0, #32768             ; 0x8000
  0x800'0a54: 0xf040 0x809f   BNE.W    ??UART_SetConfig_8     ; 0x800'0b96
  //     huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
  0x800'0a58: 0xf07f 0x0a63   MVNS.W   R10, #99               ; 0x63
  0x800'0a5c: 0xf05f 0x0802   MOVS.W   R8, #2
  0x800'0a60: 0xf05f 0x0900   MOVS.W   R9, #0
  0x800'0a64: 0x2619          MOVS     R6, #25                ; 0x19
  0x800'0a66: 0x2700          MOVS     R7, #0
  0x800'0a68: 0x0022          MOVS     R2, R4
  0x800'0a6a: 0x2300          MOVS     R3, #0
  0x800'0a6c: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0a70: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0a74: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0a78: 0xe9cd 0x0100   STRD     R0, R1, [SP]
  0x800'0a7c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0a7e: 0x2100          MOVS     R1, #0
  0x800'0a80: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0a84: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0a88: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0a8c: 0xe9dd 0x0100   LDRD     R0, R1, [SP]
  0x800'0a90: 0xf000 0xfa7e   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0a94: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0a96: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0a9a: 0x9000          STR      R0, [SP]
  0x800'0a9c: 0x0022          MOVS     R2, R4
  0x800'0a9e: 0x2300          MOVS     R3, #0
  0x800'0aa0: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0aa4: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0aa8: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0aac: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0ab0: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0ab2: 0x2100          MOVS     R1, #0
  0x800'0ab4: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0ab8: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0abc: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0ac0: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0ac4: 0xf000 0xfa64   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0ac8: 0x4683          MOV      R11, R0
  0x800'0aca: 0x0022          MOVS     R2, R4
  0x800'0acc: 0x2300          MOVS     R3, #0
  0x800'0ace: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0ad2: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0ad6: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0ada: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0ade: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0ae0: 0x2100          MOVS     R1, #0
  0x800'0ae2: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0ae6: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0aea: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0aee: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0af2: 0xf000 0xfa4d   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0af6: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0af8: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0afc: 0xfb0a 0xb000   MLA      R0, R10, R0, R11
  0x800'0b00: 0x00c0          LSLS     R0, R0, #3
  0x800'0b02: 0x3032          ADDS     R0, R0, #50            ; 0x32
  0x800'0b04: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0b06: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0b0a: 0x0040          LSLS     R0, R0, #1
  0x800'0b0c: 0xf410 0x70f8   ANDS.W   R0, R0, #496           ; 0x1f0
  0x800'0b10: 0x9900          LDR      R1, [SP]
  0x800'0b12: 0xeb10 0x1001   ADDS.W   R0, R0, R1, LSL #4
  0x800'0b16: 0x9000          STR      R0, [SP]
  0x800'0b18: 0x0022          MOVS     R2, R4
  0x800'0b1a: 0x2300          MOVS     R3, #0
  0x800'0b1c: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0b20: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0b24: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0b28: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0b2c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0b2e: 0x2100          MOVS     R1, #0
  0x800'0b30: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0b34: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0b38: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0b3c: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0b40: 0xf000 0xfa26   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0b44: 0x4683          MOV      R11, R0
  0x800'0b46: 0x0022          MOVS     R2, R4
  0x800'0b48: 0x2300          MOVS     R3, #0
  0x800'0b4a: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0b4e: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0b52: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0b56: 0x0006          MOVS     R6, R0
  0x800'0b58: 0x000f          MOVS     R7, R1
  0x800'0b5a: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0b5c: 0x2100          MOVS     R1, #0
  0x800'0b5e: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0b62: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0b66: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0b6a: 0x0030          MOVS     R0, R6
  0x800'0b6c: 0x0039          MOVS     R1, R7
  0x800'0b6e: 0xf000 0xfa0f   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0b72: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0b74: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0b78: 0xfb0a 0xba00   MLA      R10, R10, R0, R11
  0x800'0b7c: 0xea5f 0x01ca   LSLS.W   R1, R10, #3
  0x800'0b80: 0x3132          ADDS     R1, R1, #50            ; 0x32
  0x800'0b82: 0x2064          MOVS     R0, #100               ; 0x64
  0x800'0b84: 0xfbb1 0xf1f0   UDIV     R1, R1, R0
  0x800'0b88: 0xf011 0x0107   ANDS.W   R1, R1, #7
  0x800'0b8c: 0x9800          LDR      R0, [SP]
  0x800'0b8e: 0x1809          ADDS     R1, R1, R0
  0x800'0b90: 0x6828          LDR      R0, [R5]
  0x800'0b92: 0x6081          STR      R1, [R0, #0x8]
  0x800'0b94: 0xe09c          B.N      ??UART_SetConfig_9     ; 0x800'0cd0
                ??UART_SetConfig_8:
  //     huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  0x800'0b96: 0xf05f 0x0804   MOVS.W   R8, #4
  0x800'0b9a: 0xf05f 0x0900   MOVS.W   R9, #0
  0x800'0b9e: 0xf07f 0x0a63   MVNS.W   R10, #99               ; 0x63
  0x800'0ba2: 0x2619          MOVS     R6, #25                ; 0x19
  0x800'0ba4: 0x2700          MOVS     R7, #0
  0x800'0ba6: 0x0022          MOVS     R2, R4
  0x800'0ba8: 0x2300          MOVS     R3, #0
  0x800'0baa: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0bae: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0bb2: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0bb6: 0xe9cd 0x0100   STRD     R0, R1, [SP]
  0x800'0bba: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0bbc: 0x2100          MOVS     R1, #0
  0x800'0bbe: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0bc2: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0bc6: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0bca: 0xe9dd 0x0100   LDRD     R0, R1, [SP]
  0x800'0bce: 0xf000 0xf9df   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0bd2: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0bd4: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0bd8: 0x9000          STR      R0, [SP]
  0x800'0bda: 0x0022          MOVS     R2, R4
  0x800'0bdc: 0x2300          MOVS     R3, #0
  0x800'0bde: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0be2: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0be6: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0bea: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0bee: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0bf0: 0x2100          MOVS     R1, #0
  0x800'0bf2: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0bf6: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0bfa: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0bfe: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0c02: 0xf000 0xf9c5   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0c06: 0x4683          MOV      R11, R0
  0x800'0c08: 0x0022          MOVS     R2, R4
  0x800'0c0a: 0x2300          MOVS     R3, #0
  0x800'0c0c: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0c10: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0c14: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0c18: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0c1c: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0c1e: 0x2100          MOVS     R1, #0
  0x800'0c20: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0c24: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0c28: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0c2c: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0c30: 0xf000 0xf9ae   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0c34: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0c36: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0c3a: 0xfb0a 0xb000   MLA      R0, R10, R0, R11
  0x800'0c3e: 0x0101          LSLS     R1, R0, #4
  0x800'0c40: 0x3132          ADDS     R1, R1, #50            ; 0x32
  0x800'0c42: 0x2064          MOVS     R0, #100               ; 0x64
  0x800'0c44: 0xfbb1 0xf0f0   UDIV     R0, R1, R0
  0x800'0c48: 0xf010 0x00f0   ANDS.W   R0, R0, #240           ; 0xf0
  0x800'0c4c: 0x9900          LDR      R1, [SP]
  0x800'0c4e: 0xeb10 0x1001   ADDS.W   R0, R0, R1, LSL #4
  0x800'0c52: 0x9000          STR      R0, [SP]
  0x800'0c54: 0x0022          MOVS     R2, R4
  0x800'0c56: 0x2300          MOVS     R3, #0
  0x800'0c58: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0c5c: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0c60: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0c64: 0xe9cd 0x0101   STRD     R0, R1, [SP, #0x4]
  0x800'0c68: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0c6a: 0x2100          MOVS     R1, #0
  0x800'0c6c: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0c70: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0c74: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0c78: 0xe9dd 0x0101   LDRD     R0, R1, [SP, #0x4]
  0x800'0c7c: 0xf000 0xf988   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0c80: 0x4683          MOV      R11, R0
  0x800'0c82: 0x0022          MOVS     R2, R4
  0x800'0c84: 0x2300          MOVS     R3, #0
  0x800'0c86: 0xfba6 0x0102   UMULL    R0, R1, R6, R2
  0x800'0c8a: 0xfb06 0x1103   MLA      R1, R6, R3, R1
  0x800'0c8e: 0xfb07 0x1102   MLA      R1, R7, R2, R1
  0x800'0c92: 0x0006          MOVS     R6, R0
  0x800'0c94: 0x000f          MOVS     R7, R1
  0x800'0c96: 0x6868          LDR      R0, [R5, #0x4]
  0x800'0c98: 0x2100          MOVS     R1, #0
  0x800'0c9a: 0xfba8 0x2300   UMULL    R2, R3, R8, R0
  0x800'0c9e: 0xfb08 0x3301   MLA      R3, R8, R1, R3
  0x800'0ca2: 0xfb09 0x3300   MLA      R3, R9, R0, R3
  0x800'0ca6: 0x0030          MOVS     R0, R6
  0x800'0ca8: 0x0039          MOVS     R1, R7
  0x800'0caa: 0xf000 0xf971   BL       __aeabi_uldivmod       ; 0x800'0f90
  0x800'0cae: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0cb0: 0xfbb0 0xf0f1   UDIV     R0, R0, R1
  0x800'0cb4: 0xfb0a 0xba00   MLA      R10, R10, R0, R11
  0x800'0cb8: 0xea5f 0x100a   LSLS.W   R0, R10, #4
  0x800'0cbc: 0x3032          ADDS     R0, R0, #50            ; 0x32
  0x800'0cbe: 0x2164          MOVS     R1, #100               ; 0x64
  0x800'0cc0: 0xfbb0 0xf1f1   UDIV     R1, R0, R1
  0x800'0cc4: 0xf011 0x010f   ANDS.W   R1, R1, #15            ; 0xf
  0x800'0cc8: 0x9800          LDR      R0, [SP]
  0x800'0cca: 0x1809          ADDS     R1, R1, R0
  0x800'0ccc: 0x6828          LDR      R0, [R5]
  0x800'0cce: 0x6081          STR      R1, [R0, #0x8]
                ??UART_SetConfig_9:
  // }
  0x800'0cd0: 0xb005          ADD      SP, SP, #0x14
  0x800'0cd2: 0xe8bd 0x8ff0   POP.W    {R4-R11, PC}
  0x800'0cd6: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable10:
  0x800'0cd8: 0x4001'1000     DC32     0x4001'1000            ; '...@'
                ??DataTable10_5:
  0x800'0cdc: 0x4001'1400     DC32     0x4001'1400            ; '...@'
                ??DataTable10_6:
  0x800'0ce0: 0x0800'2924     DC32     ?_0
                ??DataTable10_10:
  0x800'0ce4: 0x00a0'37a1     DC32     0xa0'37a1              ; '.7..'
                ??DataTable10_11:
  0x800'0ce8: 0xffff'69f3     DC32     -38413                 ; '.i..'
                $t:
                `.text8`:
                NMI_Handler:
  // void NMI_Handler(void)
  // {
  0x800'0cec: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0cee: 0x491a          LDR.N    R1, ??DataTable8       ; `NMI_Handler::__func__`
  0x800'0cf0: 0x481a          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0cf2: 0xf000 0xfa65   BL       printf                 ; 0x800'11c0
                ??NMI_Handler_0:
  //   while (1)
  0x800'0cf6: 0xe7fe          B.N      ??NMI_Handler_0        ; 0x800'0cf6
                `.text_12`:
                MemManage_Handler:
  // void MemManage_Handler(void)
  // {
  0x800'0cf8: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0cfa: 0x4919          LDR.N    R1, ??DataTable8_3     ; `MemManage_Handler::__func__`
  0x800'0cfc: 0x4817          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0cfe: 0xf000 0xfa5f   BL       printf                 ; 0x800'11c0
                ??MemManage_Handler_0:
  //   while (1)
  0x800'0d02: 0xe7fe          B.N      ??MemManage_Handler_0  ; 0x800'0d02
                `.text_13`:
                BusFault_Handler:
  // void BusFault_Handler(void)
  // {
  0x800'0d04: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0d06: 0x4917          LDR.N    R1, ??DataTable8_4     ; `BusFault_Handler::__func__`
  0x800'0d08: 0x4814          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d0a: 0xf000 0xfa59   BL       printf                 ; 0x800'11c0
                ??BusFault_Handler_0:
  //   while (1)
  0x800'0d0e: 0xe7fe          B.N      ??BusFault_Handler_0   ; 0x800'0d0e
                `.text_14`:
                UsageFault_Handler:
  // void UsageFault_Handler(void)
  // {
  0x800'0d10: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0d12: 0x4915          LDR.N    R1, ??DataTable8_5     ; `UsageFault_Handler::__func__`
  0x800'0d14: 0x4811          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d16: 0xf000 0xfa53   BL       printf                 ; 0x800'11c0
                ??UsageFault_Handler_0:
  //   while (1)
  0x800'0d1a: 0xe7fe          B.N      ??UsageFault_Handler_0 ; 0x800'0d1a
                `.text_15`:
                SVC_Handler:
  // }
  0x800'0d1c: 0x4770          BX       LR
                `.text_16`:
                DebugMon_Handler:
  // }
  0x800'0d1e: 0x4770          BX       LR
                `.text_17`:
                TIM2_IRQHandler:
  // void TIM2_IRQHandler(void)
  // {
  0x800'0d20: 0xb580          PUSH     {R7, LR}
  //   HAL_IncTick();
  0x800'0d22: 0xf000 0xfa61   BL       HAL_IncTick            ; 0x800'11e8
  //   HAL_TIM_IRQHandler(&htim2);
  0x800'0d26: 0x4811          LDR.N    R0, ??DataTable8_6     ; htim2
  0x800'0d28: 0xf000 0xfbfa   BL       HAL_TIM_IRQHandler     ; 0x800'1520
  // }
  0x800'0d2c: 0xbd01          POP      {R0, PC}
                `.text_18`:
                USART1_IRQHandler:
  // void USART1_IRQHandler(void)
  // {
  0x800'0d2e: 0xb580          PUSH     {R7, LR}
  //   HAL_UART_IRQHandler(&huart1);
  0x800'0d30: 0x480f          LDR.N    R0, ??DataTable8_7     ; huart1
  0x800'0d32: 0xf7ff 0xfb51   BL       HAL_UART_IRQHandler    ; 0x800'03d8
  // }
  0x800'0d36: 0xbd01          POP      {R0, PC}
                `.text_19`:
                Error_Handler:
  // void Error_Handler(void)
  // {
  0x800'0d38: 0xb580          PUSH     {R7, LR}
  //   printf("this is %s.\r\n", __func__);
  0x800'0d3a: 0x490e          LDR.N    R1, ??DataTable8_8     ; `Error_Handler::__func__`
  0x800'0d3c: 0x4807          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d3e: 0xf000 0xfa3f   BL       printf                 ; 0x800'11c0
  //   __disable_irq();
  0x800'0d42: 0xb672          CPSID    i
                ??Error_Handler_0:
  //   while (1) {}
  0x800'0d44: 0xe7fe          B.N      ??Error_Handler_0      ; 0x800'0d44
                `.text_20`:
                assert_failed:
  // void assert_failed(uint8_t *file, uint32_t line)
  // {
  0x800'0d46: 0xb538          PUSH     {R3-R5, LR}
  0x800'0d48: 0x0005          MOVS     R5, R0
  0x800'0d4a: 0x000c          MOVS     R4, R1
  //   printf("this is %s.\r\n", __func__);
  0x800'0d4c: 0x490a          LDR.N    R1, ??DataTable8_9     ; `assert_failed::__func__`
  0x800'0d4e: 0x4803          LDR.N    R0, ??DataTable8_1     ; ?_0
  0x800'0d50: 0xf000 0xfa36   BL       printf                 ; 0x800'11c0
  //   __disable_irq();
  0x800'0d54: 0xb672          CPSID    i
                ??assert_failed_0:
  //   while (1) {}
  0x800'0d56: 0xe7fe          B.N      ??assert_failed_0      ; 0x800'0d56
                `$d.32`:
                ??DataTable8:
  0x800'0d58: 0x0800'2c04     DC32     `NMI_Handler::__func__`
                ??DataTable8_1:
  0x800'0d5c: 0x0800'2ba4     DC32     ?_0
                ??DataTable8_3:
  0x800'0d60: 0x0800'2b58     DC32     `MemManage_Handler::__func__`
                ??DataTable8_4:
  0x800'0d64: 0x0800'2b6c     DC32     `BusFault_Handler::__func__`
                ??DataTable8_5:
  0x800'0d68: 0x0800'2b80     DC32     `UsageFault_Handler::__func__`
                ??DataTable8_6:
  0x800'0d6c: 0x2000'01b0     DC32     htim2
                ??DataTable8_7:
  0x800'0d70: 0x2000'0168     DC32     huart1
                ??DataTable8_8:
  0x800'0d74: 0x0800'2bb4     DC32     `Error_Handler::__func__`
                ??DataTable8_9:
  0x800'0d78: 0x0800'2bc4     DC32     `assert_failed::__func__`
                $t:
                `.text9`:
                MX_USART1_UART_Init:
  // void MX_USART1_UART_Init(void)
  // {
  0x800'0d7c: 0xb580          PUSH     {R7, LR}
  //   huart1.Instance = USART1;
  0x800'0d7e: 0x482b          LDR.N    R0, ??DataTable2       ; huart1
  0x800'0d80: 0x492b          LDR.N    R1, ??DataTable2_1     ; 0x4001'1000
  0x800'0d82: 0x6001          STR      R1, [R0]
  //   huart1.Init.BaudRate = 115200;
  0x800'0d84: 0xf45f 0x31e1   MOVS.W   R1, #115200            ; 0x1'c200
  0x800'0d88: 0x6041          STR      R1, [R0, #0x4]
  //   huart1.Init.WordLength = UART_WORDLENGTH_8B;
  0x800'0d8a: 0x2100          MOVS     R1, #0
  0x800'0d8c: 0x6081          STR      R1, [R0, #0x8]
  //   huart1.Init.StopBits = UART_STOPBITS_1;
  0x800'0d8e: 0x2100          MOVS     R1, #0
  0x800'0d90: 0x60c1          STR      R1, [R0, #0xc]
  //   huart1.Init.Parity = UART_PARITY_NONE;
  0x800'0d92: 0x2100          MOVS     R1, #0
  0x800'0d94: 0x6101          STR      R1, [R0, #0x10]
  //   huart1.Init.Mode = UART_MODE_TX_RX;
  0x800'0d96: 0x210c          MOVS     R1, #12                ; 0xc
  0x800'0d98: 0x6141          STR      R1, [R0, #0x14]
  //   huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  0x800'0d9a: 0x2100          MOVS     R1, #0
  0x800'0d9c: 0x6181          STR      R1, [R0, #0x18]
  //   huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  0x800'0d9e: 0x2100          MOVS     R1, #0
  0x800'0da0: 0x61c1          STR      R1, [R0, #0x1c]
  //   if (HAL_UART_Init(&huart1) != HAL_OK)
  0x800'0da2: 0xf7ff 0xf9f1   BL       HAL_UART_Init          ; 0x800'0188
  0x800'0da6: 0x2800          CMP      R0, #0
  0x800'0da8: 0xd001          BEQ.N    ??MX_USART1_UART_Init_0
                                                              ; 0x800'0dae
  //     Error_Handler();
  0x800'0daa: 0xf7ff 0xffc5   BL       Error_Handler          ; 0x800'0d38
                ??MX_USART1_UART_Init_0:
  // }
  0x800'0dae: 0xbd01          POP      {R0, PC}
                `.text_4`:
                HAL_UART_MspInit:
  // void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
  // {
  0x800'0db0: 0xb510          PUSH     {R4, LR}
  0x800'0db2: 0xb086          SUB      SP, SP, #0x18
  0x800'0db4: 0x0004          MOVS     R4, R0
  0x800'0db6: 0x2114          MOVS     R1, #20                ; 0x14
  0x800'0db8: 0x2200          MOVS     R2, #0
  0x800'0dba: 0xa801          ADD      R0, SP, #0x4
  0x800'0dbc: 0xf000 0xfcce   BL       __aeabi_memset         ; 0x800'175c
  //   if(uartHandle->Instance==USART1)
  0x800'0dc0: 0x6821          LDR      R1, [R4]
  0x800'0dc2: 0x481b          LDR.N    R0, ??DataTable2_1     ; 0x4001'1000
  0x800'0dc4: 0x4281          CMP      R1, R0
  0x800'0dc6: 0xd12e          BNE.N    ??HAL_UART_MspInit_0   ; 0x800'0e26
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dc8: 0x2000          MOVS     R0, #0
  0x800'0dca: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dcc: 0x4919          LDR.N    R1, ??DataTable2_2     ; 0x4002'3844
  0x800'0dce: 0x6808          LDR      R0, [R1]
  0x800'0dd0: 0xf050 0x0010   ORRS.W   R0, R0, #16            ; 0x10
  0x800'0dd4: 0x6008          STR      R0, [R1]
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dd6: 0x6808          LDR      R0, [R1]
  0x800'0dd8: 0xf010 0x0010   ANDS.W   R0, R0, #16            ; 0x10
  0x800'0ddc: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_USART1_CLK_ENABLE();
  0x800'0dde: 0x9800          LDR      R0, [SP]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0de0: 0x2000          MOVS     R0, #0
  0x800'0de2: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0de4: 0x4914          LDR.N    R1, ??DataTable2_3     ; 0x4002'3830
  0x800'0de6: 0x6808          LDR      R0, [R1]
  0x800'0de8: 0xf050 0x0001   ORRS.W   R0, R0, #1
  0x800'0dec: 0x6008          STR      R0, [R1]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0dee: 0x6808          LDR      R0, [R1]
  0x800'0df0: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'0df4: 0x9000          STR      R0, [SP]
  //     __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'0df6: 0x9800          LDR      R0, [SP]
  //     GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
  0x800'0df8: 0xf44f 0x60c0   MOV.W    R0, #1536              ; 0x600
  0x800'0dfc: 0x9001          STR      R0, [SP, #0x4]
  //     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  0x800'0dfe: 0x2002          MOVS     R0, #2
  0x800'0e00: 0x9002          STR      R0, [SP, #0x8]
  //     GPIO_InitStruct.Pull = GPIO_NOPULL;
  0x800'0e02: 0x2000          MOVS     R0, #0
  0x800'0e04: 0x9003          STR      R0, [SP, #0xc]
  //     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  0x800'0e06: 0x2003          MOVS     R0, #3
  0x800'0e08: 0x9004          STR      R0, [SP, #0x10]
  //     GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
  0x800'0e0a: 0x2007          MOVS     R0, #7
  0x800'0e0c: 0x9005          STR      R0, [SP, #0x14]
  //     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  0x800'0e0e: 0xa901          ADD      R1, SP, #0x4
  0x800'0e10: 0x480a          LDR.N    R0, ??DataTable2_4     ; 0x4002'0000
  0x800'0e12: 0xf000 0xfceb   BL       HAL_GPIO_Init          ; 0x800'17ec
  //     HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
  0x800'0e16: 0x2200          MOVS     R2, #0
  0x800'0e18: 0x2100          MOVS     R1, #0
  0x800'0e1a: 0x2025          MOVS     R0, #37                ; 0x25
  0x800'0e1c: 0xf000 0xff75   BL       HAL_NVIC_SetPriority   ; 0x800'1d0a
  //     HAL_NVIC_EnableIRQ(USART1_IRQn);
  0x800'0e20: 0x2025          MOVS     R0, #37                ; 0x25
  0x800'0e22: 0xf000 0xff95   BL       HAL_NVIC_EnableIRQ     ; 0x800'1d50
                ??HAL_UART_MspInit_0:
  // }
  0x800'0e26: 0xb006          ADD      SP, SP, #0x18
  0x800'0e28: 0xbd10          POP      {R4, PC}
  0x800'0e2a: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable2:
  0x800'0e2c: 0x2000'0168     DC32     huart1
                ??DataTable2_1:
  0x800'0e30: 0x4001'1000     DC32     0x4001'1000            ; '...@'
                ??DataTable2_2:
  0x800'0e34: 0x4002'3844     DC32     0x4002'3844            ; 'D8.@'
                ??DataTable2_3:
  0x800'0e38: 0x4002'3830     DC32     0x4002'3830            ; '08.@'
                ??DataTable2_4:
  0x800'0e3c: 0x4002'0000     DC32     0x4002'0000            ; '...@'
                $t:
                `.text21`:
                HAL_GetTick:
  //   return uwTick;
  0x800'0e40: 0x4801          LDR.N    R0, ??HAL_GetTick_0    ; uwTick
  0x800'0e42: 0x6800          LDR      R0, [R0]
  0x800'0e44: 0x4770          BX       LR
  0x800'0e46: 0xbf00          NOP
                `$d.32`:
                ??HAL_GetTick_0:
  0x800'0e48: 0x2000'0228     DC32     uwTick
                $t:
                `.text_8`:
                HAL_DMA_Abort:
  // HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
  // {
  0x800'0e4c: 0xb570          PUSH     {R4-R6, LR}
  0x800'0e4e: 0x0004          MOVS     R4, R0
  //   DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  0x800'0e50: 0x6da5          LDR      R5, [R4, #0x58]
  //   uint32_t tickstart = HAL_GetTick();
  0x800'0e52: 0xf7ff 0xfff5   BL       HAL_GetTick            ; 0x800'0e40
  0x800'0e56: 0x0006          MOVS     R6, R0
  //   if(hdma->State != HAL_DMA_STATE_BUSY)
  0x800'0e58: 0xf894 0x0035   LDRB.W   R0, [R4, #0x35]
  0x800'0e5c: 0x2802          CMP      R0, #2
  0x800'0e5e: 0xd006          BEQ.N    ??HAL_DMA_Abort_0      ; 0x800'0e6e
  //     hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  0x800'0e60: 0x2080          MOVS     R0, #128               ; 0x80
  0x800'0e62: 0x6560          STR      R0, [R4, #0x54]
  //     __HAL_UNLOCK(hdma);
  0x800'0e64: 0x2000          MOVS     R0, #0
  0x800'0e66: 0xf884 0x0034   STRB.W   R0, [R4, #0x34]
  //     return HAL_ERROR;
  0x800'0e6a: 0x2001          MOVS     R0, #1
  0x800'0e6c: 0xe03b          B.N      ??HAL_DMA_Abort_1      ; 0x800'0ee6
                ??HAL_DMA_Abort_0:
  //     hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
  0x800'0e6e: 0x6820          LDR      R0, [R4]
  0x800'0e70: 0x6801          LDR      R1, [R0]
  0x800'0e72: 0xf031 0x0116   BICS.W   R1, R1, #22            ; 0x16
  0x800'0e76: 0x6820          LDR      R0, [R4]
  0x800'0e78: 0x6001          STR      R1, [R0]
  //     hdma->Instance->FCR &= ~(DMA_IT_FE);
  0x800'0e7a: 0x6820          LDR      R0, [R4]
  0x800'0e7c: 0x6941          LDR      R1, [R0, #0x14]
  0x800'0e7e: 0xf031 0x0180   BICS.W   R1, R1, #128           ; 0x80
  0x800'0e82: 0x6820          LDR      R0, [R4]
  0x800'0e84: 0x6141          STR      R1, [R0, #0x14]
  //     if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
  0x800'0e86: 0x6c20          LDR      R0, [R4, #0x40]
  0x800'0e88: 0x2800          CMP      R0, #0
  0x800'0e8a: 0xd102          BNE.N    ??HAL_DMA_Abort_2      ; 0x800'0e92
  0x800'0e8c: 0x6ca0          LDR      R0, [R4, #0x48]
  0x800'0e8e: 0x2800          CMP      R0, #0
  0x800'0e90: 0xd005          BEQ.N    ??HAL_DMA_Abort_3      ; 0x800'0e9e
                ??HAL_DMA_Abort_2:
  //       hdma->Instance->CR  &= ~(DMA_IT_HT);
  0x800'0e92: 0x6820          LDR      R0, [R4]
  0x800'0e94: 0x6801          LDR      R1, [R0]
  0x800'0e96: 0xf031 0x0108   BICS.W   R1, R1, #8
  0x800'0e9a: 0x6820          LDR      R0, [R4]
  0x800'0e9c: 0x6001          STR      R1, [R0]
                ??HAL_DMA_Abort_3:
  //     __HAL_DMA_DISABLE(hdma);
  0x800'0e9e: 0x6820          LDR      R0, [R4]
  0x800'0ea0: 0x6801          LDR      R1, [R0]
  0x800'0ea2: 0x0849          LSRS     R1, R1, #1
  0x800'0ea4: 0x0049          LSLS     R1, R1, #1
  0x800'0ea6: 0x6820          LDR      R0, [R4]
  0x800'0ea8: 0x6001          STR      R1, [R0]
                ??HAL_DMA_Abort_4:
  //     while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  0x800'0eaa: 0x6820          LDR      R0, [R4]
  0x800'0eac: 0x6800          LDR      R0, [R0]
  0x800'0eae: 0x07c0          LSLS     R0, R0, #31
  0x800'0eb0: 0xd50e          BPL.N    ??HAL_DMA_Abort_5      ; 0x800'0ed0
  //       if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
  0x800'0eb2: 0xf7ff 0xffc5   BL       HAL_GetTick            ; 0x800'0e40
  0x800'0eb6: 0x1b80          SUBS     R0, R0, R6
  0x800'0eb8: 0x2806          CMP      R0, #6
  0x800'0eba: 0xd3f6          BCC.N    ??HAL_DMA_Abort_4      ; 0x800'0eaa
  //         hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
  0x800'0ebc: 0x2020          MOVS     R0, #32                ; 0x20
  0x800'0ebe: 0x6560          STR      R0, [R4, #0x54]
  //         hdma->State = HAL_DMA_STATE_TIMEOUT;
  0x800'0ec0: 0x2003          MOVS     R0, #3
  0x800'0ec2: 0xf884 0x0035   STRB.W   R0, [R4, #0x35]
  //         __HAL_UNLOCK(hdma);
  0x800'0ec6: 0x2000          MOVS     R0, #0
  0x800'0ec8: 0xf884 0x0034   STRB.W   R0, [R4, #0x34]
  //         return HAL_TIMEOUT;
  0x800'0ecc: 0x2003          MOVS     R0, #3
  0x800'0ece: 0xe00a          B.N      ??HAL_DMA_Abort_1      ; 0x800'0ee6
                ??HAL_DMA_Abort_5:
  //     regs->IFCR = 0x3FU << hdma->StreamIndex;
  0x800'0ed0: 0x213f          MOVS     R1, #63                ; 0x3f
  0x800'0ed2: 0x6de0          LDR      R0, [R4, #0x5c]
  0x800'0ed4: 0x4081          LSLS     R1, R1, R0
  0x800'0ed6: 0x60a9          STR      R1, [R5, #0x8]
  //     hdma->State = HAL_DMA_STATE_READY;
  0x800'0ed8: 0x2001          MOVS     R0, #1
  0x800'0eda: 0xf884 0x0035   STRB.W   R0, [R4, #0x35]
  //     __HAL_UNLOCK(hdma);
  0x800'0ede: 0x2000          MOVS     R0, #0
  0x800'0ee0: 0xf884 0x0034   STRB.W   R0, [R4, #0x34]
  //   return HAL_OK;
  0x800'0ee4: 0x2000          MOVS     R0, #0
                ??HAL_DMA_Abort_1:
  0x800'0ee6: 0xbd70          POP      {R4-R6, PC}
                `.text_9`:
                HAL_DMA_Abort_IT:
  // HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
  // {
  0x800'0ee8: 0x0001          MOVS     R1, R0
  //   if(hdma->State != HAL_DMA_STATE_BUSY)
  0x800'0eea: 0xf891 0x0035   LDRB.W   R0, [R1, #0x35]
  0x800'0eee: 0x2802          CMP      R0, #2
  0x800'0ef0: 0xd003          BEQ.N    ??HAL_DMA_Abort_IT_0   ; 0x800'0efa
  //     hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  0x800'0ef2: 0x2080          MOVS     R0, #128               ; 0x80
  0x800'0ef4: 0x6548          STR      R0, [R1, #0x54]
  //     return HAL_ERROR;
  0x800'0ef6: 0x2001          MOVS     R0, #1
  0x800'0ef8: 0xe009          B.N      ??HAL_DMA_Abort_IT_1   ; 0x800'0f0e
                ??HAL_DMA_Abort_IT_0:
  //     hdma->State = HAL_DMA_STATE_ABORT;
  0x800'0efa: 0x2005          MOVS     R0, #5
  0x800'0efc: 0xf881 0x0035   STRB.W   R0, [R1, #0x35]
  //     __HAL_DMA_DISABLE(hdma);
  0x800'0f00: 0x6808          LDR      R0, [R1]
  0x800'0f02: 0x6802          LDR      R2, [R0]
  0x800'0f04: 0x0852          LSRS     R2, R2, #1
  0x800'0f06: 0x0052          LSLS     R2, R2, #1
  0x800'0f08: 0x6808          LDR      R0, [R1]
  0x800'0f0a: 0x6002          STR      R2, [R0]
  //   return HAL_OK;
  0x800'0f0c: 0x2000          MOVS     R0, #0
                ??HAL_DMA_Abort_IT_1:
  0x800'0f0e: 0x4770          BX       LR
                `.text22`:
                HAL_UART_ErrorCallback:
  // }
  0x800'0f10: 0x4770          BX       LR
                `.text30`:
                HAL_UARTEx_RxEventCallback:
  // }
  0x800'0f12: 0x4770          BX       LR
                `.text14`:
                HAL_UART_TxCpltCallback:
  // }
  0x800'0f14: 0x4770          BX       LR
                `.text18`:
                HAL_UART_RxCpltCallback:
  // }
  0x800'0f16: 0x4770          BX       LR
                `.text_9`:
                HAL_RCC_GetHCLKFreq:
  //   return SystemCoreClock;
  0x800'0f18: 0x481b          LDR.N    R0, ??DataTable8_5     ; SystemCoreClock
  0x800'0f1a: 0x6800          LDR      R0, [R0]
  0x800'0f1c: 0x4770          BX       LR
                `.text_10`:
                HAL_RCC_GetPCLK1Freq:
  // uint32_t HAL_RCC_GetPCLK1Freq(void)
  // {
  0x800'0f1e: 0xb580          PUSH     {R7, LR}
  //   return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
  0x800'0f20: 0xf7ff 0xfffa   BL       HAL_RCC_GetHCLKFreq    ; 0x800'0f18
  0x800'0f24: 0x4919          LDR.N    R1, ??DataTable8_11    ; APBPrescTable
  0x800'0f26: 0x4a17          LDR.N    R2, ??DataTable8_2     ; 0x4002'3808
  0x800'0f28: 0x6812          LDR      R2, [R2]
  0x800'0f2a: 0xf3c2 0x2282   UBFX     R2, R2, #10, #3
  0x800'0f2e: 0x5c89          LDRB     R1, [R1, R2]
  0x800'0f30: 0x40c8          LSRS     R0, R0, R1
  0x800'0f32: 0xbd02          POP      {R1, PC}
                `.text_11`:
                HAL_RCC_GetPCLK2Freq:
  // uint32_t HAL_RCC_GetPCLK2Freq(void)
  // {
  0x800'0f34: 0xb580          PUSH     {R7, LR}
  //   return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
  0x800'0f36: 0xf7ff 0xffef   BL       HAL_RCC_GetHCLKFreq    ; 0x800'0f18
  0x800'0f3a: 0x4914          LDR.N    R1, ??DataTable8_11    ; APBPrescTable
  0x800'0f3c: 0x4a11          LDR.N    R2, ??DataTable8_2     ; 0x4002'3808
  0x800'0f3e: 0x6812          LDR      R2, [R2]
  0x800'0f40: 0xf3c2 0x3242   UBFX     R2, R2, #13, #3
  0x800'0f44: 0x5c89          LDRB     R1, [R1, R2]
  0x800'0f46: 0x40c8          LSRS     R0, R0, R1
  0x800'0f48: 0xbd02          POP      {R1, PC}
                `.text_12`:
                HAL_RCC_GetClockConfig:
  //   RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  0x800'0f4a: 0x220f          MOVS     R2, #15                ; 0xf
  0x800'0f4c: 0x6002          STR      R2, [R0]
  //   RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
  0x800'0f4e: 0x4a0d          LDR.N    R2, ??DataTable8_2     ; 0x4002'3808
  0x800'0f50: 0x6813          LDR      R3, [R2]
  0x800'0f52: 0xf013 0x0303   ANDS.W   R3, R3, #3
  0x800'0f56: 0x6043          STR      R3, [R0, #0x4]
  //   RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
  0x800'0f58: 0x6813          LDR      R3, [R2]
  0x800'0f5a: 0xf013 0x03f0   ANDS.W   R3, R3, #240           ; 0xf0
  0x800'0f5e: 0x6083          STR      R3, [R0, #0x8]
  //   RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
  0x800'0f60: 0x6813          LDR      R3, [R2]
  0x800'0f62: 0xf413 0x53e0   ANDS.W   R3, R3, #7168          ; 0x1c00
  0x800'0f66: 0x60c3          STR      R3, [R0, #0xc]
  //   RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
  0x800'0f68: 0x6812          LDR      R2, [R2]
  0x800'0f6a: 0x08d2          LSRS     R2, R2, #3
  0x800'0f6c: 0xf412 0x52e0   ANDS.W   R2, R2, #7168          ; 0x1c00
  0x800'0f70: 0x6102          STR      R2, [R0, #0x10]
  //   *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
  0x800'0f72: 0x4a03          LDR.N    R2, ??DataTable8_1     ; 0x4002'3c00
  0x800'0f74: 0x6812          LDR      R2, [R2]
  0x800'0f76: 0xf012 0x0207   ANDS.W   R2, R2, #7
  0x800'0f7a: 0x600a          STR      R2, [R1]
  // }
  0x800'0f7c: 0x4770          BX       LR
  0x800'0f7e: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable8_1:
  0x800'0f80: 0x4002'3c00     DC32     0x4002'3c00            ; '.<.@'
                ??DataTable8_2:
  0x800'0f84: 0x4002'3808     DC32     0x4002'3808            ; '.8.@'
                ??DataTable8_5:
  0x800'0f88: 0x2000'0004     DC32     SystemCoreClock
                ??DataTable8_11:
  0x800'0f8c: 0x0800'2c10     DC32     APBPrescTable
                $t:
                `.text_2`:
                __aeabi_uldivmod:
  0x800'0f90: 0xbbbb          CBNZ     R3, @8001002
  0x800'0f92: 0xb1e1          CBZ      R1, @8000fce
  0x800'0f94: 0xf5b2 0x3f80   CMP.W    R2, #65536             ; 0x1'0000
  0x800'0f98: 0xf080 0x807e   BCS.W    @8001098
  0x800'0f9c: 0x2a02          CMP      R2, #2
  0x800'0f9e: 0xd91e          BLS.N    @8000fde
  0x800'0fa0: 0x468c          MOV      R12, R1
  0x800'0fa2: 0xfbb1 0xf1f2   UDIV     R1, R1, R2
  0x800'0fa6: 0xfb02 0xc311   MLS      R3, R2, R1, R12
  0x800'0faa: 0x041b          LSLS     R3, R3, #16
  0x800'0fac: 0xea43 0x4310   ORR.W    R3, R3, R0, LSR #16
  0x800'0fb0: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'0fb4: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'0fb8: 0xb280          UXTH     R0, R0
  0x800'0fba: 0xea40 0x4303   ORR.W    R3, R0, R3, LSL #16
  0x800'0fbe: 0xfbb3 0xf0f2   UDIV     R0, R3, R2
  0x800'0fc2: 0xfb02 0x3210   MLS      R2, R2, R0, R3
  0x800'0fc6: 0xea40 0x400c   ORR.W    R0, R0, R12, LSL #16
  0x800'0fca: 0x2300          MOVS     R3, #0
  0x800'0fcc: 0x4770          BX       LR
                @8000fce:
  0x800'0fce: 0x2a02          CMP      R2, #2
  0x800'0fd0: 0xd905          BLS.N    @8000fde
  0x800'0fd2: 0x4684          MOV      R12, R0
  0x800'0fd4: 0xfbb0 0xf0f2   UDIV     R0, R0, R2
  0x800'0fd8: 0xfb02 0xc210   MLS      R2, R2, R0, R12
  0x800'0fdc: 0x4770          BX       LR
                @8000fde:
  0x800'0fde: 0xb14a          CBZ      R2, @8000ff4
  0x800'0fe0: 0xd105          BNE.N    @8000fee
  0x800'0fe2: 0xf000 0x0201   AND.W    R2, R0, #1
  0x800'0fe6: 0x0849          LSRS     R1, R1, #1
  0x800'0fe8: 0xea5f 0x0030   RRXS.W   R0, R0
  0x800'0fec: 0x4770          BX       LR
                @8000fee:
  0x800'0fee: 0x2200          MOVS     R2, #0
  0x800'0ff0: 0x2300          MOVS     R3, #0
  0x800'0ff2: 0x4770          BX       LR
                @8000ff4:
  0x800'0ff4: 0xf000 0xbec8   B.W      __aeabi_ldiv0          ; 0x800'1d88
                @8000ff8:
  0x800'0ff8: 0x000b          MOVS     R3, R1
  0x800'0ffa: 0x0002          MOVS     R2, R0
  0x800'0ffc: 0x2100          MOVS     R1, #0
  0x800'0ffe: 0x2000          MOVS     R0, #0
  0x800'1000: 0x4770          BX       LR
                @8001002:
  0x800'1002: 0x4290          CMP      R0, R2
  0x800'1004: 0xeb71 0x0c03   SBCS.W   R12, R1, R3
  0x800'1008: 0xd3f6          BCC.N    @8000ff8
  0x800'100a: 0xf5b3 0x3f80   CMP.W    R3, #65536             ; 0x1'0000
  0x800'100e: 0xd22f          BCS.N    @8001070
  0x800'1010: 0xb5f0          PUSH     {R4-R7, LR}
  0x800'1012: 0xfab3 0xf783   CLZ      R7, R3
  0x800'1016: 0xfab1 0xf481   CLZ      R4, R1
  0x800'101a: 0xf1a7 0x0e0f   SUB.W    LR, R7, #15            ; 0xf
  0x800'101e: 0x1b3d          SUBS     R5, R7, R4
  0x800'1020: 0x4053          EORS     R3, R3, R2
  0x800'1022: 0xf1ce 0x0620   RSB.W    R6, LR, #32            ; 0x20
  0x800'1026: 0xfa02 0xf20e   LSL.W    R2, R2, LR
  0x800'102a: 0x41f3          RORS     R3, R3, R6
  0x800'102c: 0x4053          EORS     R3, R3, R2
  0x800'102e: 0xf1b5 0x070f   SUBS.W   R7, R5, #15            ; 0xf
  0x800'1032: 0xd846          BHI.N    @80010c2
                @8001034:
  0x800'1034: 0x3c0f          SUBS     R4, R4, #15            ; 0xf
  0x800'1036: 0x442c          ADD      R4, R4, R5
  0x800'1038: 0x4041          EORS     R1, R1, R0
  0x800'103a: 0xf1c4 0x0620   RSB.W    R6, R4, #32            ; 0x20
  0x800'103e: 0x40a0          LSLS     R0, R0, R4
  0x800'1040: 0x41f1          RORS     R1, R1, R6
  0x800'1042: 0x4041          EORS     R1, R1, R0
  0x800'1044: 0xfbb1 0xf6f3   UDIV     R6, R1, R3
  0x800'1048: 0xfb03 0x1116   MLS      R1, R3, R6, R1
  0x800'104c: 0xfba2 0x4506   UMULL    R4, R5, R2, R6
  0x800'1050: 0x1b00          SUBS     R0, R0, R4
  0x800'1052: 0x41a9          SBCS     R1, R1, R5
  0x800'1054: 0xd202          BCS.N    @800105c
  0x800'1056: 0x1e76          SUBS     R6, R6, #1
  0x800'1058: 0x1880          ADDS     R0, R0, R2
  0x800'105a: 0x4159          ADCS     R1, R1, R3
                @800105c:
  0x800'105c: 0xea80 0x0201   EOR.W    R2, R0, R1
  0x800'1060: 0xfa21 0xf30e   LSR.W    R3, R1, LR
  0x800'1064: 0xfa62 0xf20e   ROR.W    R2, R2, LR
  0x800'1068: 0x2100          MOVS     R1, #0
  0x800'106a: 0x405a          EORS     R2, R2, R3
  0x800'106c: 0x4630          MOV      R0, R6
  0x800'106e: 0xbdf0          POP      {R4-R7, PC}
                @8001070:
  0x800'1070: 0xb430          PUSH     {R4, R5}
  0x800'1072: 0xfbb1 0xfcf3   UDIV     R12, R1, R3
  0x800'1076: 0xfb03 0x111c   MLS      R1, R3, R12, R1
  0x800'107a: 0xfba2 0x450c   UMULL    R4, R5, R2, R12
  0x800'107e: 0x1b00          SUBS     R0, R0, R4
  0x800'1080: 0x41a9          SBCS     R1, R1, R5
  0x800'1082: 0xd203          BCS.N    @800108c
  0x800'1084: 0xf1ac 0x0c01   SUB.W    R12, R12, #1
  0x800'1088: 0x1880          ADDS     R0, R0, R2
  0x800'108a: 0x4159          ADCS     R1, R1, R3
                @800108c:
  0x800'108c: 0xbc30          POP      {R4, R5}
  0x800'108e: 0x4602          MOV      R2, R0
  0x800'1090: 0x460b          MOV      R3, R1
  0x800'1092: 0x4660          MOV      R0, R12
  0x800'1094: 0x2100          MOVS     R1, #0
  0x800'1096: 0x4770          BX       LR
                @8001098:
  0x800'1098: 0xf1b2 0x7f80   CMP.W    R2, #16777216          ; 0x100'0000
  0x800'109c: 0xd365          BCC.N    @800116a
  0x800'109e: 0xb5f0          PUSH     {R4-R7, LR}
  0x800'10a0: 0xfab2 0xf782   CLZ      R7, R2
  0x800'10a4: 0xfab1 0xf481   CLZ      R4, R1
  0x800'10a8: 0xf1c7 0x060f   RSB.W    R6, R7, #15            ; 0xf
  0x800'10ac: 0x1b3d          SUBS     R5, R7, R4
  0x800'10ae: 0xfa22 0xf306   LSR.W    R3, R2, R6
  0x800'10b2: 0xf107 0x0e11   ADD.W    LR, R7, #17            ; 0x11
  0x800'10b6: 0x41f2          RORS     R2, R2, R6
  0x800'10b8: 0x3520          ADDS     R5, R5, #32            ; 0x20
  0x800'10ba: 0x405a          EORS     R2, R2, R3
  0x800'10bc: 0xf1b5 0x070f   SUBS.W   R7, R5, #15            ; 0xf
  0x800'10c0: 0xd9b8          BLS.N    @8001034
                @80010c2:
  0x800'10c2: 0x4041          EORS     R1, R1, R0
  0x800'10c4: 0xf1c4 0x0620   RSB.W    R6, R4, #32            ; 0x20
  0x800'10c8: 0x40a0          LSLS     R0, R0, R4
  0x800'10ca: 0x41f1          RORS     R1, R1, R6
  0x800'10cc: 0x4041          EORS     R1, R1, R0
  0x800'10ce: 0xfbb1 0xfcf3   UDIV     R12, R1, R3
  0x800'10d2: 0xfb03 0x111c   MLS      R1, R3, R12, R1
  0x800'10d6: 0xfba2 0x450c   UMULL    R4, R5, R2, R12
  0x800'10da: 0x1b00          SUBS     R0, R0, R4
  0x800'10dc: 0x41a9          SBCS     R1, R1, R5
  0x800'10de: 0xd203          BCS.N    @80010e8
  0x800'10e0: 0xf1bc 0x0c01   SUBS.W   R12, R12, #1
  0x800'10e4: 0x1880          ADDS     R0, R0, R2
  0x800'10e6: 0x4159          ADCS     R1, R1, R3
                @80010e8:
  0x800'10e8: 0x2f0f          CMP      R7, #15                ; 0xf
  0x800'10ea: 0xd312          BCC.N    @8001112
  0x800'10ec: 0x3f0f          SUBS     R7, R7, #15            ; 0xf
  0x800'10ee: 0x03c9          LSLS     R1, R1, #15
  0x800'10f0: 0xea41 0x4150   ORR.W    R1, R1, R0, LSR #17
  0x800'10f4: 0xfbb1 0xf6f3   UDIV     R6, R1, R3
  0x800'10f8: 0xfb03 0x1116   MLS      R1, R3, R6, R1
  0x800'10fc: 0xfba2 0x4506   UMULL    R4, R5, R2, R6
  0x800'1100: 0xebd4 0x30c0   RSBS.W   R0, R4, R0, LSL #15
  0x800'1104: 0x41a9          SBCS     R1, R1, R5
  0x800'1106: 0xd202          BCS.N    @800110e
  0x800'1108: 0x1e76          SUBS     R6, R6, #1
  0x800'110a: 0x1880          ADDS     R0, R0, R2
  0x800'110c: 0x4159          ADCS     R1, R1, R3
                @800110e:
  0x800'110e: 0xea46 0x3ccc   ORR.W    R12, R6, R12, LSL #15
                @8001112:
  0x800'1112: 0xb307          CBZ      R7, @8001156
  0x800'1114: 0x4041          EORS     R1, R1, R0
  0x800'1116: 0xf1c7 0x0620   RSB.W    R6, R7, #32            ; 0x20
  0x800'111a: 0x40b8          LSLS     R0, R0, R7
  0x800'111c: 0x41f1          RORS     R1, R1, R6
  0x800'111e: 0x4041          EORS     R1, R1, R0
  0x800'1120: 0xfbb1 0xf6f3   UDIV     R6, R1, R3
  0x800'1124: 0xfb03 0x1116   MLS      R1, R3, R6, R1
  0x800'1128: 0xfba2 0x4506   UMULL    R4, R5, R2, R6
  0x800'112c: 0x1b00          SUBS     R0, R0, R4
  0x800'112e: 0x41a9          SBCS     R1, R1, R5
  0x800'1130: 0xd202          BCS.N    @8001138
  0x800'1132: 0x1e76          SUBS     R6, R6, #1
  0x800'1134: 0x1880          ADDS     R0, R0, R2
  0x800'1136: 0x4159          ADCS     R1, R1, R3
                @8001138:
  0x800'1138: 0xea80 0x0201   EOR.W    R2, R0, R1
  0x800'113c: 0xfa21 0xf30e   LSR.W    R3, R1, LR
  0x800'1140: 0xf1c7 0x0420   RSB.W    R4, R7, #32            ; 0x20
  0x800'1144: 0xfa62 0xf20e   ROR.W    R2, R2, LR
  0x800'1148: 0xfa0c 0xf007   LSL.W    R0, R12, R7
  0x800'114c: 0x405a          EORS     R2, R2, R3
  0x800'114e: 0xfa2c 0xf104   LSR.W    R1, R12, R4
  0x800'1152: 0x4330          ORRS     R0, R0, R6
  0x800'1154: 0xbdf0          POP      {R4-R7, PC}
                @8001156:
  0x800'1156: 0xea80 0x0201   EOR.W    R2, R0, R1
  0x800'115a: 0xfa21 0xf30e   LSR.W    R3, R1, LR
  0x800'115e: 0x2100          MOVS     R1, #0
  0x800'1160: 0xfa62 0xf20e   ROR.W    R2, R2, LR
  0x800'1164: 0x4660          MOV      R0, R12
  0x800'1166: 0x405a          EORS     R2, R2, R3
  0x800'1168: 0xbdf0          POP      {R4-R7, PC}
                @800116a:
  0x800'116a: 0x468c          MOV      R12, R1
  0x800'116c: 0xfbb1 0xf1f2   UDIV     R1, R1, R2
  0x800'1170: 0xfb02 0xc311   MLS      R3, R2, R1, R12
  0x800'1174: 0x021b          LSLS     R3, R3, #8
  0x800'1176: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'117a: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'117e: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'1182: 0x021b          LSLS     R3, R3, #8
  0x800'1184: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'1188: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'118c: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'1190: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'1194: 0x021b          LSLS     R3, R3, #8
  0x800'1196: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'119a: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'119e: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'11a2: 0xfb02 0x331c   MLS      R3, R2, R12, R3
  0x800'11a6: 0x021b          LSLS     R3, R3, #8
  0x800'11a8: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'11ac: 0xea43 0x6310   ORR.W    R3, R3, R0, LSR #24
  0x800'11b0: 0xfbb3 0xfcf2   UDIV     R12, R3, R2
  0x800'11b4: 0xfb02 0x321c   MLS      R2, R2, R12, R3
  0x800'11b8: 0xea4c 0x2000   ORR.W    R0, R12, R0, LSL #8
  0x800'11bc: 0x2300          MOVS     R3, #0
  0x800'11be: 0x4770          BX       LR
                `.text6`:
                printf:
  0x800'11c0: 0xb40e          PUSH     {R1-R3}
  0x800'11c2: 0xb51e          PUSH     {R1-R4, LR}
  0x800'11c4: 0x4602          MOV      R2, R0
  0x800'11c6: 0xa805          ADD      R0, SP, #0x14
  0x800'11c8: 0x9001          STR      R0, [SP, #0x4]
  0x800'11ca: 0x2400          MOVS     R4, #0
  0x800'11cc: 0x9400          STR      R4, [SP]
  0x800'11ce: 0xab01          ADD      R3, SP, #0x4
  0x800'11d0: 0x2101          MOVS     R1, #1
  0x800'11d2: 0x4804          LDR.N    R0, ??printf_0         ; 0x195d (6493)
  0x800'11d4: 0x4478          ADD      R0, R0, PC
  0x800'11d6: 0x300c          ADDS     R0, R0, #12            ; 0xc
  0x800'11d8: 0xf000 0xfde3   BL       _PrintfTiny            ; 0x800'1da2
  0x800'11dc: 0xb003          ADD      SP, SP, #0xc
  0x800'11de: 0xbc10          POP      {R4}
  0x800'11e0: 0xf85d 0xfb10   LDR.W    PC, [SP], #0x10
                `$d.32`:
                ??printf_0:
  0x800'11e4: 0x0000'195d     DC32     6493                   ; ']...'
                $t:
                `.text19`:
                HAL_IncTick:
  //   uwTick += uwTickFreq;
  0x800'11e8: 0x4803          LDR.N    R0, ??HAL_IncTick_0    ; uwTick
  0x800'11ea: 0x6801          LDR      R1, [R0]
  0x800'11ec: 0x4a03          LDR.N    R2, [PC, #0xc]         ; uwTickFreq
  0x800'11ee: 0x7812          LDRB     R2, [R2]
  0x800'11f0: 0x1889          ADDS     R1, R1, R2
  0x800'11f2: 0x6001          STR      R1, [R0]
  // }
  0x800'11f4: 0x4770          BX       LR
  0x800'11f6: 0xbf00          NOP
                `$d.32`:
                ??HAL_IncTick_0:
  0x800'11f8: 0x2000'0228     DC32     uwTick
  0x800'11fc: 0x2000'000c     DC32     uwTickFreq
                $t:
                `.text8`:
                HAL_TIM_Base_Init:
  // HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
  // {
  0x800'1200: 0xb510          PUSH     {R4, LR}
  0x800'1202: 0x0004          MOVS     R4, R0
  //   if (htim == NULL)
  0x800'1204: 0x2c00          CMP      R4, #0
  0x800'1206: 0xd101          BNE.N    ??HAL_TIM_Base_Init_0  ; 0x800'120c
  //     return HAL_ERROR;
  0x800'1208: 0x2001          MOVS     R0, #1
  0x800'120a: 0xe0d4          B.N      ??HAL_TIM_Base_Init_1  ; 0x800'13b6
                ??HAL_TIM_Base_Init_0:
  //   assert_param(IS_TIM_INSTANCE(htim->Instance));
  0x800'120c: 0x6821          LDR      R1, [R4]
  0x800'120e: 0xf8df 0x02d8   LDR.W    R0, ??DataTable7       ; 0x4001'0000
  0x800'1212: 0x4281          CMP      R1, R0
  0x800'1214: 0xd045          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1216: 0x6820          LDR      R0, [R4]
  0x800'1218: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'121c: 0xd041          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'121e: 0x6821          LDR      R1, [R4]
  0x800'1220: 0xf8df 0x02c8   LDR.W    R0, ??DataTable7_1     ; 0x4000'0400
  0x800'1224: 0x4281          CMP      R1, R0
  0x800'1226: 0xd03c          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1228: 0x6821          LDR      R1, [R4]
  0x800'122a: 0xf8df 0x02c4   LDR.W    R0, ??DataTable7_2     ; 0x4000'0800
  0x800'122e: 0x4281          CMP      R1, R0
  0x800'1230: 0xd037          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1232: 0x6821          LDR      R1, [R4]
  0x800'1234: 0xf8df 0x02bc   LDR.W    R0, ??DataTable7_3     ; 0x4000'0c00
  0x800'1238: 0x4281          CMP      R1, R0
  0x800'123a: 0xd032          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'123c: 0x6821          LDR      R1, [R4]
  0x800'123e: 0xf8df 0x02b8   LDR.W    R0, ??DataTable7_4     ; 0x4000'1000
  0x800'1242: 0x4281          CMP      R1, R0
  0x800'1244: 0xd02d          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1246: 0x6821          LDR      R1, [R4]
  0x800'1248: 0xf8df 0x02b0   LDR.W    R0, ??DataTable7_5     ; 0x4000'1400
  0x800'124c: 0x4281          CMP      R1, R0
  0x800'124e: 0xd028          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1250: 0x6821          LDR      R1, [R4]
  0x800'1252: 0xf8df 0x02ac   LDR.W    R0, ??DataTable7_6     ; 0x4001'0400
  0x800'1256: 0x4281          CMP      R1, R0
  0x800'1258: 0xd023          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'125a: 0x6821          LDR      R1, [R4]
  0x800'125c: 0xf8df 0x02a4   LDR.W    R0, ??DataTable7_7     ; 0x4001'4000
  0x800'1260: 0x4281          CMP      R1, R0
  0x800'1262: 0xd01e          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1264: 0x6820          LDR      R0, [R4]
  0x800'1266: 0xf8df 0x12a0   LDR.W    R1, ??DataTable7_8     ; 0x4001'4400
  0x800'126a: 0x4288          CMP      R0, R1
  0x800'126c: 0xd019          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'126e: 0x6821          LDR      R1, [R4]
  0x800'1270: 0xf8df 0x0298   LDR.W    R0, ??DataTable7_9     ; 0x4001'4800
  0x800'1274: 0x4281          CMP      R1, R0
  0x800'1276: 0xd014          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1278: 0x6821          LDR      R1, [R4]
  0x800'127a: 0xf8df 0x0294   LDR.W    R0, ??DataTable7_10    ; 0x4000'1800
  0x800'127e: 0x4281          CMP      R1, R0
  0x800'1280: 0xd00f          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1282: 0x6821          LDR      R1, [R4]
  0x800'1284: 0xf8df 0x028c   LDR.W    R0, ??DataTable7_11    ; 0x4000'1c00
  0x800'1288: 0x4281          CMP      R1, R0
  0x800'128a: 0xd00a          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'128c: 0x6821          LDR      R1, [R4]
  0x800'128e: 0xf8df 0x0288   LDR.W    R0, ??DataTable7_12    ; 0x4000'2000
  0x800'1292: 0x4281          CMP      R1, R0
  0x800'1294: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_2  ; 0x800'12a2
  0x800'1296: 0xf240 0x1113   MOVW     R1, #275               ; 0x113
  0x800'129a: 0xf8df 0x0280   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'129e: 0xf7ff 0xfd52   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_2:
  //   assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  0x800'12a2: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12a4: 0x2800          CMP      R0, #0
  0x800'12a6: 0xd011          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12a8: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12aa: 0x2810          CMP      R0, #16                ; 0x10
  0x800'12ac: 0xd00e          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12ae: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12b0: 0x2820          CMP      R0, #32                ; 0x20
  0x800'12b2: 0xd00b          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12b4: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12b6: 0x2840          CMP      R0, #64                ; 0x40
  0x800'12b8: 0xd008          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12ba: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'12bc: 0x2860          CMP      R0, #96                ; 0x60
  0x800'12be: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_3  ; 0x800'12cc
  0x800'12c0: 0xf44f 0x718a   MOV.W    R1, #276               ; 0x114
  0x800'12c4: 0xf8df 0x0254   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'12c8: 0xf7ff 0xfd3d   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_3:
  //   assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  0x800'12cc: 0x6920          LDR      R0, [R4, #0x10]
  0x800'12ce: 0x2800          CMP      R0, #0
  0x800'12d0: 0xd00d          BEQ.N    ??HAL_TIM_Base_Init_4  ; 0x800'12ee
  0x800'12d2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'12d4: 0xf5b0 0x7f80   CMP.W    R0, #256               ; 0x100
  0x800'12d8: 0xd009          BEQ.N    ??HAL_TIM_Base_Init_4  ; 0x800'12ee
  0x800'12da: 0x6920          LDR      R0, [R4, #0x10]
  0x800'12dc: 0xf5b0 0x7f00   CMP.W    R0, #512               ; 0x200
  0x800'12e0: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_4  ; 0x800'12ee
  0x800'12e2: 0xf240 0x1115   MOVW     R1, #277               ; 0x115
  0x800'12e6: 0xf8df 0x0234   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'12ea: 0xf7ff 0xfd2c   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_4:
  //   assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  0x800'12ee: 0x6820          LDR      R0, [R4]
  0x800'12f0: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'12f4: 0xd004          BEQ.N    ??HAL_TIM_Base_Init_5  ; 0x800'1300
  0x800'12f6: 0x6821          LDR      R1, [R4]
  0x800'12f8: 0xf8df 0x01f8   LDR.W    R0, ??DataTable7_3     ; 0x4000'0c00
  0x800'12fc: 0x4281          CMP      R1, R0
  0x800'12fe: 0xd101          BNE.N    ??HAL_TIM_Base_Init_6  ; 0x800'1304
                ??HAL_TIM_Base_Init_5:
  0x800'1300: 0x2001          MOVS     R0, #1
  0x800'1302: 0xe000          B.N      ??HAL_TIM_Base_Init_7  ; 0x800'1306
                ??HAL_TIM_Base_Init_6:
  0x800'1304: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Init_7:
  0x800'1306: 0xb2c0          UXTB     R0, R0
  0x800'1308: 0x2800          CMP      R0, #0
  0x800'130a: 0xd10a          BNE.N    ??HAL_TIM_Base_Init_8  ; 0x800'1322
  0x800'130c: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'130e: 0x2800          CMP      R0, #0
  0x800'1310: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_9  ; 0x800'131e
  0x800'1312: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1314: 0xf5b0 0x3f80   CMP.W    R0, #65536             ; 0x1'0000
  0x800'1318: 0xd201          BCS.N    ??HAL_TIM_Base_Init_9  ; 0x800'131e
  0x800'131a: 0x2001          MOVS     R0, #1
  0x800'131c: 0xe007          B.N      ??HAL_TIM_Base_Init_10 ; 0x800'132e
                ??HAL_TIM_Base_Init_9:
  0x800'131e: 0x2000          MOVS     R0, #0
  0x800'1320: 0xe005          B.N      ??HAL_TIM_Base_Init_10 ; 0x800'132e
                ??HAL_TIM_Base_Init_8:
  0x800'1322: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1324: 0x2800          CMP      R0, #0
  0x800'1326: 0xd001          BEQ.N    ??HAL_TIM_Base_Init_11 ; 0x800'132c
  0x800'1328: 0x2001          MOVS     R0, #1
  0x800'132a: 0xe000          B.N      ??HAL_TIM_Base_Init_10 ; 0x800'132e
                ??HAL_TIM_Base_Init_11:
  0x800'132c: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Init_10:
  0x800'132e: 0x2800          CMP      R0, #0
  0x800'1330: 0xd105          BNE.N    ??HAL_TIM_Base_Init_12 ; 0x800'133e
  0x800'1332: 0xf44f 0x718b   MOV.W    R1, #278               ; 0x116
  0x800'1336: 0xf8df 0x01e4   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'133a: 0xf7ff 0xfd04   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_12:
  //   assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
  0x800'133e: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'1340: 0x2800          CMP      R0, #0
  0x800'1342: 0xd008          BEQ.N    ??HAL_TIM_Base_Init_13 ; 0x800'1356
  0x800'1344: 0x69a0          LDR      R0, [R4, #0x18]
  0x800'1346: 0x2880          CMP      R0, #128               ; 0x80
  0x800'1348: 0xd005          BEQ.N    ??HAL_TIM_Base_Init_13 ; 0x800'1356
  0x800'134a: 0xf240 0x1117   MOVW     R1, #279               ; 0x117
  0x800'134e: 0xf8df 0x01cc   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'1352: 0xf7ff 0xfcf8   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Init_13:
  //   if (htim->State == HAL_TIM_STATE_RESET)
  0x800'1356: 0xf894 0x003d   LDRB.W   R0, [R4, #0x3d]
  0x800'135a: 0x2800          CMP      R0, #0
  0x800'135c: 0xd105          BNE.N    ??HAL_TIM_Base_Init_14 ; 0x800'136a
  //     htim->Lock = HAL_UNLOCKED;
  0x800'135e: 0x2000          MOVS     R0, #0
  0x800'1360: 0xf884 0x003c   STRB.W   R0, [R4, #0x3c]
  //     HAL_TIM_Base_MspInit(htim);
  0x800'1364: 0x0020          MOVS     R0, R4
  0x800'1366: 0xf000 0xfdac   BL       HAL_TIM_Base_MspInit   ; 0x800'1ec2
                ??HAL_TIM_Base_Init_14:
  //   htim->State = HAL_TIM_STATE_BUSY;
  0x800'136a: 0x2002          MOVS     R0, #2
  0x800'136c: 0xf884 0x003d   STRB.W   R0, [R4, #0x3d]
  //   TIM_Base_SetConfig(htim->Instance, &htim->Init);
  0x800'1370: 0x1d21          ADDS     R1, R4, #4
  0x800'1372: 0x6820          LDR      R0, [R4]
  0x800'1374: 0xf000 0xf973   BL       TIM_Base_SetConfig     ; 0x800'165e
  //   htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
  0x800'1378: 0x2001          MOVS     R0, #1
  0x800'137a: 0xf884 0x0046   STRB.W   R0, [R4, #0x46]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'137e: 0x2001          MOVS     R0, #1
  0x800'1380: 0xf884 0x003e   STRB.W   R0, [R4, #0x3e]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'1384: 0x2001          MOVS     R0, #1
  0x800'1386: 0xf884 0x003f   STRB.W   R0, [R4, #0x3f]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'138a: 0x2001          MOVS     R0, #1
  0x800'138c: 0xf884 0x0040   STRB.W   R0, [R4, #0x40]
  //   TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'1390: 0x2001          MOVS     R0, #1
  0x800'1392: 0xf884 0x0041   STRB.W   R0, [R4, #0x41]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'1396: 0x2001          MOVS     R0, #1
  0x800'1398: 0xf884 0x0042   STRB.W   R0, [R4, #0x42]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'139c: 0x2001          MOVS     R0, #1
  0x800'139e: 0xf884 0x0043   STRB.W   R0, [R4, #0x43]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'13a2: 0x2001          MOVS     R0, #1
  0x800'13a4: 0xf884 0x0044   STRB.W   R0, [R4, #0x44]
  //   TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  0x800'13a8: 0x2001          MOVS     R0, #1
  0x800'13aa: 0xf884 0x0045   STRB.W   R0, [R4, #0x45]
  //   htim->State = HAL_TIM_STATE_READY;
  0x800'13ae: 0x2001          MOVS     R0, #1
  0x800'13b0: 0xf884 0x003d   STRB.W   R0, [R4, #0x3d]
  //   return HAL_OK;
  0x800'13b4: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Init_1:
  0x800'13b6: 0xbd10          POP      {R4, PC}
                `.text_7`:
                HAL_TIM_Base_Start_IT:
  // HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
  // {
  0x800'13b8: 0xb570          PUSH     {R4-R6, LR}
  0x800'13ba: 0x0004          MOVS     R4, R0
  //   assert_param(IS_TIM_INSTANCE(htim->Instance));
  0x800'13bc: 0xf8df 0x6128   LDR.W    R6, ??DataTable7       ; 0x4001'0000
  0x800'13c0: 0x6820          LDR      R0, [R4]
  0x800'13c2: 0x42b0          CMP      R0, R6
  0x800'13c4: 0xd045          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13c6: 0x6820          LDR      R0, [R4]
  0x800'13c8: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'13cc: 0xd041          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13ce: 0x6821          LDR      R1, [R4]
  0x800'13d0: 0xf8df 0x0118   LDR.W    R0, ??DataTable7_1     ; 0x4000'0400
  0x800'13d4: 0x4281          CMP      R1, R0
  0x800'13d6: 0xd03c          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13d8: 0x6821          LDR      R1, [R4]
  0x800'13da: 0xf8df 0x0114   LDR.W    R0, ??DataTable7_2     ; 0x4000'0800
  0x800'13de: 0x4281          CMP      R1, R0
  0x800'13e0: 0xd037          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13e2: 0x6820          LDR      R0, [R4]
  0x800'13e4: 0xf8df 0x110c   LDR.W    R1, ??DataTable7_3     ; 0x4000'0c00
  0x800'13e8: 0x4288          CMP      R0, R1
  0x800'13ea: 0xd032          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13ec: 0x6821          LDR      R1, [R4]
  0x800'13ee: 0xf8df 0x0108   LDR.W    R0, ??DataTable7_4     ; 0x4000'1000
  0x800'13f2: 0x4281          CMP      R1, R0
  0x800'13f4: 0xd02d          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'13f6: 0x6821          LDR      R1, [R4]
  0x800'13f8: 0xf8df 0x0100   LDR.W    R0, ??DataTable7_5     ; 0x4000'1400
  0x800'13fc: 0x4281          CMP      R1, R0
  0x800'13fe: 0xd028          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1400: 0x6821          LDR      R1, [R4]
  0x800'1402: 0xf8df 0x00fc   LDR.W    R0, ??DataTable7_6     ; 0x4001'0400
  0x800'1406: 0x4281          CMP      R1, R0
  0x800'1408: 0xd023          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'140a: 0x6821          LDR      R1, [R4]
  0x800'140c: 0xf8df 0x00f4   LDR.W    R0, ??DataTable7_7     ; 0x4001'4000
  0x800'1410: 0x4281          CMP      R1, R0
  0x800'1412: 0xd01e          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1414: 0x6821          LDR      R1, [R4]
  0x800'1416: 0xf8df 0x00f0   LDR.W    R0, ??DataTable7_8     ; 0x4001'4400
  0x800'141a: 0x4281          CMP      R1, R0
  0x800'141c: 0xd019          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'141e: 0x6821          LDR      R1, [R4]
  0x800'1420: 0xf8df 0x00e8   LDR.W    R0, ??DataTable7_9     ; 0x4001'4800
  0x800'1424: 0x4281          CMP      R1, R0
  0x800'1426: 0xd014          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1428: 0x6821          LDR      R1, [R4]
  0x800'142a: 0xf8df 0x00e4   LDR.W    R0, ??DataTable7_10    ; 0x4000'1800
  0x800'142e: 0x4281          CMP      R1, R0
  0x800'1430: 0xd00f          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1432: 0x6821          LDR      R1, [R4]
  0x800'1434: 0xf8df 0x00dc   LDR.W    R0, ??DataTable7_11    ; 0x4000'1c00
  0x800'1438: 0x4281          CMP      R1, R0
  0x800'143a: 0xd00a          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'143c: 0x6821          LDR      R1, [R4]
  0x800'143e: 0xf8df 0x00d8   LDR.W    R0, ??DataTable7_12    ; 0x4000'2000
  0x800'1442: 0x4281          CMP      R1, R0
  0x800'1444: 0xd005          BEQ.N    ??HAL_TIM_Base_Start_IT_0
                                                              ; 0x800'1452
  0x800'1446: 0xf44f 0x71e8   MOV.W    R1, #464               ; 0x1d0
  0x800'144a: 0xf8df 0x00d0   LDR.W    R0, ??DataTable9       ; ?_0
  0x800'144e: 0xf7ff 0xfc7a   BL       assert_failed          ; 0x800'0d46
                ??HAL_TIM_Base_Start_IT_0:
  //   if (htim->State != HAL_TIM_STATE_READY)
  0x800'1452: 0xf894 0x003d   LDRB.W   R0, [R4, #0x3d]
  0x800'1456: 0x2801          CMP      R0, #1
  0x800'1458: 0xd001          BEQ.N    ??HAL_TIM_Base_Start_IT_1
                                                              ; 0x800'145e
  //     return HAL_ERROR;
  0x800'145a: 0x2001          MOVS     R0, #1
  0x800'145c: 0xe042          B.N      ??HAL_TIM_Base_Start_IT_2
                                                              ; 0x800'14e4
                ??HAL_TIM_Base_Start_IT_1:
  //   htim->State = HAL_TIM_STATE_BUSY;
  0x800'145e: 0x2002          MOVS     R0, #2
  0x800'1460: 0xf884 0x003d   STRB.W   R0, [R4, #0x3d]
  //   __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
  0x800'1464: 0x6820          LDR      R0, [R4]
  0x800'1466: 0x68c1          LDR      R1, [R0, #0xc]
  0x800'1468: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'146c: 0x6820          LDR      R0, [R4]
  0x800'146e: 0x60c1          STR      R1, [R0, #0xc]
  //   if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
  0x800'1470: 0x6820          LDR      R0, [R4]
  0x800'1472: 0x42b0          CMP      R0, R6
  0x800'1474: 0xd021          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'1476: 0x6820          LDR      R0, [R4]
  0x800'1478: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'147c: 0xd01d          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'147e: 0x6821          LDR      R1, [R4]
  0x800'1480: 0xf8df 0x0068   LDR.W    R0, ??DataTable7_1     ; 0x4000'0400
  0x800'1484: 0x4281          CMP      R1, R0
  0x800'1486: 0xd018          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'1488: 0x6821          LDR      R1, [R4]
  0x800'148a: 0xf8df 0x0064   LDR.W    R0, ??DataTable7_2     ; 0x4000'0800
  0x800'148e: 0x4281          CMP      R1, R0
  0x800'1490: 0xd013          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'1492: 0x6820          LDR      R0, [R4]
  0x800'1494: 0xf8df 0x105c   LDR.W    R1, ??DataTable7_3     ; 0x4000'0c00
  0x800'1498: 0x4288          CMP      R0, R1
  0x800'149a: 0xd00e          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'149c: 0x6821          LDR      R1, [R4]
  0x800'149e: 0xf8df 0x0060   LDR.W    R0, ??DataTable7_6     ; 0x4001'0400
  0x800'14a2: 0x4281          CMP      R1, R0
  0x800'14a4: 0xd009          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'14a6: 0x6821          LDR      R1, [R4]
  0x800'14a8: 0xf8df 0x0058   LDR.W    R0, ??DataTable7_7     ; 0x4001'4000
  0x800'14ac: 0x4281          CMP      R1, R0
  0x800'14ae: 0xd004          BEQ.N    ??HAL_TIM_Base_Start_IT_3
                                                              ; 0x800'14ba
  0x800'14b0: 0x6821          LDR      R1, [R4]
  0x800'14b2: 0xf8df 0x005c   LDR.W    R0, ??DataTable7_10    ; 0x4000'1800
  0x800'14b6: 0x4281          CMP      R1, R0
  0x800'14b8: 0xd10d          BNE.N    ??HAL_TIM_Base_Start_IT_4
                                                              ; 0x800'14d6
                ??HAL_TIM_Base_Start_IT_3:
  //     tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
  0x800'14ba: 0x6820          LDR      R0, [R4]
  0x800'14bc: 0x6880          LDR      R0, [R0, #0x8]
  0x800'14be: 0xf010 0x0007   ANDS.W   R0, R0, #7
  0x800'14c2: 0x0005          MOVS     R5, R0
  //     if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  0x800'14c4: 0x2d06          CMP      R5, #6
  0x800'14c6: 0xd00c          BEQ.N    ??HAL_TIM_Base_Start_IT_5
                                                              ; 0x800'14e2
  //       __HAL_TIM_ENABLE(htim);
  0x800'14c8: 0x6820          LDR      R0, [R4]
  0x800'14ca: 0x6801          LDR      R1, [R0]
  0x800'14cc: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'14d0: 0x6820          LDR      R0, [R4]
  0x800'14d2: 0x6001          STR      R1, [R0]
  0x800'14d4: 0xe005          B.N      ??HAL_TIM_Base_Start_IT_5
                                                              ; 0x800'14e2
                ??HAL_TIM_Base_Start_IT_4:
  //     __HAL_TIM_ENABLE(htim);
  0x800'14d6: 0x6820          LDR      R0, [R4]
  0x800'14d8: 0x6801          LDR      R1, [R0]
  0x800'14da: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'14de: 0x6820          LDR      R0, [R4]
  0x800'14e0: 0x6001          STR      R1, [R0]
                ??HAL_TIM_Base_Start_IT_5:
  //   return HAL_OK;
  0x800'14e2: 0x2000          MOVS     R0, #0
                ??HAL_TIM_Base_Start_IT_2:
  0x800'14e4: 0xbd70          POP      {R4-R6, PC}
  0x800'14e6: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable7:
  0x800'14e8: 0x4001'0000     DC32     0x4001'0000            ; '...@'
                ??DataTable7_1:
  0x800'14ec: 0x4000'0400     DC32     0x4000'0400            ; '...@'
                ??DataTable7_2:
  0x800'14f0: 0x4000'0800     DC32     0x4000'0800            ; '...@'
                ??DataTable7_3:
  0x800'14f4: 0x4000'0c00     DC32     0x4000'0c00            ; '...@'
                ??DataTable7_4:
  0x800'14f8: 0x4000'1000     DC32     0x4000'1000            ; '...@'
                ??DataTable7_5:
  0x800'14fc: 0x4000'1400     DC32     0x4000'1400            ; '...@'
                ??DataTable7_6:
  0x800'1500: 0x4001'0400     DC32     0x4001'0400            ; '...@'
                ??DataTable7_7:
  0x800'1504: 0x4001'4000     DC32     0x4001'4000            ; '.@.@'
                ??DataTable7_8:
  0x800'1508: 0x4001'4400     DC32     0x4001'4400            ; '.D.@'
                ??DataTable7_9:
  0x800'150c: 0x4001'4800     DC32     0x4001'4800            ; '.H.@'
                ??DataTable7_10:
  0x800'1510: 0x4000'1800     DC32     0x4000'1800            ; '...@'
                ??DataTable7_11:
  0x800'1514: 0x4000'1c00     DC32     0x4000'1c00            ; '...@'
                ??DataTable7_12:
  0x800'1518: 0x4000'2000     DC32     0x4000'2000            ; '. .@'
                ??DataTable9:
  0x800'151c: 0x0800'29d8     DC32     ?_0
                $t:
                `.text_177`:
                HAL_TIM_IRQHandler:
  // void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
  // {
  0x800'1520: 0xb570          PUSH     {R4-R6, LR}
  0x800'1522: 0x0004          MOVS     R4, R0
  //   uint32_t itsource = htim->Instance->DIER;
  0x800'1524: 0x6820          LDR      R0, [R4]
  0x800'1526: 0x68c5          LDR      R5, [R0, #0xc]
  //   uint32_t itflag   = htim->Instance->SR;
  0x800'1528: 0x6820          LDR      R0, [R4]
  0x800'152a: 0x6906          LDR      R6, [R0, #0x10]
  //   if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
  0x800'152c: 0x07b0          LSLS     R0, R6, #30
  0x800'152e: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_0 ; 0x800'1562
  //     if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
  0x800'1530: 0x07a8          LSLS     R0, R5, #30
  0x800'1532: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_0 ; 0x800'1562
  //         __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
  0x800'1534: 0xf07f 0x0102   MVNS.W   R1, #2
  0x800'1538: 0x6820          LDR      R0, [R4]
  0x800'153a: 0x6101          STR      R1, [R0, #0x10]
  //         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
  0x800'153c: 0x2001          MOVS     R0, #1
  0x800'153e: 0x7720          STRB     R0, [R4, #0x1c]
  //         if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
  0x800'1540: 0x6820          LDR      R0, [R4]
  0x800'1542: 0x6980          LDR      R0, [R0, #0x18]
  0x800'1544: 0xf010 0x0f03   TST.W    R0, #3
  0x800'1548: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_1 ; 0x800'1552
  //           HAL_TIM_IC_CaptureCallback(htim);
  0x800'154a: 0x0020          MOVS     R0, R4
  0x800'154c: 0xf000 0xfcba   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'1550: 0xe005          B.N      ??HAL_TIM_IRQHandler_2 ; 0x800'155e
                ??HAL_TIM_IRQHandler_1:
  //           HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'1552: 0x0020          MOVS     R0, R4
  0x800'1554: 0xf000 0xfcb7   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //           HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'1558: 0x0020          MOVS     R0, R4
  0x800'155a: 0xf000 0xfcb5   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_2:
  //         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'155e: 0x2000          MOVS     R0, #0
  0x800'1560: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_0:
  //   if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
  0x800'1562: 0x0770          LSLS     R0, R6, #29
  0x800'1564: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_3 ; 0x800'1598
  //     if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
  0x800'1566: 0x0768          LSLS     R0, R5, #29
  0x800'1568: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_3 ; 0x800'1598
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
  0x800'156a: 0xf07f 0x0104   MVNS.W   R1, #4
  0x800'156e: 0x6820          LDR      R0, [R4]
  0x800'1570: 0x6101          STR      R1, [R0, #0x10]
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
  0x800'1572: 0x2002          MOVS     R0, #2
  0x800'1574: 0x7720          STRB     R0, [R4, #0x1c]
  //       if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
  0x800'1576: 0x6820          LDR      R0, [R4]
  0x800'1578: 0x6980          LDR      R0, [R0, #0x18]
  0x800'157a: 0xf410 0x7f40   TST.W    R0, #768               ; 0x300
  0x800'157e: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_4 ; 0x800'1588
  //         HAL_TIM_IC_CaptureCallback(htim);
  0x800'1580: 0x0020          MOVS     R0, R4
  0x800'1582: 0xf000 0xfc9f   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'1586: 0xe005          B.N      ??HAL_TIM_IRQHandler_5 ; 0x800'1594
                ??HAL_TIM_IRQHandler_4:
  //         HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'1588: 0x0020          MOVS     R0, R4
  0x800'158a: 0xf000 0xfc9c   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //         HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'158e: 0x0020          MOVS     R0, R4
  0x800'1590: 0xf000 0xfc9a   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_5:
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'1594: 0x2000          MOVS     R0, #0
  0x800'1596: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_3:
  //   if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
  0x800'1598: 0x0730          LSLS     R0, R6, #28
  0x800'159a: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_6 ; 0x800'15ce
  //     if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
  0x800'159c: 0x0728          LSLS     R0, R5, #28
  0x800'159e: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_6 ; 0x800'15ce
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
  0x800'15a0: 0xf07f 0x0108   MVNS.W   R1, #8
  0x800'15a4: 0x6820          LDR      R0, [R4]
  0x800'15a6: 0x6101          STR      R1, [R0, #0x10]
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
  0x800'15a8: 0x2004          MOVS     R0, #4
  0x800'15aa: 0x7720          STRB     R0, [R4, #0x1c]
  //       if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
  0x800'15ac: 0x6820          LDR      R0, [R4]
  0x800'15ae: 0x69c0          LDR      R0, [R0, #0x1c]
  0x800'15b0: 0xf010 0x0f03   TST.W    R0, #3
  0x800'15b4: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_7 ; 0x800'15be
  //         HAL_TIM_IC_CaptureCallback(htim);
  0x800'15b6: 0x0020          MOVS     R0, R4
  0x800'15b8: 0xf000 0xfc84   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'15bc: 0xe005          B.N      ??HAL_TIM_IRQHandler_8 ; 0x800'15ca
                ??HAL_TIM_IRQHandler_7:
  //         HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'15be: 0x0020          MOVS     R0, R4
  0x800'15c0: 0xf000 0xfc81   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //         HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'15c4: 0x0020          MOVS     R0, R4
  0x800'15c6: 0xf000 0xfc7f   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_8:
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'15ca: 0x2000          MOVS     R0, #0
  0x800'15cc: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_6:
  //   if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
  0x800'15ce: 0x06f0          LSLS     R0, R6, #27
  0x800'15d0: 0xd518          BPL.N    ??HAL_TIM_IRQHandler_9 ; 0x800'1604
  //     if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
  0x800'15d2: 0x06e8          LSLS     R0, R5, #27
  0x800'15d4: 0xd516          BPL.N    ??HAL_TIM_IRQHandler_9 ; 0x800'1604
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
  0x800'15d6: 0xf07f 0x0110   MVNS.W   R1, #16                ; 0x10
  0x800'15da: 0x6820          LDR      R0, [R4]
  0x800'15dc: 0x6101          STR      R1, [R0, #0x10]
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
  0x800'15de: 0x2008          MOVS     R0, #8
  0x800'15e0: 0x7720          STRB     R0, [R4, #0x1c]
  //       if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
  0x800'15e2: 0x6820          LDR      R0, [R4]
  0x800'15e4: 0x69c0          LDR      R0, [R0, #0x1c]
  0x800'15e6: 0xf410 0x7f40   TST.W    R0, #768               ; 0x300
  0x800'15ea: 0xd003          BEQ.N    ??HAL_TIM_IRQHandler_10
                                                              ; 0x800'15f4
  //         HAL_TIM_IC_CaptureCallback(htim);
  0x800'15ec: 0x0020          MOVS     R0, R4
  0x800'15ee: 0xf000 0xfc69   BL       HAL_TIM_IC_CaptureCallback
                                                              ; 0x800'1ec4
  0x800'15f2: 0xe005          B.N      ??HAL_TIM_IRQHandler_11
                                                              ; 0x800'1600
                ??HAL_TIM_IRQHandler_10:
  //         HAL_TIM_OC_DelayElapsedCallback(htim);
  0x800'15f4: 0x0020          MOVS     R0, R4
  0x800'15f6: 0xf000 0xfc66   BL       HAL_TIM_OC_DelayElapsedCallback
                                                              ; 0x800'1ec6
  //         HAL_TIM_PWM_PulseFinishedCallback(htim);
  0x800'15fa: 0x0020          MOVS     R0, R4
  0x800'15fc: 0xf000 0xfc64   BL       HAL_TIM_PWM_PulseFinishedCallback
                                                              ; 0x800'1ec8
                ??HAL_TIM_IRQHandler_11:
  //       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  0x800'1600: 0x2000          MOVS     R0, #0
  0x800'1602: 0x7720          STRB     R0, [R4, #0x1c]
                ??HAL_TIM_IRQHandler_9:
  //   if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
  0x800'1604: 0x07f0          LSLS     R0, R6, #31
  0x800'1606: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_12
                                                              ; 0x800'161a
  //     if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
  0x800'1608: 0x07e8          LSLS     R0, R5, #31
  0x800'160a: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_12
                                                              ; 0x800'161a
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
  0x800'160c: 0xf07f 0x0001   MVNS.W   R0, #1
  0x800'1610: 0x6821          LDR      R1, [R4]
  0x800'1612: 0x6108          STR      R0, [R1, #0x10]
  //       HAL_TIM_PeriodElapsedCallback(htim);
  0x800'1614: 0x0020          MOVS     R0, R4
  0x800'1616: 0xf000 0xfc58   BL       HAL_TIM_PeriodElapsedCallback
                                                              ; 0x800'1eca
                ??HAL_TIM_IRQHandler_12:
  //   if ((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK))
  0x800'161a: 0x0630          LSLS     R0, R6, #24
  0x800'161c: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_13
                                                              ; 0x800'1630
  //     if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
  0x800'161e: 0x0628          LSLS     R0, R5, #24
  0x800'1620: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_13
                                                              ; 0x800'1630
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
  0x800'1622: 0xf07f 0x0180   MVNS.W   R1, #128               ; 0x80
  0x800'1626: 0x6820          LDR      R0, [R4]
  0x800'1628: 0x6101          STR      R1, [R0, #0x10]
  //       HAL_TIMEx_BreakCallback(htim);
  0x800'162a: 0x0020          MOVS     R0, R4
  0x800'162c: 0xf000 0xfc4e   BL       HAL_TIMEx_BreakCallback
                                                              ; 0x800'1ecc
                ??HAL_TIM_IRQHandler_13:
  //   if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
  0x800'1630: 0x0670          LSLS     R0, R6, #25
  0x800'1632: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_14
                                                              ; 0x800'1646
  //     if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
  0x800'1634: 0x0668          LSLS     R0, R5, #25
  0x800'1636: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_14
                                                              ; 0x800'1646
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
  0x800'1638: 0xf07f 0x0140   MVNS.W   R1, #64                ; 0x40
  0x800'163c: 0x6820          LDR      R0, [R4]
  0x800'163e: 0x6101          STR      R1, [R0, #0x10]
  //       HAL_TIM_TriggerCallback(htim);
  0x800'1640: 0x0020          MOVS     R0, R4
  0x800'1642: 0xf000 0xfc44   BL       HAL_TIM_TriggerCallback
                                                              ; 0x800'1ece
                ??HAL_TIM_IRQHandler_14:
  //   if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
  0x800'1646: 0x06b0          LSLS     R0, R6, #26
  0x800'1648: 0xd508          BPL.N    ??HAL_TIM_IRQHandler_15
                                                              ; 0x800'165c
  //     if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
  0x800'164a: 0x06a8          LSLS     R0, R5, #26
  0x800'164c: 0xd506          BPL.N    ??HAL_TIM_IRQHandler_15
                                                              ; 0x800'165c
  //       __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
  0x800'164e: 0xf07f 0x0120   MVNS.W   R1, #32                ; 0x20
  0x800'1652: 0x6820          LDR      R0, [R4]
  0x800'1654: 0x6101          STR      R1, [R0, #0x10]
  //       HAL_TIMEx_CommutCallback(htim);
  0x800'1656: 0x0020          MOVS     R0, R4
  0x800'1658: 0xf000 0xfc3a   BL       HAL_TIMEx_CommutCallback
                                                              ; 0x800'1ed0
                ??HAL_TIM_IRQHandler_15:
  // }
  0x800'165c: 0xbd70          POP      {R4-R6, PC}
                `.text_262`:
                TIM_Base_SetConfig:
  // void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
  // {
  0x800'165e: 0xb410          PUSH     {R4}
  //   tmpcr1 = TIMx->CR1;
  0x800'1660: 0x6804          LDR      R4, [R0]
  //   if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  0x800'1662: 0xf8df 0x30d4   LDR.W    R3, ??DataTable67_1    ; 0x4001'0000
  0x800'1666: 0x4298          CMP      R0, R3
  0x800'1668: 0xd012          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'166a: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'166e: 0xd00f          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1670: 0xf8df 0x20c8   LDR.W    R2, ??DataTable67_2    ; 0x4000'0400
  0x800'1674: 0x4290          CMP      R0, R2
  0x800'1676: 0xd00b          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1678: 0xf8df 0x20c4   LDR.W    R2, ??DataTable67_3    ; 0x4000'0800
  0x800'167c: 0x4290          CMP      R0, R2
  0x800'167e: 0xd007          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1680: 0xf8df 0x20c0   LDR.W    R2, ??DataTable67_4    ; 0x4000'0c00
  0x800'1684: 0x4290          CMP      R0, R2
  0x800'1686: 0xd003          BEQ.N    ??TIM_Base_SetConfig_0 ; 0x800'1690
  0x800'1688: 0xf8df 0x20cc   LDR.W    R2, ??DataTable70      ; 0x4001'0400
  0x800'168c: 0x4290          CMP      R0, R2
  0x800'168e: 0xd104          BNE.N    ??TIM_Base_SetConfig_1 ; 0x800'169a
                ??TIM_Base_SetConfig_0:
  //     tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
  0x800'1690: 0xf034 0x0470   BICS.W   R4, R4, #112           ; 0x70
  //     tmpcr1 |= Structure->CounterMode;
  0x800'1694: 0x0022          MOVS     R2, R4
  0x800'1696: 0x684c          LDR      R4, [R1, #0x4]
  0x800'1698: 0x4314          ORRS     R4, R4, R2
                ??TIM_Base_SetConfig_1:
  //   if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  0x800'169a: 0x4298          CMP      R0, R3
  0x800'169c: 0xd027          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'169e: 0xf1b0 0x4f80   CMP.W    R0, #1073741824        ; 0x4000'0000
  0x800'16a2: 0xd024          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16a4: 0xf8df 0x2094   LDR.W    R2, ??DataTable67_2    ; 0x4000'0400
  0x800'16a8: 0x4290          CMP      R0, R2
  0x800'16aa: 0xd020          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16ac: 0xf8df 0x2090   LDR.W    R2, ??DataTable67_3    ; 0x4000'0800
  0x800'16b0: 0x4290          CMP      R0, R2
  0x800'16b2: 0xd01c          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16b4: 0xf8df 0x208c   LDR.W    R2, ??DataTable67_4    ; 0x4000'0c00
  0x800'16b8: 0x4290          CMP      R0, R2
  0x800'16ba: 0xd018          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16bc: 0xf8df 0x2098   LDR.W    R2, ??DataTable70      ; 0x4001'0400
  0x800'16c0: 0x4290          CMP      R0, R2
  0x800'16c2: 0xd014          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16c4: 0x4a1a          LDR.N    R2, ??DataTable66      ; 0x4001'4000
  0x800'16c6: 0x4290          CMP      R0, R2
  0x800'16c8: 0xd011          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16ca: 0xf8df 0x207c   LDR.W    R2, ??DataTable67_5    ; 0x4001'4400
  0x800'16ce: 0x4290          CMP      R0, R2
  0x800'16d0: 0xd00d          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16d2: 0xf8df 0x2078   LDR.W    R2, ??DataTable67_6    ; 0x4001'4800
  0x800'16d6: 0x4290          CMP      R0, R2
  0x800'16d8: 0xd009          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16da: 0x4a16          LDR.N    R2, ??DataTable67      ; 0x4000'1800
  0x800'16dc: 0x4290          CMP      R0, R2
  0x800'16de: 0xd006          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16e0: 0xf8df 0x206c   LDR.W    R2, ??DataTable67_7    ; 0x4000'1c00
  0x800'16e4: 0x4290          CMP      R0, R2
  0x800'16e6: 0xd002          BEQ.N    ??TIM_Base_SetConfig_2 ; 0x800'16ee
  0x800'16e8: 0x4a1a          LDR.N    R2, ??DataTable67_8    ; 0x4000'2000
  0x800'16ea: 0x4290          CMP      R0, R2
  0x800'16ec: 0xd104          BNE.N    ??TIM_Base_SetConfig_3 ; 0x800'16f8
                ??TIM_Base_SetConfig_2:
  //     tmpcr1 &= ~TIM_CR1_CKD;
  0x800'16ee: 0xf434 0x7440   BICS.W   R4, R4, #768           ; 0x300
  //     tmpcr1 |= (uint32_t)Structure->ClockDivision;
  0x800'16f2: 0x0022          MOVS     R2, R4
  0x800'16f4: 0x68cc          LDR      R4, [R1, #0xc]
  0x800'16f6: 0x4314          ORRS     R4, R4, R2
                ??TIM_Base_SetConfig_3:
  //   MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
  0x800'16f8: 0xf034 0x0480   BICS.W   R4, R4, #128           ; 0x80
  0x800'16fc: 0x694a          LDR      R2, [R1, #0x14]
  0x800'16fe: 0x4314          ORRS     R4, R4, R2
  //   TIMx->CR1 = tmpcr1;
  0x800'1700: 0x6004          STR      R4, [R0]
  //   TIMx->ARR = (uint32_t)Structure->Period ;
  0x800'1702: 0x688a          LDR      R2, [R1, #0x8]
  0x800'1704: 0x62c2          STR      R2, [R0, #0x2c]
  //   TIMx->PSC = Structure->Prescaler;
  0x800'1706: 0x680a          LDR      R2, [R1]
  0x800'1708: 0x6282          STR      R2, [R0, #0x28]
  //   if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
  0x800'170a: 0x4298          CMP      R0, R3
  0x800'170c: 0xd003          BEQ.N    ??TIM_Base_SetConfig_4 ; 0x800'1716
  0x800'170e: 0xf8df 0x2048   LDR.W    R2, ??DataTable70      ; 0x4001'0400
  0x800'1712: 0x4290          CMP      R0, R2
  0x800'1714: 0xd101          BNE.N    ??TIM_Base_SetConfig_5 ; 0x800'171a
                ??TIM_Base_SetConfig_4:
  //     TIMx->RCR = Structure->RepetitionCounter;
  0x800'1716: 0x690a          LDR      R2, [R1, #0x10]
  0x800'1718: 0x6302          STR      R2, [R0, #0x30]
                ??TIM_Base_SetConfig_5:
  //   TIMx->EGR = TIM_EGR_UG;
  0x800'171a: 0x2201          MOVS     R2, #1
  0x800'171c: 0x6142          STR      R2, [R0, #0x14]
  //   if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
  0x800'171e: 0x6902          LDR      R2, [R0, #0x10]
  0x800'1720: 0x07d2          LSLS     R2, R2, #31
  0x800'1722: 0xd503          BPL.N    ??TIM_Base_SetConfig_6 ; 0x800'172c
  //     CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
  0x800'1724: 0x6902          LDR      R2, [R0, #0x10]
  0x800'1726: 0x0852          LSRS     R2, R2, #1
  0x800'1728: 0x0052          LSLS     R2, R2, #1
  0x800'172a: 0x6102          STR      R2, [R0, #0x10]
                ??TIM_Base_SetConfig_6:
  // }
  0x800'172c: 0xbc10          POP      {R4}
  0x800'172e: 0x4770          BX       LR
                `$d.32`:
                ??DataTable66:
  0x800'1730: 0x4001'4000     DC32     0x4001'4000            ; '.@.@'
                ??DataTable67:
  0x800'1734: 0x4000'1800     DC32     0x4000'1800            ; '...@'
                ??DataTable67_1:
  0x800'1738: 0x4001'0000     DC32     0x4001'0000            ; '...@'
                ??DataTable67_2:
  0x800'173c: 0x4000'0400     DC32     0x4000'0400            ; '...@'
                ??DataTable67_3:
  0x800'1740: 0x4000'0800     DC32     0x4000'0800            ; '...@'
                ??DataTable67_4:
  0x800'1744: 0x4000'0c00     DC32     0x4000'0c00            ; '...@'
                ??DataTable67_5:
  0x800'1748: 0x4001'4400     DC32     0x4001'4400            ; '.D.@'
                ??DataTable67_6:
  0x800'174c: 0x4001'4800     DC32     0x4001'4800            ; '.H.@'
                ??DataTable67_7:
  0x800'1750: 0x4000'1c00     DC32     0x4000'1c00            ; '...@'
                ??DataTable67_8:
  0x800'1754: 0x4000'2000     DC32     0x4000'2000            ; '. .@'
                ??DataTable70:
  0x800'1758: 0x4001'0400     DC32     0x4001'0400            ; '...@'
                $t:
                `.text6`:
                __iar_Memset:
                __aeabi_memset:
  0x800'175c: 0xf362 0x220f   BFI      R2, R2, #8, #8
  0x800'1760: 0xf362 0x421f   BFI      R2, R2, #16, #16
                `.text_1`:
                __iar_Memset_word:
  0x800'1764: 0x1840          ADDS     R0, R0, R1
  0x800'1766: 0xf010 0x0303   ANDS.W   R3, R0, #3
  0x800'176a: 0xd008          BEQ.N    @800177e
  0x800'176c: 0x1ac9          SUBS     R1, R1, R3
  0x800'176e: 0xd31f          BCC.N    @80017b0
  0x800'1770: 0x07db          LSLS     R3, R3, #31
  0x800'1772: 0xbf48          IT       MI
  0x800'1774: 0xf800 0x2d01   STRBMI.W R2, [R0, #-0x1]!
  0x800'1778: 0xbf28          IT       CS
  0x800'177a: 0xf820 0x2d02   STRHCS.W R2, [R0, #-0x2]!
                @800177e:
  0x800'177e: 0x0013          MOVS     R3, R2
  0x800'1780: 0xb430          PUSH     {R4, R5}
  0x800'1782: 0x4614          MOV      R4, R2
  0x800'1784: 0x4615          MOV      R5, R2
                @8001786:
  0x800'1786: 0x3910          SUBS     R1, R1, #16            ; 0x10
  0x800'1788: 0xbf28          IT       CS
  0x800'178a: 0xe920 0x003c   STMDBCS  R0!, {R2-R5}
  0x800'178e: 0xd8fa          BHI.N    @8001786
  0x800'1790: 0x0749          LSLS     R1, R1, #29
  0x800'1792: 0xbf28          IT       CS
  0x800'1794: 0xe920 0x000c   STMDBCS  R0!, {R2, R3}
  0x800'1798: 0xbf48          IT       MI
  0x800'179a: 0xf840 0x2d04   STRMI.W  R2, [R0, #-0x4]!
  0x800'179e: 0x0089          LSLS     R1, R1, #2
  0x800'17a0: 0xbf28          IT       CS
  0x800'17a2: 0xf820 0x2d02   STRHCS.W R2, [R0, #-0x2]!
  0x800'17a6: 0xbf48          IT       MI
  0x800'17a8: 0xf800 0x2d01   STRBMI.W R2, [R0, #-0x1]!
  0x800'17ac: 0xbc30          POP      {R4, R5}
  0x800'17ae: 0x4770          BX       LR
                @80017b0:
  0x800'17b0: 0x18c9          ADDS     R1, R1, R3
  0x800'17b2: 0xbf18          IT       NE
  0x800'17b4: 0xf800 0x2d01   STRBNE.W R2, [R0, #-0x1]!
  0x800'17b8: 0x07cb          LSLS     R3, R1, #31
  0x800'17ba: 0xbf28          IT       CS
  0x800'17bc: 0xf800 0x2d01   STRBCS.W R2, [R0, #-0x1]!
  0x800'17c0: 0x4770          BX       LR
                `.text7`:
                __iar_copy_init3:
  0x800'17c2: 0xe00e          B.N      ??__iar_copy_init3_2   ; 0x800'17e2
                ??__iar_copy_init3_5:
  0x800'17c4: 0x6802          LDR      R2, [R0]
  0x800'17c6: 0x6843          LDR      R3, [R0, #0x4]
  0x800'17c8: 0x4402          ADD      R2, R2, R0
  0x800'17ca: 0x3008          ADDS     R0, R0, #8
  0x800'17cc: 0xea5f 0x7cc3   LSLS.W   R12, R3, #31
  0x800'17d0: 0xbf44          ITT      MI
  0x800'17d2: 0x444b          ADDMI    R3, R3, R9
  0x800'17d4: 0x1e5b          SUBMI    R3, R3, #1
                ??__iar_copy_init3_4:
  0x800'17d6: 0xf852 0xcb04   LDR.W    R12, [R2], #0x4
  0x800'17da: 0xf843 0xcb04   STR.W    R12, [R3], #0x4
  0x800'17de: 0x1f09          SUBS     R1, R1, #4
  0x800'17e0: 0xd1f9          BNE.N    ??__iar_copy_init3_4   ; 0x800'17d6
                ??__iar_copy_init3_2:
  0x800'17e2: 0xf850 0x1b04   LDR.W    R1, [R0], #0x4
  0x800'17e6: 0x2900          CMP      R1, #0
  0x800'17e8: 0xd1ec          BNE.N    ??__iar_copy_init3_5   ; 0x800'17c4
  0x800'17ea: 0x4770          BX       LR
                `.text8`:
                HAL_GPIO_Init:
  // void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
  // {
  0x800'17ec: 0xe92d 0x4ff8   PUSH.W   {R3-R11, LR}
  0x800'17f0: 0x4683          MOV      R11, R0
  0x800'17f2: 0x000c          MOVS     R4, R1
  //   uint32_t ioposition = 0x00U;
  0x800'17f4: 0x2500          MOVS     R5, #0
  //   uint32_t iocurrent = 0x00U;
  0x800'17f6: 0x2600          MOVS     R6, #0
  //   uint32_t temp = 0x00U;
  0x800'17f8: 0x2700          MOVS     R7, #0
  //   assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  0x800'17fa: 0xf8df 0x83e4   LDR.W    R8, ??DataTable6       ; 0x4002'0000
  0x800'17fe: 0x45c3          CMP      R11, R8
  0x800'1800: 0xd024          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1802: 0xf8df 0x03e0   LDR.W    R0, ??DataTable6_1     ; 0x4002'0400
  0x800'1806: 0x4583          CMP      R11, R0
  0x800'1808: 0xd020          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'180a: 0xf8df 0x03dc   LDR.W    R0, ??DataTable6_2     ; 0x4002'0800
  0x800'180e: 0x4583          CMP      R11, R0
  0x800'1810: 0xd01c          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1812: 0xf8df 0x03d8   LDR.W    R0, ??DataTable6_3     ; 0x4002'0c00
  0x800'1816: 0x4583          CMP      R11, R0
  0x800'1818: 0xd018          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'181a: 0xf8df 0x03d4   LDR.W    R0, ??DataTable6_4     ; 0x4002'1000
  0x800'181e: 0x4583          CMP      R11, R0
  0x800'1820: 0xd014          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1822: 0xf8df 0x03d0   LDR.W    R0, ??DataTable6_5     ; 0x4002'1400
  0x800'1826: 0x4583          CMP      R11, R0
  0x800'1828: 0xd010          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'182a: 0xf8df 0x03cc   LDR.W    R0, ??DataTable6_6     ; 0x4002'1800
  0x800'182e: 0x4583          CMP      R11, R0
  0x800'1830: 0xd00c          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1832: 0xf8df 0x03c8   LDR.W    R0, ??DataTable6_7     ; 0x4002'1c00
  0x800'1836: 0x4583          CMP      R11, R0
  0x800'1838: 0xd008          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'183a: 0xf8df 0x03c4   LDR.W    R0, ??DataTable6_8     ; 0x4002'2000
  0x800'183e: 0x4583          CMP      R11, R0
  0x800'1840: 0xd004          BEQ.N    ??HAL_GPIO_Init_0      ; 0x800'184c
  0x800'1842: 0x21ac          MOVS     R1, #172               ; 0xac
  0x800'1844: 0xf8df 0x03bc   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1848: 0xf7ff 0xfa7d   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_0:
  //   assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  0x800'184c: 0x6820          LDR      R0, [R4]
  0x800'184e: 0x0400          LSLS     R0, R0, #16
  0x800'1850: 0xd004          BEQ.N    ??HAL_GPIO_Init_1      ; 0x800'185c
  0x800'1852: 0x6820          LDR      R0, [R4]
  0x800'1854: 0x0c00          LSRS     R0, R0, #16
  0x800'1856: 0x0400          LSLS     R0, R0, #16
  0x800'1858: 0x2800          CMP      R0, #0
  0x800'185a: 0xd004          BEQ.N    ??HAL_GPIO_Init_2      ; 0x800'1866
                ??HAL_GPIO_Init_1:
  0x800'185c: 0x21ad          MOVS     R1, #173               ; 0xad
  0x800'185e: 0xf8df 0x03a4   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1862: 0xf7ff 0xfa70   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_2:
  //   assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  0x800'1866: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1868: 0x2800          CMP      R0, #0
  0x800'186a: 0xd02b          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'186c: 0x6860          LDR      R0, [R4, #0x4]
  0x800'186e: 0x2801          CMP      R0, #1
  0x800'1870: 0xd028          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1872: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1874: 0x2811          CMP      R0, #17                ; 0x11
  0x800'1876: 0xd025          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1878: 0x6860          LDR      R0, [R4, #0x4]
  0x800'187a: 0x2802          CMP      R0, #2
  0x800'187c: 0xd022          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'187e: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1880: 0x2812          CMP      R0, #18                ; 0x12
  0x800'1882: 0xd01f          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1884: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1886: 0xf5b0 0x1f88   CMP.W    R0, #1114112           ; 0x11'0000
  0x800'188a: 0xd01b          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'188c: 0x6860          LDR      R0, [R4, #0x4]
  0x800'188e: 0xf5b0 0x1f04   CMP.W    R0, #2162688           ; 0x21'0000
  0x800'1892: 0xd017          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'1894: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1896: 0xf5b0 0x1f44   CMP.W    R0, #3211264           ; 0x31'0000
  0x800'189a: 0xd013          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'189c: 0x6860          LDR      R0, [R4, #0x4]
  0x800'189e: 0xf5b0 0x1f90   CMP.W    R0, #1179648           ; 0x12'0000
  0x800'18a2: 0xd00f          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18a4: 0x6860          LDR      R0, [R4, #0x4]
  0x800'18a6: 0xf5b0 0x1f08   CMP.W    R0, #2228224           ; 0x22'0000
  0x800'18aa: 0xd00b          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18ac: 0x6860          LDR      R0, [R4, #0x4]
  0x800'18ae: 0xf5b0 0x1f48   CMP.W    R0, #3276800           ; 0x32'0000
  0x800'18b2: 0xd007          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18b4: 0x6860          LDR      R0, [R4, #0x4]
  0x800'18b6: 0x2803          CMP      R0, #3
  0x800'18b8: 0xd004          BEQ.N    ??HAL_GPIO_Init_3      ; 0x800'18c4
  0x800'18ba: 0x21ae          MOVS     R1, #174               ; 0xae
  0x800'18bc: 0xf8df 0x0344   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'18c0: 0xf7ff 0xfa41   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_3:
  //   for(position = 0U; position < GPIO_NUMBER; position++)
  0x800'18c4: 0xf05f 0x0900   MOVS.W   R9, #0
                ??HAL_GPIO_Init_4:
  //   for(position = 0U; position < GPIO_NUMBER; position++)
  0x800'18c8: 0xf1b9 0x0f10   CMP.W    R9, #16                ; 0x10
  0x800'18cc: 0xf080 0x8185   BCS.W    ??HAL_GPIO_Init_5      ; 0x800'1bda
  //     ioposition = 0x01U << position;
  0x800'18d0: 0xf05f 0x0a01   MOVS.W   R10, #1
  0x800'18d4: 0xfa1a 0xf009   LSLS.W   R0, R10, R9
  0x800'18d8: 0x0005          MOVS     R5, R0
  //     iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  0x800'18da: 0x6820          LDR      R0, [R4]
  0x800'18dc: 0x4028          ANDS     R0, R0, R5
  0x800'18de: 0x0006          MOVS     R6, R0
  //     if(iocurrent == ioposition)
  0x800'18e0: 0x42ae          CMP      R6, R5
  0x800'18e2: 0xf040 0x8177   BNE.W    ??HAL_GPIO_Init_6      ; 0x800'1bd4
  //       if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
  //           (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
  0x800'18e6: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'18e8: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'18ec: 0x2801          CMP      R0, #1
  0x800'18ee: 0xd004          BEQ.N    ??HAL_GPIO_Init_7      ; 0x800'18fa
  0x800'18f0: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'18f2: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'18f6: 0x2802          CMP      R0, #2
  0x800'18f8: 0xd12f          BNE.N    ??HAL_GPIO_Init_8      ; 0x800'195a
                ??HAL_GPIO_Init_7:
  //         assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
  0x800'18fa: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'18fc: 0x2800          CMP      R0, #0
  0x800'18fe: 0xd00d          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'1900: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1902: 0x2801          CMP      R0, #1
  0x800'1904: 0xd00a          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'1906: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1908: 0x2802          CMP      R0, #2
  0x800'190a: 0xd007          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'190c: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'190e: 0x2803          CMP      R0, #3
  0x800'1910: 0xd004          BEQ.N    ??HAL_GPIO_Init_9      ; 0x800'191c
  0x800'1912: 0x21c0          MOVS     R1, #192               ; 0xc0
  0x800'1914: 0xf8df 0x02ec   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1918: 0xf7ff 0xfa15   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_9:
  //         temp = GPIOx->OSPEEDR;
  0x800'191c: 0xf8db 0x1008   LDR.W    R1, [R11, #0x8]
  //         temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
  0x800'1920: 0x2203          MOVS     R2, #3
  0x800'1922: 0x4648          MOV      R0, R9
  0x800'1924: 0xb2c0          UXTB     R0, R0
  0x800'1926: 0x0040          LSLS     R0, R0, #1
  0x800'1928: 0x4082          LSLS     R2, R2, R0
  0x800'192a: 0x4391          BICS     R1, R1, R2
  //         temp |= (GPIO_Init->Speed << (position * 2U));
  0x800'192c: 0x68e2          LDR      R2, [R4, #0xc]
  0x800'192e: 0x4648          MOV      R0, R9
  0x800'1930: 0xb2c0          UXTB     R0, R0
  0x800'1932: 0x0040          LSLS     R0, R0, #1
  0x800'1934: 0x4082          LSLS     R2, R2, R0
  0x800'1936: 0x4311          ORRS     R1, R1, R2
  //         GPIOx->OSPEEDR = temp;
  0x800'1938: 0xf8cb 0x1008   STR.W    R1, [R11, #0x8]
  //         temp = GPIOx->OTYPER;
  0x800'193c: 0xf8db 0x0004   LDR.W    R0, [R11, #0x4]
  //         temp &= ~(GPIO_OTYPER_OT_0 << position) ;
  0x800'1940: 0xfa1a 0xfa09   LSLS.W   R10, R10, R9
  0x800'1944: 0xea30 0x000a   BICS.W   R0, R0, R10
  //         temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
  0x800'1948: 0x6862          LDR      R2, [R4, #0x4]
  0x800'194a: 0xf3c2 0x1200   UBFX     R2, R2, #4, #1
  0x800'194e: 0xfa12 0xf209   LSLS.W   R2, R2, R9
  0x800'1952: 0x4310          ORRS     R0, R0, R2
  0x800'1954: 0x0007          MOVS     R7, R0
  //         GPIOx->OTYPER = temp;
  0x800'1956: 0xf8cb 0x7004   STR.W    R7, [R11, #0x4]
                ??HAL_GPIO_Init_8:
  //       if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
  0x800'195a: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'195c: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'1960: 0x2803          CMP      R0, #3
  0x800'1962: 0xd01e          BEQ.N    ??HAL_GPIO_Init_10     ; 0x800'19a2
  //         assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
  0x800'1964: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'1966: 0x2800          CMP      R0, #0
  0x800'1968: 0xd00a          BEQ.N    ??HAL_GPIO_Init_11     ; 0x800'1980
  0x800'196a: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'196c: 0x2801          CMP      R0, #1
  0x800'196e: 0xd007          BEQ.N    ??HAL_GPIO_Init_11     ; 0x800'1980
  0x800'1970: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'1972: 0x2802          CMP      R0, #2
  0x800'1974: 0xd004          BEQ.N    ??HAL_GPIO_Init_11     ; 0x800'1980
  0x800'1976: 0x21d1          MOVS     R1, #209               ; 0xd1
  0x800'1978: 0xf8df 0x0288   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'197c: 0xf7ff 0xf9e3   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_11:
  //         temp = GPIOx->PUPDR;
  0x800'1980: 0xf8db 0x100c   LDR.W    R1, [R11, #0xc]
  //         temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
  0x800'1984: 0x2203          MOVS     R2, #3
  0x800'1986: 0x4648          MOV      R0, R9
  0x800'1988: 0xb2c0          UXTB     R0, R0
  0x800'198a: 0x0040          LSLS     R0, R0, #1
  0x800'198c: 0x4082          LSLS     R2, R2, R0
  0x800'198e: 0x4391          BICS     R1, R1, R2
  //         temp |= ((GPIO_Init->Pull) << (position * 2U));
  0x800'1990: 0x68a2          LDR      R2, [R4, #0x8]
  0x800'1992: 0x4648          MOV      R0, R9
  0x800'1994: 0xb2c0          UXTB     R0, R0
  0x800'1996: 0x0040          LSLS     R0, R0, #1
  0x800'1998: 0x4082          LSLS     R2, R2, R0
  0x800'199a: 0x4311          ORRS     R1, R1, R2
  0x800'199c: 0x000f          MOVS     R7, R1
  //         GPIOx->PUPDR = temp;
  0x800'199e: 0xf8cb 0x700c   STR.W    R7, [R11, #0xc]
                ??HAL_GPIO_Init_10:
  //       if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
  0x800'19a2: 0x7920          LDRB     R0, [R4, #0x4]
  0x800'19a4: 0xf010 0x0003   ANDS.W   R0, R0, #3
  0x800'19a8: 0x2802          CMP      R0, #2
  0x800'19aa: 0xf040 0x8084   BNE.W    ??HAL_GPIO_Init_12     ; 0x800'1ab6
  //         assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
  0x800'19ae: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19b0: 0x2800          CMP      R0, #0
  0x800'19b2: 0xd067          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19b4: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19b6: 0x2809          CMP      R0, #9
  0x800'19b8: 0xd064          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19ba: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19bc: 0x2800          CMP      R0, #0
  0x800'19be: 0xd061          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19c0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19c2: 0x2800          CMP      R0, #0
  0x800'19c4: 0xd05e          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19c6: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19c8: 0x2800          CMP      R0, #0
  0x800'19ca: 0xd05b          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19cc: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19ce: 0x2800          CMP      R0, #0
  0x800'19d0: 0xd058          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19d2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19d4: 0x2801          CMP      R0, #1
  0x800'19d6: 0xd055          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19d8: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19da: 0x2801          CMP      R0, #1
  0x800'19dc: 0xd052          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19de: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19e0: 0x2802          CMP      R0, #2
  0x800'19e2: 0xd04f          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19e4: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19e6: 0x2802          CMP      R0, #2
  0x800'19e8: 0xd04c          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19ea: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19ec: 0x2802          CMP      R0, #2
  0x800'19ee: 0xd049          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19f0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19f2: 0x2803          CMP      R0, #3
  0x800'19f4: 0xd046          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19f6: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19f8: 0x2804          CMP      R0, #4
  0x800'19fa: 0xd043          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'19fc: 0x6920          LDR      R0, [R4, #0x10]
  0x800'19fe: 0x2804          CMP      R0, #4
  0x800'1a00: 0xd040          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a02: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a04: 0x2804          CMP      R0, #4
  0x800'1a06: 0xd03d          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a08: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a0a: 0x2805          CMP      R0, #5
  0x800'1a0c: 0xd03a          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a0e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a10: 0x2805          CMP      R0, #5
  0x800'1a12: 0xd037          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a14: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a16: 0x2809          CMP      R0, #9
  0x800'1a18: 0xd034          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a1a: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a1c: 0x2806          CMP      R0, #6
  0x800'1a1e: 0xd031          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a20: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a22: 0x2809          CMP      R0, #9
  0x800'1a24: 0xd02e          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a26: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a28: 0x2807          CMP      R0, #7
  0x800'1a2a: 0xd02b          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a2c: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a2e: 0x2807          CMP      R0, #7
  0x800'1a30: 0xd028          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a32: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a34: 0x2807          CMP      R0, #7
  0x800'1a36: 0xd025          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a38: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a3a: 0x2808          CMP      R0, #8
  0x800'1a3c: 0xd022          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a3e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a40: 0x2808          CMP      R0, #8
  0x800'1a42: 0xd01f          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a44: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a46: 0x2808          CMP      R0, #8
  0x800'1a48: 0xd01c          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a4a: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a4c: 0x2809          CMP      R0, #9
  0x800'1a4e: 0xd019          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a50: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a52: 0x2809          CMP      R0, #9
  0x800'1a54: 0xd016          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a56: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a58: 0x280a          CMP      R0, #10                ; 0xa
  0x800'1a5a: 0xd013          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a5c: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a5e: 0x280a          CMP      R0, #10                ; 0xa
  0x800'1a60: 0xd010          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a62: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a64: 0x280c          CMP      R0, #12                ; 0xc
  0x800'1a66: 0xd00d          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a68: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a6a: 0x280c          CMP      R0, #12                ; 0xc
  0x800'1a6c: 0xd00a          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a6e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a70: 0x280c          CMP      R0, #12                ; 0xc
  0x800'1a72: 0xd007          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a74: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1a76: 0x280f          CMP      R0, #15                ; 0xf
  0x800'1a78: 0xd004          BEQ.N    ??HAL_GPIO_Init_13     ; 0x800'1a84
  0x800'1a7a: 0x21de          MOVS     R1, #222               ; 0xde
  0x800'1a7c: 0xf8df 0x0184   LDR.W    R0, ??DataTable6_9     ; ?_0
  0x800'1a80: 0xf7ff 0xf961   BL       assert_failed          ; 0x800'0d46
                ??HAL_GPIO_Init_13:
  //         temp = GPIOx->AFR[position >> 3U];
  0x800'1a84: 0x4648          MOV      R0, R9
  0x800'1a86: 0x08c0          LSRS     R0, R0, #3
  0x800'1a88: 0xeb0b 0x0080   ADD.W    R0, R11, R0, LSL #2
  0x800'1a8c: 0x6a01          LDR      R1, [R0, #0x20]
  //         temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
  0x800'1a8e: 0x220f          MOVS     R2, #15                ; 0xf
  0x800'1a90: 0xf019 0x0007   ANDS.W   R0, R9, #7
  0x800'1a94: 0xb2c0          UXTB     R0, R0
  0x800'1a96: 0x0080          LSLS     R0, R0, #2
  0x800'1a98: 0x4082          LSLS     R2, R2, R0
  0x800'1a9a: 0x4391          BICS     R1, R1, R2
  //         temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
  0x800'1a9c: 0x6922          LDR      R2, [R4, #0x10]
  0x800'1a9e: 0xf019 0x0007   ANDS.W   R0, R9, #7
  0x800'1aa2: 0xb2c0          UXTB     R0, R0
  0x800'1aa4: 0x0080          LSLS     R0, R0, #2
  0x800'1aa6: 0x4082          LSLS     R2, R2, R0
  0x800'1aa8: 0x4311          ORRS     R1, R1, R2
  0x800'1aaa: 0x000f          MOVS     R7, R1
  //         GPIOx->AFR[position >> 3U] = temp;
  0x800'1aac: 0x4648          MOV      R0, R9
  0x800'1aae: 0x08c0          LSRS     R0, R0, #3
  0x800'1ab0: 0xeb0b 0x0080   ADD.W    R0, R11, R0, LSL #2
  0x800'1ab4: 0x6207          STR      R7, [R0, #0x20]
                ??HAL_GPIO_Init_12:
  //       temp = GPIOx->MODER;
  0x800'1ab6: 0xf8db 0x1000   LDR.W    R1, [R11]
  //       temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
  0x800'1aba: 0x2203          MOVS     R2, #3
  0x800'1abc: 0x4648          MOV      R0, R9
  0x800'1abe: 0xb2c0          UXTB     R0, R0
  0x800'1ac0: 0x0040          LSLS     R0, R0, #1
  0x800'1ac2: 0x4082          LSLS     R2, R2, R0
  0x800'1ac4: 0x4391          BICS     R1, R1, R2
  //       temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
  0x800'1ac6: 0x7922          LDRB     R2, [R4, #0x4]
  0x800'1ac8: 0xf012 0x0203   ANDS.W   R2, R2, #3
  0x800'1acc: 0x4648          MOV      R0, R9
  0x800'1ace: 0xb2c0          UXTB     R0, R0
  0x800'1ad0: 0x0040          LSLS     R0, R0, #1
  0x800'1ad2: 0x4082          LSLS     R2, R2, R0
  0x800'1ad4: 0x4311          ORRS     R1, R1, R2
  0x800'1ad6: 0x000f          MOVS     R7, R1
  //       GPIOx->MODER = temp;
  0x800'1ad8: 0xf8cb 0x7000   STR.W    R7, [R11]
  //       if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
  0x800'1adc: 0x6860          LDR      R0, [R4, #0x4]
  0x800'1ade: 0xf410 0x3f40   TST.W    R0, #196608            ; 0x3'0000
  0x800'1ae2: 0xd077          BEQ.N    ??HAL_GPIO_Init_6      ; 0x800'1bd4
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1ae4: 0x2000          MOVS     R0, #0
  0x800'1ae6: 0x9000          STR      R0, [SP]
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1ae8: 0xf8df 0x111c   LDR.W    R1, ??DataTable6_10    ; 0x4002'3844
  0x800'1aec: 0x6808          LDR      R0, [R1]
  0x800'1aee: 0xf450 0x4080   ORRS.W   R0, R0, #16384         ; 0x4000
  0x800'1af2: 0x6008          STR      R0, [R1]
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1af4: 0x6808          LDR      R0, [R1]
  0x800'1af6: 0xf410 0x4080   ANDS.W   R0, R0, #16384         ; 0x4000
  0x800'1afa: 0x9000          STR      R0, [SP]
  //         __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'1afc: 0x9800          LDR      R0, [SP]
  //         temp = SYSCFG->EXTICR[position >> 2U];
  0x800'1afe: 0xf8df 0x110c   LDR.W    R1, ??DataTable6_11    ; 0x4001'3808
  0x800'1b02: 0x4648          MOV      R0, R9
  0x800'1b04: 0x0880          LSRS     R0, R0, #2
  0x800'1b06: 0xf851 0x2020   LDR.W    R2, [R1, R0, LSL #2]
  //         temp &= ~(0x0FU << (4U * (position & 0x03U)));
  0x800'1b0a: 0x230f          MOVS     R3, #15                ; 0xf
  0x800'1b0c: 0xf019 0x0003   ANDS.W   R0, R9, #3
  0x800'1b10: 0xb2c0          UXTB     R0, R0
  0x800'1b12: 0x0080          LSLS     R0, R0, #2
  0x800'1b14: 0x4083          LSLS     R3, R3, R0
  0x800'1b16: 0x439a          BICS     R2, R2, R3
  //         temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
  0x800'1b18: 0x45c3          CMP      R11, R8
  0x800'1b1a: 0xd101          BNE.N    ??HAL_GPIO_Init_14     ; 0x800'1b20
  0x800'1b1c: 0x2300          MOVS     R3, #0
  0x800'1b1e: 0xe02a          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_14:
  0x800'1b20: 0xf8df 0x00c0   LDR.W    R0, ??DataTable6_1     ; 0x4002'0400
  0x800'1b24: 0x4583          CMP      R11, R0
  0x800'1b26: 0xd101          BNE.N    ??HAL_GPIO_Init_16     ; 0x800'1b2c
  0x800'1b28: 0x2301          MOVS     R3, #1
  0x800'1b2a: 0xe024          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_16:
  0x800'1b2c: 0xf8df 0x00b8   LDR.W    R0, ??DataTable6_2     ; 0x4002'0800
  0x800'1b30: 0x4583          CMP      R11, R0
  0x800'1b32: 0xd101          BNE.N    ??HAL_GPIO_Init_17     ; 0x800'1b38
  0x800'1b34: 0x2302          MOVS     R3, #2
  0x800'1b36: 0xe01e          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_17:
  0x800'1b38: 0xf8df 0x00b0   LDR.W    R0, ??DataTable6_3     ; 0x4002'0c00
  0x800'1b3c: 0x4583          CMP      R11, R0
  0x800'1b3e: 0xd101          BNE.N    ??HAL_GPIO_Init_19     ; 0x800'1b44
  0x800'1b40: 0x2303          MOVS     R3, #3
  0x800'1b42: 0xe018          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_19:
  0x800'1b44: 0xf8df 0x00a8   LDR.W    R0, ??DataTable6_4     ; 0x4002'1000
  0x800'1b48: 0x4583          CMP      R11, R0
  0x800'1b4a: 0xd101          BNE.N    ??HAL_GPIO_Init_20     ; 0x800'1b50
  0x800'1b4c: 0x2304          MOVS     R3, #4
  0x800'1b4e: 0xe012          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_20:
  0x800'1b50: 0xf8df 0x00a0   LDR.W    R0, ??DataTable6_5     ; 0x4002'1400
  0x800'1b54: 0x4583          CMP      R11, R0
  0x800'1b56: 0xd101          BNE.N    ??HAL_GPIO_Init_22     ; 0x800'1b5c
  0x800'1b58: 0x2305          MOVS     R3, #5
  0x800'1b5a: 0xe00c          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_22:
  0x800'1b5c: 0xf8df 0x0098   LDR.W    R0, ??DataTable6_6     ; 0x4002'1800
  0x800'1b60: 0x4583          CMP      R11, R0
  0x800'1b62: 0xd101          BNE.N    ??HAL_GPIO_Init_23     ; 0x800'1b68
  0x800'1b64: 0x2306          MOVS     R3, #6
  0x800'1b66: 0xe006          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_23:
  0x800'1b68: 0xf8df 0x0090   LDR.W    R0, ??DataTable6_7     ; 0x4002'1c00
  0x800'1b6c: 0x4583          CMP      R11, R0
  0x800'1b6e: 0xd101          BNE.N    ??HAL_GPIO_Init_25     ; 0x800'1b74
  0x800'1b70: 0x2307          MOVS     R3, #7
  0x800'1b72: 0xe000          B.N      ??HAL_GPIO_Init_24     ; 0x800'1b76
                ??HAL_GPIO_Init_25:
  0x800'1b74: 0x2308          MOVS     R3, #8
                ??HAL_GPIO_Init_15:
                ??HAL_GPIO_Init_18:
                ??HAL_GPIO_Init_21:
                ??HAL_GPIO_Init_24:
  0x800'1b76: 0xb2db          UXTB     R3, R3
  0x800'1b78: 0xf019 0x0003   ANDS.W   R0, R9, #3
  0x800'1b7c: 0xb2c0          UXTB     R0, R0
  0x800'1b7e: 0x0080          LSLS     R0, R0, #2
  0x800'1b80: 0x4083          LSLS     R3, R3, R0
  0x800'1b82: 0x431a          ORRS     R2, R2, R3
  //         SYSCFG->EXTICR[position >> 2U] = temp;
  0x800'1b84: 0x4648          MOV      R0, R9
  0x800'1b86: 0x0880          LSRS     R0, R0, #2
  0x800'1b88: 0xf841 0x2020   STR.W    R2, [R1, R0, LSL #2]
  //         temp = EXTI->RTSR;
  0x800'1b8c: 0xf8df 0x1080   LDR.W    R1, ??DataTable6_12    ; 0x4001'3c08
  0x800'1b90: 0x6808          LDR      R0, [R1]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1b92: 0x43b0          BICS     R0, R0, R6
  //         if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
  0x800'1b94: 0x6863          LDR      R3, [R4, #0x4]
  0x800'1b96: 0x02db          LSLS     R3, R3, #11
  0x800'1b98: 0xd500          BPL.N    ??HAL_GPIO_Init_26     ; 0x800'1b9c
  //           temp |= iocurrent;
  0x800'1b9a: 0x4330          ORRS     R0, R0, R6
                ??HAL_GPIO_Init_26:
  //         EXTI->RTSR = temp;
  0x800'1b9c: 0x6008          STR      R0, [R1]
  //         temp = EXTI->FTSR;
  0x800'1b9e: 0xf8df 0x1074   LDR.W    R1, ??DataTable6_13    ; 0x4001'3c0c
  0x800'1ba2: 0x680a          LDR      R2, [R1]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1ba4: 0x43b2          BICS     R2, R2, R6
  //         if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
  0x800'1ba6: 0x6863          LDR      R3, [R4, #0x4]
  0x800'1ba8: 0x029b          LSLS     R3, R3, #10
  0x800'1baa: 0xd500          BPL.N    ??HAL_GPIO_Init_27     ; 0x800'1bae
  //           temp |= iocurrent;
  0x800'1bac: 0x4332          ORRS     R2, R2, R6
                ??HAL_GPIO_Init_27:
  //         EXTI->FTSR = temp;
  0x800'1bae: 0x600a          STR      R2, [R1]
  //         temp = EXTI->EMR;
  0x800'1bb0: 0xf8df 0x0064   LDR.W    R0, ??DataTable6_14    ; 0x4001'3c04
  0x800'1bb4: 0x6801          LDR      R1, [R0]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1bb6: 0x43b1          BICS     R1, R1, R6
  //         if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
  0x800'1bb8: 0x6863          LDR      R3, [R4, #0x4]
  0x800'1bba: 0x039b          LSLS     R3, R3, #14
  0x800'1bbc: 0xd500          BPL.N    ??HAL_GPIO_Init_28     ; 0x800'1bc0
  //           temp |= iocurrent;
  0x800'1bbe: 0x4331          ORRS     R1, R1, R6
                ??HAL_GPIO_Init_28:
  //         EXTI->EMR = temp;
  0x800'1bc0: 0x6001          STR      R1, [R0]
  //         temp = EXTI->IMR;
  0x800'1bc2: 0xf8df 0x0058   LDR.W    R0, ??DataTable6_15    ; 0x4001'3c00
  0x800'1bc6: 0x6807          LDR      R7, [R0]
  //         temp &= ~((uint32_t)iocurrent);
  0x800'1bc8: 0x43b7          BICS     R7, R7, R6
  //         if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
  0x800'1bca: 0x6862          LDR      R2, [R4, #0x4]
  0x800'1bcc: 0x03d2          LSLS     R2, R2, #15
  0x800'1bce: 0xd500          BPL.N    ??HAL_GPIO_Init_29     ; 0x800'1bd2
  //           temp |= iocurrent;
  0x800'1bd0: 0x4337          ORRS     R7, R7, R6
                ??HAL_GPIO_Init_29:
  //         EXTI->IMR = temp;
  0x800'1bd2: 0x6007          STR      R7, [R0]
                ??HAL_GPIO_Init_6:
  //   for(position = 0U; position < GPIO_NUMBER; position++)
  0x800'1bd4: 0xf119 0x0901   ADDS.W   R9, R9, #1
  0x800'1bd8: 0xe676          B.N      ??HAL_GPIO_Init_4      ; 0x800'18c8
                ??HAL_GPIO_Init_5:
  // }
  0x800'1bda: 0xe8bd 0x8ff1   POP.W    {R0, R4-R11, PC}
  0x800'1bde: 0x0000          MOVS     R0, R0
                `$d.32`:
                ??DataTable6:
  0x800'1be0: 0x4002'0000     DC32     0x4002'0000            ; '...@'
                ??DataTable6_1:
  0x800'1be4: 0x4002'0400     DC32     0x4002'0400            ; '...@'
                ??DataTable6_2:
  0x800'1be8: 0x4002'0800     DC32     0x4002'0800            ; '...@'
                ??DataTable6_3:
  0x800'1bec: 0x4002'0c00     DC32     0x4002'0c00            ; '...@'
                ??DataTable6_4:
  0x800'1bf0: 0x4002'1000     DC32     0x4002'1000            ; '...@'
                ??DataTable6_5:
  0x800'1bf4: 0x4002'1400     DC32     0x4002'1400            ; '...@'
                ??DataTable6_6:
  0x800'1bf8: 0x4002'1800     DC32     0x4002'1800            ; '...@'
                ??DataTable6_7:
  0x800'1bfc: 0x4002'1c00     DC32     0x4002'1c00            ; '...@'
                ??DataTable6_8:
  0x800'1c00: 0x4002'2000     DC32     0x4002'2000            ; '. .@'
                ??DataTable6_9:
  0x800'1c04: 0x0800'2960     DC32     ?_0
                ??DataTable6_10:
  0x800'1c08: 0x4002'3844     DC32     0x4002'3844            ; 'D8.@'
                ??DataTable6_11:
  0x800'1c0c: 0x4001'3808     DC32     0x4001'3808            ; '.8.@'
                ??DataTable6_12:
  0x800'1c10: 0x4001'3c08     DC32     0x4001'3c08            ; '.<.@'
                ??DataTable6_13:
  0x800'1c14: 0x4001'3c0c     DC32     0x4001'3c0c            ; '.<.@'
                ??DataTable6_14:
  0x800'1c18: 0x4001'3c04     DC32     0x4001'3c04            ; '.<.@'
                ??DataTable6_15:
  0x800'1c1c: 0x4001'3c00     DC32     0x4001'3c00            ; '.<.@'
                $t:
                `.text8`:
                __NVIC_SetPriorityGrouping:
  // __STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
  // {
  0x800'1c20: 0xb410          PUSH     {R4}
  //   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
  0x800'1c22: 0xf010 0x0207   ANDS.W   R2, R0, #7
  //   reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  0x800'1c26: 0xf8df 0x3148   LDR.W    R3, ??DataTable24      ; 0xe000'ed0c
  0x800'1c2a: 0x681c          LDR      R4, [R3]
  //   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  0x800'1c2c: 0xf64f 0x01ff   MOVW     R1, #63743             ; 0xf8ff
  0x800'1c30: 0x400c          ANDS     R4, R4, R1
  //   reg_value  =  (reg_value                                   |
  //                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
  //                 (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  0x800'1c32: 0xea54 0x2402   ORRS.W   R4, R4, R2, LSL #8
  0x800'1c36: 0xf8df 0x113c   LDR.W    R1, ??DataTable24_1    ; 0x5fa'0000
  0x800'1c3a: 0x430c          ORRS     R4, R4, R1
  //   SCB->AIRCR =  reg_value;
  0x800'1c3c: 0x601c          STR      R4, [R3]
  // }
  0x800'1c3e: 0xbc10          POP      {R4}
  0x800'1c40: 0x4770          BX       LR
                `.text_4`:
                __NVIC_GetPriorityGrouping:
  //   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
  0x800'1c42: 0xf8df 0x012c   LDR.W    R0, ??DataTable24      ; 0xe000'ed0c
  0x800'1c46: 0x6800          LDR      R0, [R0]
  0x800'1c48: 0xf3c0 0x2002   UBFX     R0, R0, #8, #3
  0x800'1c4c: 0x4770          BX       LR
  0x800'1c4e: 0x0000          MOVS     R0, R0
                `.text_5`:
                __NVIC_EnableIRQ:
  //   if ((int32_t)(IRQn) >= 0)
  0x800'1c50: 0x0001          MOVS     R1, R0
  0x800'1c52: 0xb249          SXTB     R1, R1
  0x800'1c54: 0x2900          CMP      R1, #0
  0x800'1c56: 0xd40a          BMI.N    ??__NVIC_EnableIRQ_0   ; 0x800'1c6e
  //     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  0x800'1c58: 0x2201          MOVS     R2, #1
  0x800'1c5a: 0xf010 0x011f   ANDS.W   R1, R0, #31            ; 0x1f
  0x800'1c5e: 0x408a          LSLS     R2, R2, R1
  0x800'1c60: 0xf8df 0x3114   LDR.W    R3, ??DataTable24_2    ; 0xe000'e100
  0x800'1c64: 0x0001          MOVS     R1, R0
  0x800'1c66: 0xb249          SXTB     R1, R1
  0x800'1c68: 0x0949          LSRS     R1, R1, #5
  0x800'1c6a: 0xf843 0x2021   STR.W    R2, [R3, R1, LSL #2]
                ??__NVIC_EnableIRQ_0:
  // }
  0x800'1c6e: 0x4770          BX       LR
                `.text_11`:
                __NVIC_SetPriority:
  // __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
  // {
  0x800'1c70: 0xb410          PUSH     {R4}
  //   if ((int32_t)(IRQn) >= 0)
  0x800'1c72: 0x0002          MOVS     R2, R0
  0x800'1c74: 0xb252          SXTB     R2, R2
  0x800'1c76: 0x2a00          CMP      R2, #0
  0x800'1c78: 0xd406          BMI.N    ??__NVIC_SetPriority_0 ; 0x800'1c88
  //     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  0x800'1c7a: 0x010c          LSLS     R4, R1, #4
  0x800'1c7c: 0xf8df 0x30fc   LDR.W    R3, ??DataTable24_7    ; 0xe000'e400
  0x800'1c80: 0x0002          MOVS     R2, R0
  0x800'1c82: 0xb252          SXTB     R2, R2
  0x800'1c84: 0x549c          STRB     R4, [R3, R2]
  0x800'1c86: 0xe009          B.N      ??__NVIC_SetPriority_1 ; 0x800'1c9c
                ??__NVIC_SetPriority_0:
  //     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  0x800'1c88: 0x010a          LSLS     R2, R1, #4
  0x800'1c8a: 0xf8df 0x40f4   LDR.W    R4, ??DataTable24_8    ; 0xe000'ed18
  0x800'1c8e: 0x0003          MOVS     R3, R0
  0x800'1c90: 0xb25b          SXTB     R3, R3
  0x800'1c92: 0xf013 0x030f   ANDS.W   R3, R3, #15            ; 0xf
  0x800'1c96: 0x4423          ADD      R3, R3, R4
  0x800'1c98: 0xf803 0x2c04   STRB.W   R2, [R3, #-0x4]
                ??__NVIC_SetPriority_1:
  // }
  0x800'1c9c: 0xbc10          POP      {R4}
  0x800'1c9e: 0x4770          BX       LR
                `.text_13`:
                NVIC_EncodePriority:
  // __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
  // {
  0x800'1ca0: 0xb470          PUSH     {R4-R6}
  0x800'1ca2: 0x0003          MOVS     R3, R0
  //   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  0x800'1ca4: 0xf013 0x0407   ANDS.W   R4, R3, #7
  //   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  0x800'1ca8: 0xf1d4 0x0007   RSBS.W   R0, R4, #7
  0x800'1cac: 0x2805          CMP      R0, #5
  0x800'1cae: 0xd301          BCC.N    ??NVIC_EncodePriority_0
                                                              ; 0x800'1cb4
  0x800'1cb0: 0x2004          MOVS     R0, #4
  0x800'1cb2: 0xe001          B.N      ??NVIC_EncodePriority_1
                                                              ; 0x800'1cb8
                ??NVIC_EncodePriority_0:
  0x800'1cb4: 0xf1d4 0x0007   RSBS.W   R0, R4, #7
                ??NVIC_EncodePriority_1:
  //   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
  0x800'1cb8: 0x1d25          ADDS     R5, R4, #4
  0x800'1cba: 0x2d07          CMP      R5, #7
  0x800'1cbc: 0xd201          BCS.N    ??NVIC_EncodePriority_2
                                                              ; 0x800'1cc2
  0x800'1cbe: 0x2600          MOVS     R6, #0
  0x800'1cc0: 0xe000          B.N      ??NVIC_EncodePriority_3
                                                              ; 0x800'1cc4
                ??NVIC_EncodePriority_2:
  0x800'1cc2: 0x1ee6          SUBS     R6, R4, #3
                ??NVIC_EncodePriority_3:
  //   return (
  //            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  //            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
  //          );
  0x800'1cc4: 0x2501          MOVS     R5, #1
  0x800'1cc6: 0xfa15 0xf000   LSLS.W   R0, R5, R0
  0x800'1cca: 0x1e40          SUBS     R0, R0, #1
  0x800'1ccc: 0x4001          ANDS     R1, R1, R0
  0x800'1cce: 0x40b1          LSLS     R1, R1, R6
  0x800'1cd0: 0xfa15 0xf606   LSLS.W   R6, R5, R6
  0x800'1cd4: 0x1e76          SUBS     R6, R6, #1
  0x800'1cd6: 0x4032          ANDS     R2, R2, R6
  0x800'1cd8: 0x4311          ORRS     R1, R1, R2
  0x800'1cda: 0x0008          MOVS     R0, R1
  0x800'1cdc: 0xbc70          POP      {R4-R6}
  0x800'1cde: 0x4770          BX       LR
                `.text_17`:
                HAL_NVIC_SetPriorityGrouping:
  // void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
  // {
  0x800'1ce0: 0xb510          PUSH     {R4, LR}
  0x800'1ce2: 0x0004          MOVS     R4, R0
  //   assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  0x800'1ce4: 0x2c07          CMP      R4, #7
  0x800'1ce6: 0xd00c          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1ce8: 0x2c06          CMP      R4, #6
  0x800'1cea: 0xd00a          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cec: 0x2c05          CMP      R4, #5
  0x800'1cee: 0xd008          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cf0: 0x2c04          CMP      R4, #4
  0x800'1cf2: 0xd006          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cf4: 0x2c03          CMP      R4, #3
  0x800'1cf6: 0xd004          BEQ.N    ??HAL_NVIC_SetPriorityGrouping_0
                                                              ; 0x800'1d02
  0x800'1cf8: 0x2190          MOVS     R1, #144               ; 0x90
  0x800'1cfa: 0xf8df 0x0088   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1cfe: 0xf7ff 0xf822   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_SetPriorityGrouping_0:
  //   NVIC_SetPriorityGrouping(PriorityGroup);
  0x800'1d02: 0x0020          MOVS     R0, R4
  0x800'1d04: 0xf7ff 0xff8c   BL       __NVIC_SetPriorityGrouping
                                                              ; 0x800'1c20
  // }
  0x800'1d08: 0xbd10          POP      {R4, PC}
                `.text_18`:
                HAL_NVIC_SetPriority:
  // void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
  // {
  0x800'1d0a: 0xe92d 0x41f0   PUSH.W   {R4-R8, LR}
  0x800'1d0e: 0x4680          MOV      R8, R0
  0x800'1d10: 0x000c          MOVS     R4, R1
  0x800'1d12: 0x0015          MOVS     R5, R2
  //   uint32_t prioritygroup = 0x00U;
  0x800'1d14: 0x2600          MOVS     R6, #0
  //   assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  0x800'1d16: 0x2d10          CMP      R5, #16                ; 0x10
  0x800'1d18: 0xd304          BCC.N    ??HAL_NVIC_SetPriority_0
                                                              ; 0x800'1d24
  0x800'1d1a: 0x21a8          MOVS     R1, #168               ; 0xa8
  0x800'1d1c: 0xf8df 0x0064   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1d20: 0xf7ff 0xf811   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_SetPriority_0:
  //   assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  0x800'1d24: 0x2c10          CMP      R4, #16                ; 0x10
  0x800'1d26: 0xd304          BCC.N    ??HAL_NVIC_SetPriority_1
                                                              ; 0x800'1d32
  0x800'1d28: 0x21a9          MOVS     R1, #169               ; 0xa9
  0x800'1d2a: 0xf8df 0x0058   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1d2e: 0xf7ff 0xf80a   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_SetPriority_1:
  //   prioritygroup = NVIC_GetPriorityGrouping();
  0x800'1d32: 0xf7ff 0xff86   BL       __NVIC_GetPriorityGrouping
                                                              ; 0x800'1c42
  0x800'1d36: 0x0007          MOVS     R7, R0
  //   NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
  0x800'1d38: 0x002a          MOVS     R2, R5
  0x800'1d3a: 0x0021          MOVS     R1, R4
  0x800'1d3c: 0x0038          MOVS     R0, R7
  0x800'1d3e: 0xf7ff 0xffaf   BL       NVIC_EncodePriority    ; 0x800'1ca0
  0x800'1d42: 0x0001          MOVS     R1, R0
  0x800'1d44: 0x4640          MOV      R0, R8
  0x800'1d46: 0xb240          SXTB     R0, R0
  0x800'1d48: 0xf7ff 0xff92   BL       __NVIC_SetPriority     ; 0x800'1c70
  // }
  0x800'1d4c: 0xe8bd 0x81f0   POP.W    {R4-R8, PC}
                `.text_19`:
                HAL_NVIC_EnableIRQ:
  // void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
  // {
  0x800'1d50: 0xb510          PUSH     {R4, LR}
  0x800'1d52: 0x0004          MOVS     R4, R0
  //   assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  0x800'1d54: 0x0020          MOVS     R0, R4
  0x800'1d56: 0xb240          SXTB     R0, R0
  0x800'1d58: 0x2800          CMP      R0, #0
  0x800'1d5a: 0xd504          BPL.N    ??HAL_NVIC_EnableIRQ_0 ; 0x800'1d66
  0x800'1d5c: 0x21bc          MOVS     R1, #188               ; 0xbc
  0x800'1d5e: 0xf8df 0x0024   LDR.W    R0, ??DataTable24_13   ; ?_0
  0x800'1d62: 0xf7fe 0xfff0   BL       assert_failed          ; 0x800'0d46
                ??HAL_NVIC_EnableIRQ_0:
  //   NVIC_EnableIRQ(IRQn);
  0x800'1d66: 0x0020          MOVS     R0, R4
  0x800'1d68: 0xb240          SXTB     R0, R0
  0x800'1d6a: 0xf7ff 0xff71   BL       __NVIC_EnableIRQ       ; 0x800'1c50
  // }
  0x800'1d6e: 0xbd10          POP      {R4, PC}
                `$d.32`:
                ??DataTable24:
  0x800'1d70: 0xe000'ed0c     DC32     0xe000'ed0c            ; '....'
                ??DataTable24_1:
  0x800'1d74: 0x05fa'0000     DC32     0x5fa'0000             ; '....'
                ??DataTable24_2:
  0x800'1d78: 0xe000'e100     DC32     0xe000'e100            ; '....'
                ??DataTable24_7:
  0x800'1d7c: 0xe000'e400     DC32     0xe000'e400            ; '....'
                ??DataTable24_8:
  0x800'1d80: 0xe000'ed18     DC32     0xe000'ed18            ; '....'
                ??DataTable24_13:
  0x800'1d84: 0x0800'299c     DC32     ?_0
                $t:
                `.text6`:
                __aeabi_ldiv0:
  0x800'1d88: 0x4770          BX       LR
                `.text6`:
                out:
  0x800'1d8a: 0xb570          PUSH     {R4-R6, LR}
  0x800'1d8c: 0x4606          MOV      R6, R0
  0x800'1d8e: 0x001c          MOVS     R4, R3
  0x800'1d90: 0x4608          MOV      R0, R1
  0x800'1d92: 0x4615          MOV      R5, R2
  0x800'1d94: 0xd004          BEQ.N    ??out_0                ; 0x800'1da0
                ??out_1:
  0x800'1d96: 0xf815 0x1b01   LDRB.W   R1, [R5], #0x1
  0x800'1d9a: 0x47b0          BLX      R6
  0x800'1d9c: 0x1e64          SUBS     R4, R4, #1
  0x800'1d9e: 0xd1fa          BNE.N    ??out_1                ; 0x800'1d96
                ??out_0:
  0x800'1da0: 0xbd70          POP      {R4-R6, PC}
                `.text_3`:
                _PrintfTiny:
  0x800'1da2: 0xe92d 0x46fc   PUSH.W   {R2-R7, R9, R10, LR}
  0x800'1da6: 0xb083          SUB      SP, SP, #0xc
  0x800'1da8: 0x4681          MOV      R9, R0
  0x800'1daa: 0x468a          MOV      R10, R1
  0x800'1dac: 0x4616          MOV      R6, R2
  0x800'1dae: 0x461f          MOV      R7, R3
  0x800'1db0: 0xe007          B.N      ??_PrintfTiny_4        ; 0x800'1dc2
                ??_PrintfTiny_6:
  0x800'1db2: 0x2301          MOVS     R3, #1
  0x800'1db4: 0x4632          MOV      R2, R6
  0x800'1db6: 0x4651          MOV      R1, R10
  0x800'1db8: 0x4648          MOV      R0, R9
  0x800'1dba: 0xf7ff 0xffe6   BL       out                    ; 0x800'1d8a
  0x800'1dbe: 0x4682          MOV      R10, R0
  0x800'1dc0: 0x1c76          ADDS     R6, R6, #1
                ??_PrintfTiny_4:
  0x800'1dc2: 0x7830          LDRB     R0, [R6]
  0x800'1dc4: 0xb1e0          CBZ      R0, ??_PrintfTiny_5    ; 0x800'1e00
  0x800'1dc6: 0x2825          CMP      R0, #37                ; 0x25
  0x800'1dc8: 0xd1f3          BNE.N    ??_PrintfTiny_6        ; 0x800'1db2
  0x800'1dca: 0x7871          LDRB     R1, [R6, #0x1]
  0x800'1dcc: 0x1cb6          ADDS     R6, R6, #2
  0x800'1dce: 0x2925          CMP      R1, #37                ; 0x25
  0x800'1dd0: 0xd012          BEQ.N    ??_PrintfTiny_7        ; 0x800'1df8
  0x800'1dd2: 0x2958          CMP      R1, #88                ; 0x58
  0x800'1dd4: 0xd05a          BEQ.N    ??_PrintfTiny_8        ; 0x800'1e8c
  0x800'1dd6: 0x2963          CMP      R1, #99                ; 0x63
  0x800'1dd8: 0xd015          BEQ.N    ??_PrintfTiny_9        ; 0x800'1e06
  0x800'1dda: 0x2964          CMP      R1, #100               ; 0x64
  0x800'1ddc: 0xbf18          IT       NE
  0x800'1dde: 0x2969          CMPNE    R1, #105               ; 0x69
  0x800'1de0: 0xd017          BEQ.N    ??_PrintfTiny_10       ; 0x800'1e12
  0x800'1de2: 0x296f          CMP      R1, #111               ; 0x6f
  0x800'1de4: 0xd052          BEQ.N    ??_PrintfTiny_8        ; 0x800'1e8c
  0x800'1de6: 0x2970          CMP      R1, #112               ; 0x70
  0x800'1de8: 0xd055          BEQ.N    ??_PrintfTiny_11       ; 0x800'1e96
  0x800'1dea: 0x2973          CMP      R1, #115               ; 0x73
  0x800'1dec: 0xd059          BEQ.N    ??_PrintfTiny_12       ; 0x800'1ea2
  0x800'1dee: 0x2975          CMP      R1, #117               ; 0x75
  0x800'1df0: 0xbf18          IT       NE
  0x800'1df2: 0x2978          CMPNE    R1, #120               ; 0x78
  0x800'1df4: 0xd04a          BEQ.N    ??_PrintfTiny_8        ; 0x800'1e8c
  0x800'1df6: 0xe7e4          B.N      ??_PrintfTiny_4        ; 0x800'1dc2
                ??_PrintfTiny_7:
  0x800'1df8: 0x4650          MOV      R0, R10
  0x800'1dfa: 0x47c8          BLX      R9
                ??_PrintfTiny_20:
  0x800'1dfc: 0x4682          MOV      R10, R0
  0x800'1dfe: 0xe7e0          B.N      ??_PrintfTiny_4        ; 0x800'1dc2
                ??_PrintfTiny_5:
  0x800'1e00: 0xb005          ADD      SP, SP, #0x14
  0x800'1e02: 0xe8bd 0x86f0   POP.W    {R4-R7, R9, R10, PC}
                ??_PrintfTiny_9:
  0x800'1e06: 0x6839          LDR      R1, [R7]
  0x800'1e08: 0xf851 0x0b04   LDR.W    R0, [R1], #0x4
  0x800'1e0c: 0x6039          STR      R1, [R7]
  0x800'1e0e: 0xb2c1          UXTB     R1, R0
  0x800'1e10: 0xe7f2          B.N      ??_PrintfTiny_7        ; 0x800'1df8
                ??_PrintfTiny_10:
  0x800'1e12: 0x6838          LDR      R0, [R7]
  0x800'1e14: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1e18: 0x6038          STR      R0, [R7]
  0x800'1e1a: 0x2d00          CMP      R5, #0
  0x800'1e1c: 0xd503          BPL.N    ??_PrintfTiny_13       ; 0x800'1e26
  0x800'1e1e: 0x212d          MOVS     R1, #45                ; 0x2d
  0x800'1e20: 0x4650          MOV      R0, R10
  0x800'1e22: 0x47c8          BLX      R9
  0x800'1e24: 0x4682          MOV      R10, R0
                ??_PrintfTiny_13:
  0x800'1e26: 0x2164          MOVS     R1, #100               ; 0x64
                ??_PrintfTiny_22:
  0x800'1e28: 0x296f          CMP      R1, #111               ; 0x6f
  0x800'1e2a: 0xbf08          IT       EQ
  0x800'1e2c: 0x2208          MOVEQ    R2, #8
  0x800'1e2e: 0xd005          BEQ.N    ??_PrintfTiny_14       ; 0x800'1e3c
  0x800'1e30: 0xf041 0x0020   ORR.W    R0, R1, #32            ; 0x20
  0x800'1e34: 0x2878          CMP      R0, #120               ; 0x78
  0x800'1e36: 0xbf14          ITE      NE
  0x800'1e38: 0x220a          MOVNE    R2, #10                ; 0xa
  0x800'1e3a: 0x2210          MOVEQ    R2, #16                ; 0x10
                ??_PrintfTiny_14:
  0x800'1e3c: 0x240b          MOVS     R4, #11                ; 0xb
  0x800'1e3e: 0x2964          CMP      R1, #100               ; 0x64
  0x800'1e40: 0x4628          MOV      R0, R5
  0x800'1e42: 0xd102          BNE.N    ??_PrintfTiny_15       ; 0x800'1e4a
  0x800'1e44: 0x2d00          CMP      R5, #0
  0x800'1e46: 0xbf48          IT       MI
  0x800'1e48: 0x4240          RSBMI    R0, R0, #0
                ??_PrintfTiny_15:
  0x800'1e4a: 0xfbb0 0xf3f2   UDIV     R3, R0, R2
  0x800'1e4e: 0xfb02 0x0013   MLS      R0, R2, R3, R0
  0x800'1e52: 0x1e64          SUBS     R4, R4, #1
  0x800'1e54: 0x3030          ADDS     R0, R0, #48            ; 0x30
  0x800'1e56: 0x283a          CMP      R0, #58                ; 0x3a
  0x800'1e58: 0xda04          BGE.N    ??_PrintfTiny_16       ; 0x800'1e64
                ??_PrintfTiny_19:
  0x800'1e5a: 0xf80d 0x0004   STRB.W   R0, [SP, R4]
  0x800'1e5e: 0x0018          MOVS     R0, R3
  0x800'1e60: 0xd103          BNE.N    ??_PrintfTiny_17       ; 0x800'1e6a
  0x800'1e62: 0xe004          B.N      ??_PrintfTiny_18       ; 0x800'1e6e
                ??_PrintfTiny_16:
  0x800'1e64: 0x1840          ADDS     R0, R0, R1
  0x800'1e66: 0x3851          SUBS     R0, R0, #81            ; 0x51
  0x800'1e68: 0xe7f7          B.N      ??_PrintfTiny_19       ; 0x800'1e5a
                ??_PrintfTiny_17:
  0x800'1e6a: 0x2c00          CMP      R4, #0
  0x800'1e6c: 0xdced          BGT.N    ??_PrintfTiny_15       ; 0x800'1e4a
                ??_PrintfTiny_18:
  0x800'1e6e: 0x4261          RSBS     R1, R4, #0
  0x800'1e70: 0xf111 0x0f0b   CMN.W    R1, #11                ; 0xb
  0x800'1e74: 0xeb0d 0x0504   ADD.W    R5, SP, R4
  0x800'1e78: 0x4650          MOV      R0, R10
  0x800'1e7a: 0xd0bf          BEQ.N    ??_PrintfTiny_20       ; 0x800'1dfc
  0x800'1e7c: 0xf1c4 0x040b   RSB.W    R4, R4, #11            ; 0xb
                ??_PrintfTiny_21:
  0x800'1e80: 0xf815 0x1b01   LDRB.W   R1, [R5], #0x1
  0x800'1e84: 0x47c8          BLX      R9
  0x800'1e86: 0x1e64          SUBS     R4, R4, #1
  0x800'1e88: 0xd1fa          BNE.N    ??_PrintfTiny_21       ; 0x800'1e80
  0x800'1e8a: 0xe7b7          B.N      ??_PrintfTiny_20       ; 0x800'1dfc
                ??_PrintfTiny_8:
  0x800'1e8c: 0x6838          LDR      R0, [R7]
  0x800'1e8e: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1e92: 0x6038          STR      R0, [R7]
  0x800'1e94: 0xe7c8          B.N      ??_PrintfTiny_22       ; 0x800'1e28
                ??_PrintfTiny_11:
  0x800'1e96: 0x6838          LDR      R0, [R7]
  0x800'1e98: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1e9c: 0x6038          STR      R0, [R7]
  0x800'1e9e: 0x2178          MOVS     R1, #120               ; 0x78
  0x800'1ea0: 0xe7c2          B.N      ??_PrintfTiny_22       ; 0x800'1e28
                ??_PrintfTiny_12:
  0x800'1ea2: 0x6838          LDR      R0, [R7]
  0x800'1ea4: 0xf850 0x5b04   LDR.W    R5, [R0], #0x4
  0x800'1ea8: 0x6038          STR      R0, [R7]
  0x800'1eaa: 0x4628          MOV      R0, R5
  0x800'1eac: 0xf000 0xf812   BL       strlen                 ; 0x800'1ed4
  0x800'1eb0: 0x0004          MOVS     R4, R0
  0x800'1eb2: 0x4650          MOV      R0, R10
  0x800'1eb4: 0xd0a2          BEQ.N    ??_PrintfTiny_20       ; 0x800'1dfc
                ??_PrintfTiny_23:
  0x800'1eb6: 0xf815 0x1b01   LDRB.W   R1, [R5], #0x1
  0x800'1eba: 0x47c8          BLX      R9
  0x800'1ebc: 0x1e64          SUBS     R4, R4, #1
  0x800'1ebe: 0xd1fa          BNE.N    ??_PrintfTiny_23       ; 0x800'1eb6
  0x800'1ec0: 0xe79c          B.N      ??_PrintfTiny_20       ; 0x800'1dfc
                `.text10`:
                HAL_TIM_Base_MspInit:
  // }
  0x800'1ec2: 0x4770          BX       LR
                `.text40`:
                HAL_TIM_IC_CaptureCallback:
  // }
  0x800'1ec4: 0x4770          BX       LR
                `.text38`:
                HAL_TIM_OC_DelayElapsedCallback:
  // }
  0x800'1ec6: 0x4770          BX       LR
                `.text44`:
                HAL_TIM_PWM_PulseFinishedCallback:
  // }
  0x800'1ec8: 0x4770          BX       LR
                `.text34`:
                HAL_TIM_PeriodElapsedCallback:
  // }
  0x800'1eca: 0x4770          BX       LR
                `.text18`:
                HAL_TIMEx_BreakCallback:
  // }
  0x800'1ecc: 0x4770          BX       LR
                `.text48`:
                HAL_TIM_TriggerCallback:
  // }
  0x800'1ece: 0x4770          BX       LR
                `.text14`:
                HAL_TIMEx_CommutCallback:
  // }
  0x800'1ed0: 0x4770          BX       LR
  0x800'1ed2: 0x0000          MOVS     R0, R0
                `.text6`:
                strlen:
  0x800'1ed4: 0xf100 0x0301   ADD.W    R3, R0, #1
  0x800'1ed8: 0x0781          LSLS     R1, R0, #30
  0x800'1eda: 0xd004          BEQ.N    @8001ee6
                @8001edc:
  0x800'1edc: 0xf810 0x1b01   LDRB.W   R1, [R0], #0x1
  0x800'1ee0: 0x0782          LSLS     R2, R0, #30
  0x800'1ee2: 0xb181          CBZ      R1, @8001f06
  0x800'1ee4: 0xd1fa          BNE.N    @8001edc
                @8001ee6:
  0x800'1ee6: 0x6802          LDR      R2, [R0]
                @8001ee8:
  0x800'1ee8: 0xf1a2 0x3101   SUB.W    R1, R2, #16843009      ; 0x101'0101
  0x800'1eec: 0x4391          BICS     R1, R1, R2
  0x800'1eee: 0xf011 0x3180   ANDS.W   R1, R1, #-2139062144   ; 0x8080'8080
  0x800'1ef2: 0xbf04          ITT      EQ
  0x800'1ef4: 0xf850 0x2f04   LDREQ.W  R2, [R0, #0x4]!
  0x800'1ef8: 0xe7f6          BEQ.N    @8001ee8
  0x800'1efa: 0xba09          REV      R1, R1
  0x800'1efc: 0xfab1 0xf181   CLZ      R1, R1
  0x800'1f00: 0xeb00 0x00d1   ADD.W    R0, R0, R1, LSR #3
  0x800'1f04: 0x1c40          ADDS     R0, R0, #1
                @8001f06:
  0x800'1f06: 0x1ac0          SUBS     R0, R0, R3
  0x800'1f08: 0x4770          BX       LR
  0x800'1f0a: 0x0000          MOVS     R0, R0
                `.text_3`:
                _tx_thread_system_ni_resume:
  // VOID  _tx_thread_system_ni_resume(TX_THREAD *thread_ptr)
  // {
  0x800'1f0c: 0xe92d 0x4ffe   PUSH.W   {R1-R11, LR}
  0x800'1f10: 0x0004          MOVS     R4, R0
  //     if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
  0x800'1f12: 0x6e60          LDR      R0, [R4, #0x64]
  0x800'1f14: 0x2800          CMP      R0, #0
  0x800'1f16: 0xd003          BEQ.N    ??_tx_thread_system_ni_resume_0
                                                              ; 0x800'1f20
  //         _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
  0x800'1f18: 0xf114 0x004c   ADDS.W   R0, R4, #76            ; 0x4c
  0x800'1f1c: 0xf000 0xf9b4   BL       _tx_timer_system_deactivate
                                                              ; 0x800'2288
                ??_tx_thread_system_ni_resume_0:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'1f20: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'1f24: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'1f26: 0x2c00          CMP      R4, #0
  0x800'1f28: 0xd039          BEQ.N    ??_tx_thread_system_ni_resume_1
                                                              ; 0x800'1f9e
  0x800'1f2a: 0x6821          LDR      R1, [R4]
  0x800'1f2c: 0x48c9          LDR.N    R0, ??DataTable1_2     ; 0x5448'5244
  0x800'1f2e: 0x4281          CMP      R1, R0
  0x800'1f30: 0xd135          BNE.N    ??_tx_thread_system_ni_resume_1
                                                              ; 0x800'1f9e
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f32: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'1f34: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'1f38: 0x4281          CMP      R1, R0
  0x800'1f3a: 0xd202          BCS.N    ??_tx_thread_system_ni_resume_2
                                                              ; 0x800'1f42
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f3c: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'1f3e: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_ni_resume_2:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f42: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1f44: 0x6801          LDR      R1, [R0]
  0x800'1f46: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'1f4a: 0x4281          CMP      R1, R0
  0x800'1f4c: 0xd10b          BNE.N    ??_tx_thread_system_ni_resume_3
                                                              ; 0x800'1f66
  0x800'1f4e: 0x6920          LDR      R0, [R4, #0x10]
  0x800'1f50: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'1f54: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'1f58: 0x4281          CMP      R1, R0
  0x800'1f5a: 0xd104          BNE.N    ??_tx_thread_system_ni_resume_3
                                                              ; 0x800'1f66
  0x800'1f5c: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'1f60: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'1f62: 0x4281          CMP      R1, R0
  0x800'1f64: 0xd209          BCS.N    ??_tx_thread_system_ni_resume_4
                                                              ; 0x800'1f7a
                ??_tx_thread_system_ni_resume_3:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f66: 0x46ba          MOV      R10, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'1f68: 0xf38a 0x8810   MSR      PRIMASK, R10
  // }
  0x800'1f6c: 0x0020          MOVS     R0, R4
  0x800'1f6e: 0xf000 0xf9a7   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'1f72: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'1f76: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'1f78: 0x0007          MOVS     R7, R0
                ??_tx_thread_system_ni_resume_4:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f7a: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'1f7e: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'1f82: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'1f86: 0x4281          CMP      R1, R0
  0x800'1f88: 0xd009          BEQ.N    ??_tx_thread_system_ni_resume_1
                                                              ; 0x800'1f9e
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f8a: 0x46ba          MOV      R10, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'1f8c: 0xf38a 0x8810   MSR      PRIMASK, R10
  // }
  0x800'1f90: 0x0020          MOVS     R0, R4
  0x800'1f92: 0xf000 0xf9a7   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'1f96: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'1f9a: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'1f9c: 0x0007          MOVS     R7, R0
                ??_tx_thread_system_ni_resume_1:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'1f9e: 0x0039          MOVS     R1, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'1fa0: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'1fa4: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'1fa6: 0x2800          CMP      R0, #0
  0x800'1fa8: 0xf000 0x80d7   BEQ.W    ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
  //         if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
  0x800'1fac: 0x6b60          LDR      R0, [R4, #0x34]
  0x800'1fae: 0x2800          CMP      R0, #0
  0x800'1fb0: 0xf040 0x80cf   BNE.W    ??_tx_thread_system_ni_resume_6
                                                              ; 0x800'2152
  //             thread_ptr -> tx_thread_state =  TX_READY;
  0x800'1fb4: 0x2000          MOVS     R0, #0
  0x800'1fb6: 0x6320          STR      R0, [R4, #0x30]
  //             priority =  thread_ptr -> tx_thread_priority;
  0x800'1fb8: 0x6ae0          LDR      R0, [R4, #0x2c]
  0x800'1fba: 0x4681          MOV      R9, R0
  //             _tx_thread_performance_resume_count++;
  0x800'1fbc: 0x49a4          LDR.N    R1, ??DataTable1_1     ; _tx_thread_performance_resume_count
  0x800'1fbe: 0x6808          LDR      R0, [R1]
  0x800'1fc0: 0x1c40          ADDS     R0, R0, #1
  0x800'1fc2: 0x6008          STR      R0, [R1]
  //             thread_ptr -> tx_thread_performance_resume_count++;
  0x800'1fc4: 0xf8d4 0x00a4   LDR.W    R0, [R4, #0xa4]
  0x800'1fc8: 0x1c40          ADDS     R0, R0, #1
  0x800'1fca: 0xf8c4 0x00a4   STR.W    R0, [R4, #0xa4]
  //             head_ptr =  _tx_thread_priority_list[priority];
  0x800'1fce: 0x49a2          LDR.N    R1, ??DataTable1_3     ; _tx_thread_priority_list
  0x800'1fd0: 0xf851 0x0029   LDR.W    R0, [R1, R9, LSL #2]
  0x800'1fd4: 0x0005          MOVS     R5, R0
  //             if (head_ptr == TX_NULL)
  0x800'1fd6: 0x2d00          CMP      R5, #0
  0x800'1fd8: 0xf040 0x80b2   BNE.W    ??_tx_thread_system_ni_resume_7
                                                              ; 0x800'2140
  //                 _tx_thread_priority_list[priority] =       thread_ptr;
  0x800'1fdc: 0xf841 0x4029   STR.W    R4, [R1, R9, LSL #2]
  //                 thread_ptr -> tx_thread_ready_next =       thread_ptr;
  0x800'1fe0: 0x6224          STR      R4, [R4, #0x20]
  //                 thread_ptr -> tx_thread_ready_previous =   thread_ptr;
  0x800'1fe2: 0x6264          STR      R4, [R4, #0x24]
  //                 TX_MOD32_BIT_SET(priority, priority_bit)
  0x800'1fe4: 0x2001          MOVS     R0, #1
  0x800'1fe6: 0xfa10 0xf009   LSLS.W   R0, R0, R9
  0x800'1fea: 0x9001          STR      R0, [SP, #0x4]
  //                 _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
  0x800'1fec: 0x4a9b          LDR.N    R2, ??DataTable1_4     ; _tx_thread_priority_maps
  0x800'1fee: 0x6811          LDR      R1, [R2]
  0x800'1ff0: 0x9801          LDR      R0, [SP, #0x4]
  0x800'1ff2: 0x4301          ORRS     R1, R1, R0
  0x800'1ff4: 0x6011          STR      R1, [R2]
  //                 if (priority < _tx_thread_highest_priority)
  0x800'1ff6: 0x499a          LDR.N    R1, ??DataTable1_5     ; _tx_thread_highest_priority
  0x800'1ff8: 0x6808          LDR      R0, [R1]
  0x800'1ffa: 0x4581          CMP      R9, R0
  0x800'1ffc: 0xf080 0x80ad   BCS.W    ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
  //                     _tx_thread_highest_priority =  priority;
  0x800'2000: 0xf8c1 0x9000   STR.W    R9, [R1]
  //                     execute_ptr =  _tx_thread_execute_ptr;
  0x800'2004: 0x4a97          LDR.N    R2, ??DataTable1_6     ; _tx_thread_execute_ptr
  0x800'2006: 0x6810          LDR      R0, [R2]
  0x800'2008: 0x0006          MOVS     R6, R0
  //                     if (execute_ptr == TX_NULL)
  0x800'200a: 0x2e00          CMP      R6, #0
  0x800'200c: 0xd101          BNE.N    ??_tx_thread_system_ni_resume_8
                                                              ; 0x800'2012
  //                         _tx_thread_execute_ptr =  thread_ptr;
  0x800'200e: 0x6014          STR      R4, [R2]
  0x800'2010: 0xe0a3          B.N      ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
                ??_tx_thread_system_ni_resume_8:
  //                         if (priority < execute_ptr -> tx_thread_preempt_threshold)
  0x800'2012: 0x6bf0          LDR      R0, [R6, #0x3c]
  0x800'2014: 0x4581          CMP      R9, R0
  0x800'2016: 0xf080 0x80a0   BCS.W    ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
  //                             if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
  0x800'201a: 0x4b93          LDR.N    R3, ??DataTable1_7     ; _tx_thread_system_state
  0x800'201c: 0x6818          LDR      R0, [R3]
  0x800'201e: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'2022: 0x4308          ORRS     R0, R0, R1
  0x800'2024: 0x2800          CMP      R0, #0
  0x800'2026: 0xd109          BNE.N    ??_tx_thread_system_ni_resume_9
                                                              ; 0x800'203c
  //                                 _tx_thread_performance_solicited_preemption_count++;
  0x800'2028: 0x4990          LDR.N    R1, ??DataTable1_8     ; _tx_thread_performance_solicited_preemption_count
  0x800'202a: 0x6808          LDR      R0, [R1]
  0x800'202c: 0x1c40          ADDS     R0, R0, #1
  0x800'202e: 0x6008          STR      R0, [R1]
  //                                 execute_ptr -> tx_thread_performance_solicited_preemption_count++;
  0x800'2030: 0xf8d6 0x00ac   LDR.W    R0, [R6, #0xac]
  0x800'2034: 0x1c40          ADDS     R0, R0, #1
  0x800'2036: 0xf8c6 0x00ac   STR.W    R0, [R6, #0xac]
  0x800'203a: 0xe00f          B.N      ??_tx_thread_system_ni_resume_10
                                                              ; 0x800'205c
                ??_tx_thread_system_ni_resume_9:
  //                                 if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
  0x800'203c: 0x6819          LDR      R1, [R3]
  0x800'203e: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'2042: 0x4301          ORRS     R1, R1, R0
  0x800'2044: 0xf1b1 0x3ff0   CMP.W    R1, #-252645136        ; 0xf0f0'f0f0
  0x800'2048: 0xd208          BCS.N    ??_tx_thread_system_ni_resume_10
                                                              ; 0x800'205c
  //                                     _tx_thread_performance_interrupt_preemption_count++;
  0x800'204a: 0x4989          LDR.N    R1, ??DataTable1_9     ; _tx_thread_performance_interrupt_preemption_count
  0x800'204c: 0x6808          LDR      R0, [R1]
  0x800'204e: 0x1c40          ADDS     R0, R0, #1
  0x800'2050: 0x6008          STR      R0, [R1]
  //                                     execute_ptr -> tx_thread_performance_interrupt_preemption_count++;
  0x800'2052: 0xf8d6 0x00b0   LDR.W    R0, [R6, #0xb0]
  0x800'2056: 0x1c40          ADDS     R0, R0, #1
  0x800'2058: 0xf8c6 0x00b0   STR.W    R0, [R6, #0xb0]
                ??_tx_thread_system_ni_resume_10:
  //                             execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;
  0x800'205c: 0xf8c6 0x40b8   STR.W    R4, [R6, #0xb8]
  //                             _tx_thread_execute_ptr =  thread_ptr;
  0x800'2060: 0x6014          STR      R4, [R2]
  //                             if (_tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] != _tx_thread_execute_ptr)
  0x800'2062: 0x4884          LDR.N    R0, ??DataTable1_10    ; _tx_thread_performance__execute_log_index
  0x800'2064: 0x4984          LDR.N    R1, ??DataTable1_11    ; _tx_thread_performance_execute_log
  0x800'2066: 0x6803          LDR      R3, [R0]
  0x800'2068: 0xf851 0x7023   LDR.W    R7, [R1, R3, LSL #2]
  0x800'206c: 0x6813          LDR      R3, [R2]
  0x800'206e: 0x429f          CMP      R7, R3
  0x800'2070: 0xd00b          BEQ.N    ??_tx_thread_system_ni_resume_11
                                                              ; 0x800'208a
  //                                 _tx_thread_performance__execute_log_index++;
  0x800'2072: 0x6803          LDR      R3, [R0]
  0x800'2074: 0x1c5b          ADDS     R3, R3, #1
  0x800'2076: 0x6003          STR      R3, [R0]
  //                                 if (_tx_thread_performance__execute_log_index >= TX_THREAD_EXECUTE_LOG_SIZE)
  0x800'2078: 0x6803          LDR      R3, [R0]
  0x800'207a: 0x2b08          CMP      R3, #8
  0x800'207c: 0xd301          BCC.N    ??_tx_thread_system_ni_resume_12
                                                              ; 0x800'2082
  //                                     _tx_thread_performance__execute_log_index =  ((UINT) 0);
  0x800'207e: 0x2300          MOVS     R3, #0
  0x800'2080: 0x6003          STR      R3, [R0]
                ??_tx_thread_system_ni_resume_12:
  //                                 _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
  0x800'2082: 0x6813          LDR      R3, [R2]
  0x800'2084: 0x6800          LDR      R0, [R0]
  0x800'2086: 0xf841 0x3020   STR.W    R3, [R1, R0, LSL #2]
                ??_tx_thread_system_ni_resume_11:
  //                             thread_ptr =  _tx_thread_execute_ptr;
  0x800'208a: 0x6817          LDR      R7, [R2]
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'208c: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'2090: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2092: 0x2f00          CMP      R7, #0
  0x800'2094: 0xd039          BEQ.N    ??_tx_thread_system_ni_resume_13
                                                              ; 0x800'210a
  0x800'2096: 0x6839          LDR      R1, [R7]
  0x800'2098: 0x486e          LDR.N    R0, ??DataTable1_2     ; 0x5448'5244
  0x800'209a: 0x4281          CMP      R1, R0
  0x800'209c: 0xd135          BNE.N    ??_tx_thread_system_ni_resume_13
                                                              ; 0x800'210a
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'209e: 0x68b9          LDR      R1, [R7, #0x8]
  0x800'20a0: 0xf8d7 0x00cc   LDR.W    R0, [R7, #0xcc]
  0x800'20a4: 0x4281          CMP      R1, R0
  0x800'20a6: 0xd202          BCS.N    ??_tx_thread_system_ni_resume_14
                                                              ; 0x800'20ae
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20a8: 0x68b8          LDR      R0, [R7, #0x8]
  0x800'20aa: 0xf8c7 0x00cc   STR.W    R0, [R7, #0xcc]
                ??_tx_thread_system_ni_resume_14:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20ae: 0x68f8          LDR      R0, [R7, #0xc]
  0x800'20b0: 0x6801          LDR      R1, [R0]
  0x800'20b2: 0xf8d7 0x00d4   LDR.W    R0, [R7, #0xd4]
  0x800'20b6: 0x4281          CMP      R1, R0
  0x800'20b8: 0xd10b          BNE.N    ??_tx_thread_system_ni_resume_15
                                                              ; 0x800'20d2
  0x800'20ba: 0x6938          LDR      R0, [R7, #0x10]
  0x800'20bc: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'20c0: 0xf8d7 0x00d4   LDR.W    R0, [R7, #0xd4]
  0x800'20c4: 0x4281          CMP      R1, R0
  0x800'20c6: 0xd104          BNE.N    ??_tx_thread_system_ni_resume_15
                                                              ; 0x800'20d2
  0x800'20c8: 0xf8d7 0x10cc   LDR.W    R1, [R7, #0xcc]
  0x800'20cc: 0x68f8          LDR      R0, [R7, #0xc]
  0x800'20ce: 0x4281          CMP      R1, R0
  0x800'20d0: 0xd209          BCS.N    ??_tx_thread_system_ni_resume_16
                                                              ; 0x800'20e6
                ??_tx_thread_system_ni_resume_15:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20d2: 0x4654          MOV      R4, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'20d4: 0xf384 0x8810   MSR      PRIMASK, R4
  // }
  0x800'20d8: 0x0038          MOVS     R0, R7
  0x800'20da: 0xf000 0xf8f1   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'20de: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'20e2: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'20e4: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_16:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20e6: 0xf8d7 0x00cc   LDR.W    R0, [R7, #0xcc]
  0x800'20ea: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'20ee: 0xf8d7 0x00d4   LDR.W    R0, [R7, #0xd4]
  0x800'20f2: 0x4281          CMP      R1, R0
  0x800'20f4: 0xd009          BEQ.N    ??_tx_thread_system_ni_resume_13
                                                              ; 0x800'210a
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'20f6: 0x4654          MOV      R4, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'20f8: 0xf384 0x8810   MSR      PRIMASK, R4
  // }
  0x800'20fc: 0x0038          MOVS     R0, R7
  0x800'20fe: 0xf000 0xf8f1   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2102: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'2106: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2108: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_13:
  //                             TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'210a: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'210c: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2110: 0x484e          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'2112: 0x6800          LDR      R0, [R0]
  //                             if (combined_flags == ((ULONG) 0))
  0x800'2114: 0x2800          CMP      R0, #0
  0x800'2116: 0xd112          BNE.N    ??_tx_thread_system_ni_resume_18
                                                              ; 0x800'213e
  //                                 _tx_thread_performance_non_idle_return_count++;
  0x800'2118: 0x4a58          LDR.N    R2, ??DataTable1_12    ; _tx_thread_performance_non_idle_return_count
  0x800'211a: 0x6811          LDR      R1, [R2]
  0x800'211c: 0x1c49          ADDS     R1, R1, #1
  0x800'211e: 0x6011          STR      R1, [R2]
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'2120: 0xf05f 0x5380   MOVS.W   R3, #268435456         ; 0x1000'0000
  0x800'2124: 0x4956          LDR.N    R1, ??DataTable1_13    ; 0xe000'ed04
  0x800'2126: 0x600b          STR      R3, [R1]
  //     if (__get_ipsr_value() == 0)
  0x800'2128: 0xf3ef 0x8105   MRS      R1, IPSR
  0x800'212c: 0x2900          CMP      R1, #0
  0x800'212e: 0xd106          BNE.N    ??_tx_thread_system_ni_resume_18
                                                              ; 0x800'213e
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2130: 0xf3ef 0x8110   MRS      R1, PRIMASK
  //     return(posture);
  0x800'2134: 0x000a          MOVS     R2, R1
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'2136: 0xb662          CPSIE    i
  // }
  0x800'2138: 0x0011          MOVS     R1, R2
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'213a: 0xf381 0x8810   MSR      PRIMASK, R1
                ??_tx_thread_system_ni_resume_17:
                ??_tx_thread_system_ni_resume_18:
  // }
  0x800'213e: 0xe083          B.N      ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
                ??_tx_thread_system_ni_resume_7:
  //                 tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
  0x800'2140: 0x6a68          LDR      R0, [R5, #0x24]
  0x800'2142: 0x4680          MOV      R8, R0
  //                 tail_ptr -> tx_thread_ready_next =         thread_ptr;
  0x800'2144: 0xf8c8 0x4020   STR.W    R4, [R8, #0x20]
  //                 head_ptr -> tx_thread_ready_previous =     thread_ptr;
  0x800'2148: 0x626c          STR      R4, [R5, #0x24]
  //                 thread_ptr -> tx_thread_ready_previous =   tail_ptr;
  0x800'214a: 0xf8c4 0x8024   STR.W    R8, [R4, #0x24]
  //                 thread_ptr -> tx_thread_ready_next =       head_ptr;
  0x800'214e: 0x6225          STR      R5, [R4, #0x20]
  0x800'2150: 0xe003          B.N      ??_tx_thread_system_ni_resume_5
                                                              ; 0x800'215a
                ??_tx_thread_system_ni_resume_6:
  //             thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
  0x800'2152: 0x2000          MOVS     R0, #0
  0x800'2154: 0x6360          STR      R0, [R4, #0x34]
  //             thread_ptr -> tx_thread_state =            TX_SUSPENDED;
  0x800'2156: 0x2003          MOVS     R0, #3
  0x800'2158: 0x6320          STR      R0, [R4, #0x30]
                ??_tx_thread_system_ni_resume_5:
  //     if (_tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] != _tx_thread_execute_ptr)
  0x800'215a: 0x4946          LDR.N    R1, ??DataTable1_10    ; _tx_thread_performance__execute_log_index
  0x800'215c: 0x4a46          LDR.N    R2, ??DataTable1_11    ; _tx_thread_performance_execute_log
  0x800'215e: 0x4841          LDR.N    R0, ??DataTable1_6     ; _tx_thread_execute_ptr
  0x800'2160: 0x680b          LDR      R3, [R1]
  0x800'2162: 0xf852 0x3023   LDR.W    R3, [R2, R3, LSL #2]
  0x800'2166: 0x6807          LDR      R7, [R0]
  0x800'2168: 0x42bb          CMP      R3, R7
  0x800'216a: 0xd00b          BEQ.N    ??_tx_thread_system_ni_resume_20
                                                              ; 0x800'2184
  //         _tx_thread_performance__execute_log_index++;
  0x800'216c: 0x680b          LDR      R3, [R1]
  0x800'216e: 0x1c5b          ADDS     R3, R3, #1
  0x800'2170: 0x600b          STR      R3, [R1]
  //         if (_tx_thread_performance__execute_log_index >= TX_THREAD_EXECUTE_LOG_SIZE)
  0x800'2172: 0x680b          LDR      R3, [R1]
  0x800'2174: 0x2b08          CMP      R3, #8
  0x800'2176: 0xd301          BCC.N    ??_tx_thread_system_ni_resume_21
                                                              ; 0x800'217c
  //             _tx_thread_performance__execute_log_index =  ((UINT) 0);
  0x800'2178: 0x2300          MOVS     R3, #0
  0x800'217a: 0x600b          STR      R3, [R1]
                ??_tx_thread_system_ni_resume_21:
  //         _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
  0x800'217c: 0x6803          LDR      R3, [R0]
  0x800'217e: 0x6809          LDR      R1, [R1]
  0x800'2180: 0xf842 0x3021   STR.W    R3, [R2, R1, LSL #2]
                ??_tx_thread_system_ni_resume_20:
  //     TX_THREAD_GET_CURRENT(current_thread)
  0x800'2184: 0x493f          LDR.N    R1, ??DataTable1_14    ; _tx_thread_current_ptr
  0x800'2186: 0x680f          LDR      R7, [R1]
  //     if (current_thread != _tx_thread_execute_ptr)
  0x800'2188: 0x6801          LDR      R1, [R0]
  0x800'218a: 0x428f          CMP      R7, R1
  0x800'218c: 0xd05c          BEQ.N    ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
  //         thread_ptr =  _tx_thread_execute_ptr;
  0x800'218e: 0x6800          LDR      R0, [R0]
  0x800'2190: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2192: 0xf3ef 0x8a10   MRS      R10, PRIMASK
  //     return(posture);
  0x800'2196: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2198: 0x2c00          CMP      R4, #0
  0x800'219a: 0xd039          BEQ.N    ??_tx_thread_system_ni_resume_23
                                                              ; 0x800'2210
  0x800'219c: 0x6821          LDR      R1, [R4]
  0x800'219e: 0x482d          LDR.N    R0, ??DataTable1_2     ; 0x5448'5244
  0x800'21a0: 0x4281          CMP      R1, R0
  0x800'21a2: 0xd135          BNE.N    ??_tx_thread_system_ni_resume_23
                                                              ; 0x800'2210
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21a4: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'21a6: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'21aa: 0x4281          CMP      R1, R0
  0x800'21ac: 0xd202          BCS.N    ??_tx_thread_system_ni_resume_24
                                                              ; 0x800'21b4
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21ae: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'21b0: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_system_ni_resume_24:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21b4: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'21b6: 0x6801          LDR      R1, [R0]
  0x800'21b8: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'21bc: 0x4281          CMP      R1, R0
  0x800'21be: 0xd10b          BNE.N    ??_tx_thread_system_ni_resume_25
                                                              ; 0x800'21d8
  0x800'21c0: 0x6920          LDR      R0, [R4, #0x10]
  0x800'21c2: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'21c6: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'21ca: 0x4281          CMP      R1, R0
  0x800'21cc: 0xd104          BNE.N    ??_tx_thread_system_ni_resume_25
                                                              ; 0x800'21d8
  0x800'21ce: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'21d2: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'21d4: 0x4281          CMP      R1, R0
  0x800'21d6: 0xd209          BCS.N    ??_tx_thread_system_ni_resume_26
                                                              ; 0x800'21ec
                ??_tx_thread_system_ni_resume_25:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21d8: 0x46d3          MOV      R11, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'21da: 0xf38b 0x8810   MSR      PRIMASK, R11
  // }
  0x800'21de: 0x0020          MOVS     R0, R4
  0x800'21e0: 0xf000 0xf86e   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'21e4: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'21e8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'21ea: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_26:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21ec: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'21f0: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'21f4: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'21f8: 0x4281          CMP      R1, R0
  0x800'21fa: 0xd009          BEQ.N    ??_tx_thread_system_ni_resume_23
                                                              ; 0x800'2210
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'21fc: 0x46d3          MOV      R11, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'21fe: 0xf38b 0x8810   MSR      PRIMASK, R11
  // }
  0x800'2202: 0x0020          MOVS     R0, R4
  0x800'2204: 0xf000 0xf86e   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2208: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'220c: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'220e: 0x4682          MOV      R10, R0
                ??_tx_thread_system_ni_resume_23:
  //         TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2210: 0x4651          MOV      R1, R10
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2212: 0xf381 0x8810   MSR      PRIMASK, R1
  // }
  0x800'2216: 0x480d          LDR.N    R0, ??DataTable1       ; _tx_thread_preempt_disable
  0x800'2218: 0x6800          LDR      R0, [R0]
  0x800'221a: 0x9000          STR      R0, [SP]
  //         if (combined_flags == ((ULONG) 0))
  0x800'221c: 0x9800          LDR      R0, [SP]
  0x800'221e: 0x2800          CMP      R0, #0
  0x800'2220: 0xd112          BNE.N    ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
  //             _tx_thread_performance_non_idle_return_count++;
  0x800'2222: 0x4916          LDR.N    R1, ??DataTable1_12    ; _tx_thread_performance_non_idle_return_count
  0x800'2224: 0x6808          LDR      R0, [R1]
  0x800'2226: 0x1c40          ADDS     R0, R0, #1
  0x800'2228: 0x6008          STR      R0, [R1]
  //     *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
  0x800'222a: 0xf05f 0x5080   MOVS.W   R0, #268435456         ; 0x1000'0000
  0x800'222e: 0x4a14          LDR.N    R2, ??DataTable1_13    ; 0xe000'ed04
  0x800'2230: 0x6010          STR      R0, [R2]
  //     if (__get_ipsr_value() == 0)
  0x800'2232: 0xf3ef 0x8005   MRS      R0, IPSR
  0x800'2236: 0x2800          CMP      R0, #0
  0x800'2238: 0xd106          BNE.N    ??_tx_thread_system_ni_resume_27
                                                              ; 0x800'2248
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'223a: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'223e: 0x0001          MOVS     R1, R0
  //     __asm__ volatile ("CPSIE  i": : : "memory");
  0x800'2240: 0xb662          CPSIE    i
  // }
  0x800'2242: 0x0008          MOVS     R0, R1
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2244: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_system_ni_resume_19:
                ??_tx_thread_system_ni_resume_22:
                ??_tx_thread_system_ni_resume_27:
  // }
  0x800'2248: 0xe8bd 0x8ff7   POP.W    {R0-R2, R4-R11, PC}
                `$d.32`:
                ??DataTable1:
  0x800'224c: 0x2000'0244     DC32     _tx_thread_preempt_disable
                ??DataTable1_1:
  0x800'2250: 0x2000'024c     DC32     _tx_thread_performance_resume_count
                ??DataTable1_2:
  0x800'2254: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
                ??DataTable1_3:
  0x800'2258: 0x2000'00e8     DC32     _tx_thread_priority_list
                ??DataTable1_4:
  0x800'225c: 0x2000'023c     DC32     _tx_thread_priority_maps
                ??DataTable1_5:
  0x800'2260: 0x2000'0240     DC32     _tx_thread_highest_priority
                ??DataTable1_6:
  0x800'2264: 0x2000'0238     DC32     _tx_thread_execute_ptr
                ??DataTable1_7:
  0x800'2268: 0x2000'0008     DC32     _tx_thread_system_state
                ??DataTable1_8:
  0x800'226c: 0x2000'0250     DC32     _tx_thread_performance_solicited_preemption_count
                ??DataTable1_9:
  0x800'2270: 0x2000'0254     DC32     _tx_thread_performance_interrupt_preemption_count
                ??DataTable1_10:
  0x800'2274: 0x2000'0260     DC32     _tx_thread_performance__execute_log_index
                ??DataTable1_11:
  0x800'2278: 0x2000'01f8     DC32     _tx_thread_performance_execute_log
                ??DataTable1_12:
  0x800'227c: 0x2000'025c     DC32     _tx_thread_performance_non_idle_return_count
                ??DataTable1_13:
  0x800'2280: 0xe000'ed04     DC32     0xe000'ed04            ; '....'
                ??DataTable1_14:
  0x800'2284: 0x2000'0234     DC32     _tx_thread_current_ptr
                $t:
                `.text8`:
                _tx_timer_system_deactivate:
  // VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
  // {
  0x800'2288: 0xb410          PUSH     {R4}
  //     list_head =  timer_ptr -> tx_timer_internal_list_head;
  0x800'228a: 0x6981          LDR      R1, [R0, #0x18]
  //     if (list_head != TX_NULL)
  0x800'228c: 0x2900          CMP      R1, #0
  0x800'228e: 0xd014          BEQ.N    ??_tx_timer_system_deactivate_0
                                                              ; 0x800'22ba
  //         next_timer =  timer_ptr -> tx_timer_internal_active_next;
  0x800'2290: 0x6904          LDR      R4, [R0, #0x10]
  0x800'2292: 0x0022          MOVS     R2, R4
  //         if (timer_ptr == next_timer)
  0x800'2294: 0x4290          CMP      R0, R2
  0x800'2296: 0xd105          BNE.N    ??_tx_timer_system_deactivate_1
                                                              ; 0x800'22a4
  //             if (*(list_head) == timer_ptr)
  0x800'2298: 0x680c          LDR      R4, [R1]
  0x800'229a: 0x4284          CMP      R4, R0
  0x800'229c: 0xd10b          BNE.N    ??_tx_timer_system_deactivate_2
                                                              ; 0x800'22b6
  //                 *(list_head) =  TX_NULL;
  0x800'229e: 0x2400          MOVS     R4, #0
  0x800'22a0: 0x600c          STR      R4, [R1]
  0x800'22a2: 0xe008          B.N      ??_tx_timer_system_deactivate_2
                                                              ; 0x800'22b6
                ??_tx_timer_system_deactivate_1:
  //             previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
  0x800'22a4: 0x6944          LDR      R4, [R0, #0x14]
  0x800'22a6: 0x0023          MOVS     R3, R4
  //             next_timer -> tx_timer_internal_active_previous =  previous_timer;
  0x800'22a8: 0x6153          STR      R3, [R2, #0x14]
  //             previous_timer -> tx_timer_internal_active_next =  next_timer;
  0x800'22aa: 0x611a          STR      R2, [R3, #0x10]
  //             if (*(list_head) == timer_ptr)
  0x800'22ac: 0x680c          LDR      R4, [R1]
  0x800'22ae: 0x4284          CMP      R4, R0
  0x800'22b0: 0xd101          BNE.N    ??_tx_timer_system_deactivate_2
                                                              ; 0x800'22b6
  //                 next_timer -> tx_timer_internal_list_head =  list_head;
  0x800'22b2: 0x6191          STR      R1, [R2, #0x18]
  //                 *(list_head) =  next_timer;
  0x800'22b4: 0x600a          STR      R2, [R1]
                ??_tx_timer_system_deactivate_2:
  //         timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
  0x800'22b6: 0x2400          MOVS     R4, #0
  0x800'22b8: 0x6184          STR      R4, [R0, #0x18]
                ??_tx_timer_system_deactivate_0:
  // }
  0x800'22ba: 0xbc10          POP      {R4}
  0x800'22bc: 0x4770          BX       LR
  0x800'22be: 0x0000          MOVS     R0, R0
                `.text8`:
                _tx_thread_stack_error_handler:
  // VOID  _tx_thread_stack_error_handler(TX_THREAD *thread_ptr)
  // {
  0x800'22c0: 0xb538          PUSH     {R3-R5, LR}
  0x800'22c2: 0x0004          MOVS     R4, R0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'22c4: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'22c8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'22ca: 0x4905          LDR.N    R1, ??_tx_thread_stack_error_handler_0
                                                              ; _tx_thread_application_stack_error_handler
  0x800'22cc: 0x6808          LDR      R0, [R1]
  0x800'22ce: 0x2800          CMP      R0, #0
  0x800'22d0: 0xd002          BEQ.N    ??_tx_thread_stack_error_handler_1
                                                              ; 0x800'22d8
  //         (_tx_thread_application_stack_error_handler)(thread_ptr);
  0x800'22d2: 0x0020          MOVS     R0, R4
  0x800'22d4: 0x6809          LDR      R1, [R1]
  0x800'22d6: 0x4788          BLX      R1
                ??_tx_thread_stack_error_handler_1:
  //     TX_RESTORE
  0x800'22d8: 0x0028          MOVS     R0, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'22da: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'22de: 0xbd31          POP      {R0, R4, R5, PC}
                `$d.32`:
                ??_tx_thread_stack_error_handler_0:
  0x800'22e0: 0x2000'0248     DC32     _tx_thread_application_stack_error_handler
                $t:
                `.text8`:
                _tx_thread_stack_analyze:
  // VOID  _tx_thread_stack_analyze(TX_THREAD *thread_ptr)
  // {
  0x800'22e4: 0xb4f0          PUSH     {R4-R7}
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'22e6: 0xf3ef 0x8510   MRS      R5, PRIMASK
  //     return(posture);
  0x800'22ea: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'22ec: 0x2800          CMP      R0, #0
  0x800'22ee: 0xd03e          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //         if (thread_ptr -> tx_thread_id == TX_THREAD_ID)
  0x800'22f0: 0x4e21          LDR.N    R6, ??_tx_thread_stack_analyze_0
                                                              ; 0x5448'5244
  0x800'22f2: 0x6807          LDR      R7, [R0]
  0x800'22f4: 0x42b7          CMP      R7, R6
  0x800'22f6: 0xd13a          BNE.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //             stack_lowest =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_start);
  0x800'22f8: 0x68c7          LDR      R7, [R0, #0xc]
  0x800'22fa: 0x0039          MOVS     R1, R7
  //             if (stack_lowest != TX_NULL)
  0x800'22fc: 0x2900          CMP      R1, #0
  0x800'22fe: 0xd036          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                 stack_highest =  TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_highest_ptr);
  0x800'2300: 0xf8d0 0x70cc   LDR.W    R7, [R0, #0xcc]
  0x800'2304: 0x003a          MOVS     R2, R7
  //                 if (stack_highest != TX_NULL)
  0x800'2306: 0x2a00          CMP      R2, #0
  0x800'2308: 0xd031          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                     TX_RESTORE
  0x800'230a: 0x002f          MOVS     R7, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'230c: 0xf387 0x8810   MSR      PRIMASK, R7
                ??_tx_thread_stack_analyze_2:
  // }
  0x800'2310: 0x1a57          SUBS     R7, R2, R1
  0x800'2312: 0x10bf          ASRS     R7, R7, #2
  0x800'2314: 0x087f          LSRS     R7, R7, #1
  0x800'2316: 0x003c          MOVS     R4, R7
  //                         stack_ptr =  TX_ULONG_POINTER_ADD(stack_lowest, size);
  0x800'2318: 0xeb01 0x0784   ADD.W    R7, R1, R4, LSL #2
  0x800'231c: 0x003b          MOVS     R3, R7
  //                         if (*stack_ptr != TX_STACK_FILL)
  0x800'231e: 0xf8d3 0xc000   LDR.W    R12, [R3]
  0x800'2322: 0xf8d0 0x70d4   LDR.W    R7, [R0, #0xd4]
  0x800'2326: 0x45bc          CMP      R12, R7
  0x800'2328: 0xd001          BEQ.N    ??_tx_thread_stack_analyze_3
                                                              ; 0x800'232e
  //                             stack_highest =  stack_ptr;
  0x800'232a: 0x001a          MOVS     R2, R3
  0x800'232c: 0xe000          B.N      ??_tx_thread_stack_analyze_4
                                                              ; 0x800'2330
                ??_tx_thread_stack_analyze_3:
  //                             stack_lowest =  stack_ptr;
  0x800'232e: 0x0019          MOVS     R1, R3
                ??_tx_thread_stack_analyze_4:
  //                     } while(size > ((ULONG) 1));
  0x800'2330: 0x2c02          CMP      R4, #2
  0x800'2332: 0xd2ed          BCS.N    ??_tx_thread_stack_analyze_2
                                                              ; 0x800'2310
                ??_tx_thread_stack_analyze_5:
  //                     while (*stack_ptr == TX_STACK_FILL)
  0x800'2334: 0xf8d3 0xc000   LDR.W    R12, [R3]
  0x800'2338: 0xf8d0 0x70d4   LDR.W    R7, [R0, #0xd4]
  0x800'233c: 0x45bc          CMP      R12, R7
  0x800'233e: 0xd101          BNE.N    ??_tx_thread_stack_analyze_6
                                                              ; 0x800'2344
  //                         stack_ptr =  TX_ULONG_POINTER_ADD(stack_ptr, 1);
  0x800'2340: 0x1d1b          ADDS     R3, R3, #4
  0x800'2342: 0xe7f7          B.N      ??_tx_thread_stack_analyze_5
                                                              ; 0x800'2334
                ??_tx_thread_stack_analyze_6:
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2344: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'2348: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'234a: 0x003d          MOVS     R5, R7
  //                     if (thread_ptr -> tx_thread_id == TX_THREAD_ID)
  0x800'234c: 0x6807          LDR      R7, [R0]
  0x800'234e: 0x42b7          CMP      R7, R6
  0x800'2350: 0xd10d          BNE.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                         if (stack_ptr > (TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_start)))
  0x800'2352: 0x68c6          LDR      R6, [R0, #0xc]
  0x800'2354: 0x429e          CMP      R6, R3
  0x800'2356: 0xd20a          BCS.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                             if (stack_ptr < (TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_stack_highest_ptr)))
  0x800'2358: 0xf8d0 0x60cc   LDR.W    R6, [R0, #0xcc]
  0x800'235c: 0x42b3          CMP      R3, R6
  0x800'235e: 0xd206          BCS.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                                 if (*stack_ptr != TX_STACK_FILL)
  0x800'2360: 0x681f          LDR      R7, [R3]
  0x800'2362: 0xf8d0 0x60d4   LDR.W    R6, [R0, #0xd4]
  0x800'2366: 0x42b7          CMP      R7, R6
  0x800'2368: 0xd001          BEQ.N    ??_tx_thread_stack_analyze_1
                                                              ; 0x800'236e
  //                                     thread_ptr -> tx_thread_stack_highest_ptr =  stack_ptr;
  0x800'236a: 0xf8c0 0x30cc   STR.W    R3, [R0, #0xcc]
                ??_tx_thread_stack_analyze_1:
  //     TX_RESTORE
  0x800'236e: 0x002e          MOVS     R6, R5
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2370: 0xf386 0x8810   MSR      PRIMASK, R6
  // }
  0x800'2374: 0xbcf0          POP      {R4-R7}
  0x800'2376: 0x4770          BX       LR
                `$d.32`:
                ??_tx_thread_stack_analyze_0:
  0x800'2378: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
                $t:
                `.text8`:
                _tx_thread_time_slice:
  // VOID  _tx_thread_time_slice(VOID)
  // {
  0x800'237c: 0xe92d 0x41f0   PUSH.W   {R4-R8, LR}
  //     TX_THREAD_GET_CURRENT(thread_ptr)
  0x800'2380: 0x485d          LDR.N    R0, ??_tx_thread_time_slice_0
                                                              ; _tx_thread_current_ptr
  0x800'2382: 0x6804          LDR      R4, [R0]
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'2384: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'2388: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'238a: 0x2c00          CMP      R4, #0
  0x800'238c: 0xd039          BEQ.N    ??_tx_thread_time_slice_1
                                                              ; 0x800'2402
  0x800'238e: 0x6820          LDR      R0, [R4]
  0x800'2390: 0x495a          LDR.N    R1, [PC, #0x168]       ; 0x5448'5244
  0x800'2392: 0x4288          CMP      R0, R1
  0x800'2394: 0xd135          BNE.N    ??_tx_thread_time_slice_1
                                                              ; 0x800'2402
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2396: 0x68a1          LDR      R1, [R4, #0x8]
  0x800'2398: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'239c: 0x4281          CMP      R1, R0
  0x800'239e: 0xd202          BCS.N    ??_tx_thread_time_slice_2
                                                              ; 0x800'23a6
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23a0: 0x68a0          LDR      R0, [R4, #0x8]
  0x800'23a2: 0xf8c4 0x00cc   STR.W    R0, [R4, #0xcc]
                ??_tx_thread_time_slice_2:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23a6: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'23a8: 0x6801          LDR      R1, [R0]
  0x800'23aa: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'23ae: 0x4281          CMP      R1, R0
  0x800'23b0: 0xd10b          BNE.N    ??_tx_thread_time_slice_3
                                                              ; 0x800'23ca
  0x800'23b2: 0x6920          LDR      R0, [R4, #0x10]
  0x800'23b4: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'23b8: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'23bc: 0x4281          CMP      R1, R0
  0x800'23be: 0xd104          BNE.N    ??_tx_thread_time_slice_3
                                                              ; 0x800'23ca
  0x800'23c0: 0xf8d4 0x10cc   LDR.W    R1, [R4, #0xcc]
  0x800'23c4: 0x68e0          LDR      R0, [R4, #0xc]
  0x800'23c6: 0x4281          CMP      R1, R0
  0x800'23c8: 0xd209          BCS.N    ??_tx_thread_time_slice_4
                                                              ; 0x800'23de
                ??_tx_thread_time_slice_3:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23ca: 0x003d          MOVS     R5, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'23cc: 0xf385 0x8810   MSR      PRIMASK, R5
  // }
  0x800'23d0: 0x0020          MOVS     R0, R4
  0x800'23d2: 0xf7ff 0xff75   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'23d6: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'23da: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'23dc: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_4:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23de: 0xf8d4 0x00cc   LDR.W    R0, [R4, #0xcc]
  0x800'23e2: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'23e6: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'23ea: 0x4281          CMP      R1, R0
  0x800'23ec: 0xd009          BEQ.N    ??_tx_thread_time_slice_1
                                                              ; 0x800'2402
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'23ee: 0x003d          MOVS     R5, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'23f0: 0xf385 0x8810   MSR      PRIMASK, R5
  // }
  0x800'23f4: 0x0020          MOVS     R0, R4
  0x800'23f6: 0xf7ff 0xff75   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'23fa: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'23fe: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2400: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_1:
  //     TX_THREAD_STACK_CHECK(thread_ptr)
  0x800'2402: 0x003a          MOVS     R2, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2404: 0xf382 0x8810   MSR      PRIMASK, R2
  // }
  0x800'2408: 0x2500          MOVS     R5, #0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'240a: 0xf3ef 0x8610   MRS      R6, PRIMASK
  //     return(posture);
  0x800'240e: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2410: 0x2000          MOVS     R0, #0
  0x800'2412: 0x493b          LDR.N    R1, [PC, #0xec]        ; _tx_timer_expired_time_slice
  0x800'2414: 0x6008          STR      R0, [R1]
  //     if (thread_ptr != TX_NULL)
  0x800'2416: 0x2c00          CMP      R4, #0
  0x800'2418: 0xd024          BEQ.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2464
  //         if (thread_ptr -> tx_thread_state == TX_READY)
  0x800'241a: 0x6b20          LDR      R0, [R4, #0x30]
  0x800'241c: 0x2800          CMP      R0, #0
  0x800'241e: 0xd121          BNE.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2464
  //             thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
  0x800'2420: 0x69e0          LDR      R0, [R4, #0x1c]
  0x800'2422: 0x61a0          STR      R0, [R4, #0x18]
  //             _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
  0x800'2424: 0x69a1          LDR      R1, [R4, #0x18]
  0x800'2426: 0x4837          LDR.N    R0, [PC, #0xdc]        ; _tx_timer_time_slice
  0x800'2428: 0x6001          STR      R1, [R0]
  //             if (thread_ptr -> tx_thread_ready_next != thread_ptr)
  0x800'242a: 0x6a20          LDR      R0, [R4, #0x20]
  0x800'242c: 0x42a0          CMP      R0, R4
  0x800'242e: 0xd019          BEQ.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2464
  //                 if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
  0x800'2430: 0x6ae0          LDR      R0, [R4, #0x2c]
  0x800'2432: 0x6be1          LDR      R1, [R4, #0x3c]
  0x800'2434: 0x4288          CMP      R0, R1
  0x800'2436: 0xd115          BNE.N    ??_tx_thread_time_slice_5
                                                              ; 0x800'2464
  //                     _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
  0x800'2438: 0x4933          LDR.N    R1, [PC, #0xcc]        ; _tx_thread_priority_list
  0x800'243a: 0x6a20          LDR      R0, [R4, #0x20]
  0x800'243c: 0x6ae2          LDR      R2, [R4, #0x2c]
  0x800'243e: 0xf841 0x0022   STR.W    R0, [R1, R2, LSL #2]
  //                     _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
  0x800'2442: 0x4832          LDR.N    R0, [PC, #0xc8]        ; _tx_thread_execute_ptr
  0x800'2444: 0x4a32          LDR.N    R2, [PC, #0xc8]        ; _tx_thread_highest_priority
  0x800'2446: 0x6812          LDR      R2, [R2]
  0x800'2448: 0xf851 0x1022   LDR.W    R1, [R1, R2, LSL #2]
  0x800'244c: 0x6001          STR      R1, [R0]
  //                     thread_ptr -> tx_thread_performance_time_slice_count++;
  0x800'244e: 0xf8d4 0x10bc   LDR.W    R1, [R4, #0xbc]
  0x800'2452: 0x1c49          ADDS     R1, R1, #1
  0x800'2454: 0xf8c4 0x10bc   STR.W    R1, [R4, #0xbc]
  //                     _tx_thread_performance_time_slice_count++;
  0x800'2458: 0x4a2e          LDR.N    R2, [PC, #0xb8]        ; _tx_thread_performance_time_slice_count
  0x800'245a: 0x6811          LDR      R1, [R2]
  0x800'245c: 0x1c49          ADDS     R1, R1, #1
  0x800'245e: 0x6011          STR      R1, [R2]
  //                     next_thread_ptr =  _tx_thread_execute_ptr;
  0x800'2460: 0x6800          LDR      R0, [R0]
  0x800'2462: 0x0005          MOVS     R5, R0
                ??_tx_thread_time_slice_5:
  //     TX_RESTORE
  0x800'2464: 0x0030          MOVS     R0, R6
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'2466: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'246a: 0x2d00          CMP      R5, #0
  0x800'246c: 0xd041          BEQ.N    ??_tx_thread_time_slice_6
                                                              ; 0x800'24f2
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'246e: 0xf3ef 0x8710   MRS      R7, PRIMASK
  //     return(posture);
  0x800'2472: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2474: 0x2d00          CMP      R5, #0
  0x800'2476: 0xd039          BEQ.N    ??_tx_thread_time_slice_7
                                                              ; 0x800'24ec
  0x800'2478: 0x6829          LDR      R1, [R5]
  0x800'247a: 0x4820          LDR.N    R0, [PC, #0x80]        ; 0x5448'5244
  0x800'247c: 0x4281          CMP      R1, R0
  0x800'247e: 0xd135          BNE.N    ??_tx_thread_time_slice_7
                                                              ; 0x800'24ec
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2480: 0x68a9          LDR      R1, [R5, #0x8]
  0x800'2482: 0xf8d5 0x00cc   LDR.W    R0, [R5, #0xcc]
  0x800'2486: 0x4281          CMP      R1, R0
  0x800'2488: 0xd202          BCS.N    ??_tx_thread_time_slice_8
                                                              ; 0x800'2490
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'248a: 0x68a8          LDR      R0, [R5, #0x8]
  0x800'248c: 0xf8c5 0x00cc   STR.W    R0, [R5, #0xcc]
                ??_tx_thread_time_slice_8:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'2490: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'2492: 0x6801          LDR      R1, [R0]
  0x800'2494: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'2498: 0x4281          CMP      R1, R0
  0x800'249a: 0xd10b          BNE.N    ??_tx_thread_time_slice_9
                                                              ; 0x800'24b4
  0x800'249c: 0x6928          LDR      R0, [R5, #0x10]
  0x800'249e: 0xf8d0 0x1001   LDR.W    R1, [R0, #0x1]
  0x800'24a2: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'24a6: 0x4281          CMP      R1, R0
  0x800'24a8: 0xd104          BNE.N    ??_tx_thread_time_slice_9
                                                              ; 0x800'24b4
  0x800'24aa: 0xf8d5 0x10cc   LDR.W    R1, [R5, #0xcc]
  0x800'24ae: 0x68e8          LDR      R0, [R5, #0xc]
  0x800'24b0: 0x4281          CMP      R1, R0
  0x800'24b2: 0xd209          BCS.N    ??_tx_thread_time_slice_10
                                                              ; 0x800'24c8
                ??_tx_thread_time_slice_9:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'24b4: 0x46b8          MOV      R8, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'24b6: 0xf388 0x8810   MSR      PRIMASK, R8
  // }
  0x800'24ba: 0x0028          MOVS     R0, R5
  0x800'24bc: 0xf7ff 0xff00   BL       _tx_thread_stack_error_handler
                                                              ; 0x800'22c0
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'24c0: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'24c4: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'24c6: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_10:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'24c8: 0xf8d5 0x00cc   LDR.W    R0, [R5, #0xcc]
  0x800'24cc: 0xf850 0x1c04   LDR.W    R1, [R0, #-0x4]
  0x800'24d0: 0xf8d4 0x00d4   LDR.W    R0, [R4, #0xd4]
  0x800'24d4: 0x4281          CMP      R1, R0
  0x800'24d6: 0xd009          BEQ.N    ??_tx_thread_time_slice_7
                                                              ; 0x800'24ec
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'24d8: 0x46b8          MOV      R8, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'24da: 0xf388 0x8810   MSR      PRIMASK, R8
  // }
  0x800'24de: 0x0028          MOVS     R0, R5
  0x800'24e0: 0xf7ff 0xff00   BL       _tx_thread_stack_analyze
                                                              ; 0x800'22e4
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'24e4: 0xf3ef 0x8010   MRS      R0, PRIMASK
  //     return(posture);
  0x800'24e8: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'24ea: 0x0007          MOVS     R7, R0
                ??_tx_thread_time_slice_7:
  //         TX_THREAD_STACK_CHECK(next_thread_ptr)
  0x800'24ec: 0x0038          MOVS     R0, R7
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'24ee: 0xf380 0x8810   MSR      PRIMASK, R0
                ??_tx_thread_time_slice_6:
  // }
  0x800'24f2: 0xe8bd 0x81f0   POP.W    {R4-R8, PC}
  0x800'24f6: 0xbf00          NOP
                `$d.32`:
                ??_tx_thread_time_slice_0:
  0x800'24f8: 0x2000'0234     DC32     _tx_thread_current_ptr
  0x800'24fc: 0x5448'5244     DC32     0x5448'5244            ; 'DRHT'
  0x800'2500: 0x2000'0268     DC32     _tx_timer_expired_time_slice
  0x800'2504: 0x2000'027c     DC32     _tx_timer_time_slice
  0x800'2508: 0x2000'00e8     DC32     _tx_thread_priority_list
  0x800'250c: 0x2000'0238     DC32     _tx_thread_execute_ptr
  0x800'2510: 0x2000'0240     DC32     _tx_thread_highest_priority
  0x800'2514: 0x2000'0258     DC32     _tx_thread_performance_time_slice_count
                $t:
                `.text9`:
                HAL_InitTick:
  // HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
  // {
  0x800'2518: 0xe92d 0x47f8   PUSH.W   {R3-R10, LR}
  0x800'251c: 0xb087          SUB      SP, SP, #0x1c
  0x800'251e: 0x0005          MOVS     R5, R0
  //   uint32_t              uwTimclock, uwAPB1Prescaler = 0U;
  0x800'2520: 0x2700          MOVS     R7, #0
  //   uint32_t              uwPrescalerValue = 0U;
  0x800'2522: 0x2600          MOVS     R6, #0
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'2524: 0x2000          MOVS     R0, #0
  0x800'2526: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'2528: 0x492a          LDR.N    R1, ??DataTable2       ; 0x4002'3840
  0x800'252a: 0x6808          LDR      R0, [R1]
  0x800'252c: 0xf050 0x0001   ORRS.W   R0, R0, #1
  0x800'2530: 0x6008          STR      R0, [R1]
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'2532: 0x6808          LDR      R0, [R1]
  0x800'2534: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'2538: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_TIM2_CLK_ENABLE();
  0x800'253a: 0x9800          LDR      R0, [SP]
  //   HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
  0x800'253c: 0xa901          ADD      R1, SP, #0x4
  0x800'253e: 0xa802          ADD      R0, SP, #0x8
  0x800'2540: 0xf7fe 0xfd03   BL       HAL_RCC_GetClockConfig ; 0x800'0f4a
  //   uwAPB1Prescaler = clkconfig.APB1CLKDivider;
  0x800'2544: 0x9c05          LDR      R4, [SP, #0x14]
  //   if (uwAPB1Prescaler == RCC_HCLK_DIV1)
  0x800'2546: 0x2c00          CMP      R4, #0
  0x800'2548: 0xd103          BNE.N    ??HAL_InitTick_0       ; 0x800'2552
  //     uwTimclock = HAL_RCC_GetPCLK1Freq();
  0x800'254a: 0xf7fe 0xfce8   BL       HAL_RCC_GetPCLK1Freq   ; 0x800'0f1e
  0x800'254e: 0x0007          MOVS     R7, R0
  0x800'2550: 0xe002          B.N      ??HAL_InitTick_1       ; 0x800'2558
                ??HAL_InitTick_0:
  //     uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
  0x800'2552: 0xf7fe 0xfce4   BL       HAL_RCC_GetPCLK1Freq   ; 0x800'0f1e
  0x800'2556: 0x0047          LSLS     R7, R0, #1
                ??HAL_InitTick_1:
  //   uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
  0x800'2558: 0x481f          LDR.N    R0, ??DataTable2_1     ; 0xf'4240
  0x800'255a: 0xfbb7 0xf8f0   UDIV     R8, R7, R0
  0x800'255e: 0xf1b8 0x0801   SUBS.W   R8, R8, #1
  //   htim2.Instance = TIM2;
  0x800'2562: 0xf8df 0x9078   LDR.W    R9, ??DataTable2_2     ; htim2
  0x800'2566: 0xf05f 0x4080   MOVS.W   R0, #1073741824        ; 0x4000'0000
  0x800'256a: 0xf8c9 0x0000   STR.W    R0, [R9]
  //   htim2.Init.Period = (1000000U / 1000U) - 1U;
  0x800'256e: 0xf240 0x30e7   MOVW     R0, #999               ; 0x3e7
  0x800'2572: 0xf8c9 0x000c   STR.W    R0, [R9, #0xc]
  //   htim2.Init.Prescaler = uwPrescalerValue;
  0x800'2576: 0xf8c9 0x8004   STR.W    R8, [R9, #0x4]
  //   htim2.Init.ClockDivision = 0;
  0x800'257a: 0x2000          MOVS     R0, #0
  0x800'257c: 0xf8c9 0x0010   STR.W    R0, [R9, #0x10]
  //   htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  0x800'2580: 0x2000          MOVS     R0, #0
  0x800'2582: 0xf8c9 0x0008   STR.W    R0, [R9, #0x8]
  //   htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  0x800'2586: 0x2000          MOVS     R0, #0
  0x800'2588: 0xf8c9 0x0018   STR.W    R0, [R9, #0x18]
  //   status = HAL_TIM_Base_Init(&htim2);
  0x800'258c: 0x4648          MOV      R0, R9
  0x800'258e: 0xf7fe 0xfe37   BL       HAL_TIM_Base_Init      ; 0x800'1200
  0x800'2592: 0x4682          MOV      R10, R0
  //   if (status == HAL_OK)
  0x800'2594: 0x4650          MOV      R0, R10
  0x800'2596: 0xb2c0          UXTB     R0, R0
  0x800'2598: 0x2800          CMP      R0, #0
  0x800'259a: 0xd116          BNE.N    ??HAL_InitTick_2       ; 0x800'25ca
  //     status = HAL_TIM_Base_Start_IT(&htim2);
  0x800'259c: 0x4648          MOV      R0, R9
  0x800'259e: 0xf7fe 0xff0b   BL       HAL_TIM_Base_Start_IT  ; 0x800'13b8
  0x800'25a2: 0x4682          MOV      R10, R0
  //     if (status == HAL_OK)
  0x800'25a4: 0x4650          MOV      R0, R10
  0x800'25a6: 0xb2c0          UXTB     R0, R0
  0x800'25a8: 0x2800          CMP      R0, #0
  0x800'25aa: 0xd10e          BNE.N    ??HAL_InitTick_2       ; 0x800'25ca
  //         HAL_NVIC_EnableIRQ(TIM2_IRQn);
  0x800'25ac: 0x201c          MOVS     R0, #28                ; 0x1c
  0x800'25ae: 0xf7ff 0xfbcf   BL       HAL_NVIC_EnableIRQ     ; 0x800'1d50
  //       if (TickPriority < (1UL << __NVIC_PRIO_BITS))
  0x800'25b2: 0x2d10          CMP      R5, #16                ; 0x10
  0x800'25b4: 0xd207          BCS.N    ??HAL_InitTick_3       ; 0x800'25c6
  //         HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority, 0U);
  0x800'25b6: 0x2200          MOVS     R2, #0
  0x800'25b8: 0x0029          MOVS     R1, R5
  0x800'25ba: 0x201c          MOVS     R0, #28                ; 0x1c
  0x800'25bc: 0xf7ff 0xfba5   BL       HAL_NVIC_SetPriority   ; 0x800'1d0a
  //         uwTickPrio = TickPriority;
  0x800'25c0: 0x4807          LDR.N    R0, ??DataTable2_3     ; uwTickPrio
  0x800'25c2: 0x6005          STR      R5, [R0]
  0x800'25c4: 0xe001          B.N      ??HAL_InitTick_2       ; 0x800'25ca
                ??HAL_InitTick_3:
  //         status = HAL_ERROR;
  0x800'25c6: 0x2001          MOVS     R0, #1
  0x800'25c8: 0x4682          MOV      R10, R0
                ??HAL_InitTick_2:
  //   return status;
  0x800'25ca: 0x4650          MOV      R0, R10
  0x800'25cc: 0xb2c0          UXTB     R0, R0
  0x800'25ce: 0xb008          ADD      SP, SP, #0x20
  0x800'25d0: 0xe8bd 0x87f0   POP.W    {R4-R10, PC}
                `$d.32`:
                ??DataTable2:
  0x800'25d4: 0x4002'3840     DC32     0x4002'3840            ; '@8.@'
                ??DataTable2_1:
  0x800'25d8: 0x000f'4240     DC32     0xf'4240               ; '@B..'
                ??DataTable2_2:
  0x800'25dc: 0x2000'01b0     DC32     htim2
                ??DataTable2_3:
  0x800'25e0: 0x2000'0000     DC32     uwTickPrio
                $t:
                `.text6`:
                _tx_thread_schedule:
  //     MOV     r0, #0                                  // Build value for TX_FALSE
  0x800'25e4: 0xf04f 0x0000   MOV.W    R0, #0
  //     LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  0x800'25e8: 0x4a2a          LDR.N    R2, [PC, #0xa8]        ; _tx_thread_preempt_disable
  //     STR     r0, [r2, #0]                            // Clear preempt disable flag
  0x800'25ea: 0x6010          STR      R0, [R2]
  //     MRS     r0, CONTROL                             // Pickup current CONTROL register
  0x800'25ec: 0xf3ef 0x8014   MRS      R0, CONTROL
  //     BIC     r0, r0, #4                              // Clear the FPCA bit
  0x800'25f0: 0xf020 0x0004   BIC.W    R0, R0, #4
  //     MSR     CONTROL, r0                             // Setup new CONTROL register
  0x800'25f4: 0xf380 0x8814   MSR      CONTROL, R0
  //     CPSIE   i
  0x800'25f8: 0xb662          CPSIE    i
  //     MOV     r0, #0x10000000                         // Load PENDSVSET bit
  0x800'25fa: 0xf04f 0x5080   MOV.W    R0, #268435456         ; 0x1000'0000
  //     MOV     r1, #0xE000E000                         // Load NVIC base
  0x800'25fe: 0xf04f 0x21e0   MOV.W    R1, #-536813568        ; 0xe000'e000
  //     STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
  0x800'2602: 0xf8c1 0x0d04   STR.W    R0, [R1, #0xd04]
  //     DSB                                             // Complete all memory accesses
  0x800'2606: 0xf3bf 0x8f4f   DSB
  //     ISB                                             // Flush pipeline
  0x800'260a: 0xf3bf 0x8f6f   ISB
                __tx_wait_here:
  //     B       __tx_wait_here                          // Wait for the PendSV to happen
  0x800'260e: 0xe7fe          B.N      __tx_wait_here         ; 0x800'260e
                __tx_ts_handler:
                PendSV_Handler:
                __tx_PendSVHandler:
  //     LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  0x800'2610: 0x4821          LDR.N    R0, [PC, #0x84]        ; _tx_thread_current_ptr
  //     LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  0x800'2612: 0x4a22          LDR.N    R2, [PC, #0x88]        ; _tx_thread_execute_ptr
  //     MOV     r3, #0                                  // Build NULL value
  0x800'2614: 0xf04f 0x0300   MOV.W    R3, #0
  //     LDR     r1, [r0]                                // Pickup current thread pointer
  0x800'2618: 0x6801          LDR      R1, [R0]
  //     CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
  0x800'261a: 0xb191          CBZ      R1, __tx_ts_new        ; 0x800'2642
  //     STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
  0x800'261c: 0x6003          STR      R3, [R0]
  //     MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
  0x800'261e: 0xf3ef 0x8c09   MRS      R12, PSP
  //     STMDB   r12!, {r4-r11}                          // Save its remaining registers
  0x800'2622: 0xe92c 0x0ff0   STMDB    R12!, {R4-R11}
  //     TST     LR, #0x10                               // Determine if the VFP extended frame is present
  0x800'2626: 0xf01e 0x0f10   TST.W    LR, #16                ; 0x10
  //     BNE     _skip_vfp_save
  0x800'262a: 0xd101          BNE.N    _skip_vfp_save         ; 0x800'2630
  //     VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
  0x800'262c: 0xed2c 0x8a10   VSTMDB   R12!, {S16-S31}
                _skip_vfp_save:
  //     LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  0x800'2630: 0x4c1b          LDR.N    R4, [PC, #0x6c]        ; _tx_timer_time_slice
  //     STMDB   r12!, {LR}                              // Save LR on the stack
  0x800'2632: 0xf84c 0xed04   STR.W    LR, [R12, #-0x4]!
  //     LDR     r5, [r4]                                // Pickup current time-slice
  0x800'2636: 0x6825          LDR      R5, [R4]
  //     STR     r12, [r1, #8]                           // Save the thread stack pointer
  0x800'2638: 0xf8c1 0xc008   STR.W    R12, [R1, #0x8]
  //     CBZ     r5, __tx_ts_new                         // If not active, skip processing
  0x800'263c: 0xb10d          CBZ      R5, __tx_ts_new        ; 0x800'2642
  //     STR     r5, [r1, #24]                           // Save current time-slice
  0x800'263e: 0x618d          STR      R5, [R1, #0x18]
  //     STR     r3, [r4]                                // Clear time-slice
  0x800'2640: 0x6023          STR      R3, [R4]
                __tx_ts_new:
  //     CPSID   i                                       // Disable interrupts
  0x800'2642: 0xb672          CPSID    i
  //     LDR     r1, [r2]                                // Is there another thread ready to execute?
  0x800'2644: 0x6811          LDR      R1, [R2]
  //     CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
  0x800'2646: 0xb1b1          CBZ      R1, __tx_ts_wait       ; 0x800'2676
  //     STR     r1, [r0]                                // Setup the current thread pointer to the new thread
  0x800'2648: 0x6001          STR      R1, [R0]
  //     CPSIE   i                                       // Enable interrupts
  0x800'264a: 0xb662          CPSIE    i
                __tx_ts_restore:
  //     LDR     r7, [r1, #4]                            // Pickup the current thread run count
  0x800'264c: 0x684f          LDR      R7, [R1, #0x4]
  //     LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
  0x800'264e: 0x4c14          LDR.N    R4, [PC, #0x50]        ; _tx_timer_time_slice
  //     LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
  0x800'2650: 0x698d          LDR      R5, [R1, #0x18]
  //     ADD     r7, r7, #1                              // Increment the thread run count
  0x800'2652: 0xf107 0x0701   ADD.W    R7, R7, #1
  //     STR     r7, [r1, #4]                            // Store the new run count
  0x800'2656: 0x604f          STR      R7, [R1, #0x4]
  //     STR     r5, [r4]                                // Setup global time-slice
  0x800'2658: 0x6025          STR      R5, [R4]
  //     LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
  0x800'265a: 0xf8d1 0xc008   LDR.W    R12, [R1, #0x8]
  //     LDMIA   r12!, {LR}                              // Pickup LR
  0x800'265e: 0xf85c 0xeb04   LDR.W    LR, [R12], #0x4
  //     TST     LR, #0x10                               // Determine if the VFP extended frame is present
  0x800'2662: 0xf01e 0x0f10   TST.W    LR, #16                ; 0x10
  //     BNE     _skip_vfp_restore                       // If not, skip VFP restore
  0x800'2666: 0xd101          BNE.N    _skip_vfp_restore      ; 0x800'266c
  //     VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
  0x800'2668: 0xecbc 0x8a10   VLDM     R12!,{S16-S31}
                _skip_vfp_restore:
  //     LDMIA   r12!, {r4-r11}                          // Recover thread's registers
  0x800'266c: 0xe8bc 0x0ff0   LDM      R12!, {R4-R11}
  //     MSR     PSP, r12                                // Setup the thread's stack pointer
  0x800'2670: 0xf38c 0x8809   MSR      PSP, R12
  //     BX      lr                                      // Return to thread!
  0x800'2674: 0x4770          BX       LR
                __tx_ts_wait:
  //     CPSID   i                                       // Disable interrupts
  0x800'2676: 0xb672          CPSID    i
  //     LDR     r1, [r2]                                // Pickup the next thread to execute pointer
  0x800'2678: 0x6811          LDR      R1, [R2]
  //     STR     r1, [r0]                                // Store it in the current pointer
  0x800'267a: 0x6001          STR      R1, [R0]
  //     CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
  0x800'267c: 0xb909          CBNZ     R1, __tx_ts_ready      ; 0x800'2682
  //     CPSIE   i                                       // Enable interrupts
  0x800'267e: 0xb662          CPSIE    i
  //     B       __tx_ts_wait                            // Loop to continue waiting
  0x800'2680: 0xe7f9          B.N      __tx_ts_wait           ; 0x800'2676
                __tx_ts_ready:
  //     MOV     r7, #0x08000000                         // Build clear PendSV value
  0x800'2682: 0xf04f 0x6700   MOV.W    R7, #134217728         ; 0x800'0000
  //     MOV     r8, #0xE000E000                         // Build base NVIC address
  0x800'2686: 0xf04f 0x28e0   MOV.W    R8, #-536813568        ; 0xe000'e000
  //     STR     r7, [r8, #0xD04]                        // Clear any PendSV
  0x800'268a: 0xf8c8 0x7d04   STR.W    R7, [R8, #0xd04]
  //     CPSIE   i                                       // Enable interrupts
  0x800'268e: 0xb662          CPSIE    i
  //     B       __tx_ts_restore                         // Restore the thread
  0x800'2690: 0xe7dc          B.N      __tx_ts_restore        ; 0x800'264c
                tx_thread_fpu_enable:
                tx_thread_fpu_disable:
  //     BX      LR                                      // Return to caller
  0x800'2692: 0x4770          BX       LR
                `$d.32`:
  //     END
  0x800'2694: 0x2000'0244     DC32     _tx_thread_preempt_disable
  //     END
  0x800'2698: 0x2000'0234     DC32     _tx_thread_current_ptr
  //     END
  0x800'269c: 0x2000'0238     DC32     _tx_thread_execute_ptr
  //     END
  0x800'26a0: 0x2000'027c     DC32     _tx_timer_time_slice
                $t:
                `.text6`:
                _tx_timer_interrupt:
  //     LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
  0x800'26a4: 0x4921          LDR.N    R1, [PC, #0x84]        ; _tx_timer_system_clock
  //     LDR     r0, [r1, #0]                            // Pickup system clock
  0x800'26a6: 0x6808          LDR      R0, [R1]
  //     ADD     r0, r0, #1                              // Increment system clock
  0x800'26a8: 0xf100 0x0001   ADD.W    R0, R0, #1
  //     STR     r0, [r1, #0]                            // Store new system clock
  0x800'26ac: 0x6008          STR      R0, [R1]
  //     LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
  0x800'26ae: 0x4b20          LDR.N    R3, [PC, #0x80]        ; _tx_timer_time_slice
  //     LDR     r2, [r3, #0]                            // Pickup time-slice
  0x800'26b0: 0x681a          LDR      R2, [R3]
  //     CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
  0x800'26b2: 0xb13a          CBZ      R2, __tx_timer_no_time_slice
                                                              ; 0x800'26c4
  //     SUB     r2, r2, #1                              // Decrement the time-slice
  0x800'26b4: 0xf1a2 0x0201   SUB.W    R2, R2, #1
  //     STR     r2, [r3, #0]                            // Store new time-slice value
  0x800'26b8: 0x601a          STR      R2, [R3]
  //     CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
  0x800'26ba: 0xb91a          CBNZ     R2, __tx_timer_no_time_slice
                                                              ; 0x800'26c4
  //     LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
  0x800'26bc: 0x4b1d          LDR.N    R3, [PC, #0x74]        ; _tx_timer_expired_time_slice
  //     MOV     r0, #1                                  // Build expired value
  0x800'26be: 0xf04f 0x0001   MOV.W    R0, #1
  //     STR     r0, [r3, #0]                            // Set time-slice expiration flag
  0x800'26c2: 0x6018          STR      R0, [R3]
                __tx_timer_no_time_slice:
  //     LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
  0x800'26c4: 0x491c          LDR.N    R1, [PC, #0x70]        ; _tx_timer_current_ptr
  //     LDR     r0, [r1, #0]                            // Pickup current timer
  0x800'26c6: 0x6808          LDR      R0, [R1]
  //     LDR     r2, [r0, #0]                            // Pickup timer list entry
  0x800'26c8: 0x6802          LDR      R2, [R0]
  //     CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
  0x800'26ca: 0xb122          CBZ      R2, __tx_timer_no_timer
                                                              ; 0x800'26d6
  //     LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
  0x800'26cc: 0x4b1b          LDR.N    R3, [PC, #0x6c]        ; _tx_timer_expired
  //     MOV     r2, #1                                  // Build expired value
  0x800'26ce: 0xf04f 0x0201   MOV.W    R2, #1
  //     STR     r2, [r3, #0]                            // Set expired flag
  0x800'26d2: 0x601a          STR      R2, [R3]
  //     B       __tx_timer_done                         // Finished timer processing
  0x800'26d4: 0xe008          B.N      __tx_timer_done        ; 0x800'26e8
                __tx_timer_no_timer:
  //     ADD     r0, r0, #4                              // Move to next timer
  0x800'26d6: 0xf100 0x0004   ADD.W    R0, R0, #4
  //     LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
  0x800'26da: 0x4b19          LDR.N    R3, [PC, #0x64]        ; _tx_timer_list_end
  //     LDR     r2, [r3, #0]                            // Pickup list end
  0x800'26dc: 0x681a          LDR      R2, [R3]
  //     CMP     r0, r2                                  // Are we at list end?
  0x800'26de: 0x4290          CMP      R0, R2
  //     BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
  0x800'26e0: 0xd101          BNE.N    __tx_timer_skip_wrap   ; 0x800'26e6
  //     LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
  0x800'26e2: 0x4b18          LDR.N    R3, [PC, #0x60]        ; _tx_timer_list_start
  //     LDR     r0, [r3, #0]                            // Set current pointer to list start
  0x800'26e4: 0x6818          LDR      R0, [R3]
                __tx_timer_skip_wrap:
  //     STR     r0, [r1, #0]                            // Store new current timer pointer
  0x800'26e6: 0x6008          STR      R0, [R1]
                __tx_timer_done:
  //     LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
  0x800'26e8: 0x4b12          LDR.N    R3, [PC, #0x48]        ; _tx_timer_expired_time_slice
  //     LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
  0x800'26ea: 0x681a          LDR      R2, [R3]
  //     CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
  0x800'26ec: 0xb912          CBNZ     R2, __tx_something_expired
                                                              ; 0x800'26f4
  //     LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
  0x800'26ee: 0x4913          LDR.N    R1, [PC, #0x4c]        ; _tx_timer_expired
  //     LDR     r0, [r1, #0]                            // Pickup timer expired flag
  0x800'26f0: 0x6808          LDR      R0, [R1]
  //     CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
  0x800'26f2: 0xb1c0          CBZ      R0, __tx_timer_nothing_expired
                                                              ; 0x800'2726
                __tx_something_expired:
  //     STMDB   sp!, {r0, lr}                           // Save the lr register on the stack
  0x800'26f4: 0xb501          PUSH     {R0, LR}
  //     LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
  0x800'26f6: 0x4911          LDR.N    R1, [PC, #0x44]        ; _tx_timer_expired
  //     LDR     r0, [r1, #0]                            // Pickup timer expired flag
  0x800'26f8: 0x6808          LDR      R0, [R1]
  //     CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
  0x800'26fa: 0xb108          CBZ      R0, __tx_timer_dont_activate
                                                              ; 0x800'2700
  //     BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
  0x800'26fc: 0xf000 0xf82e   BL       _tx_timer_expiration_process
                                                              ; 0x800'275c
                __tx_timer_dont_activate:
  //     LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
  0x800'2700: 0x4b0c          LDR.N    R3, [PC, #0x30]        ; _tx_timer_expired_time_slice
  //     LDR     r2, [r3, #0]                            // Pickup the actual flag
  0x800'2702: 0x681a          LDR      R2, [R3]
  //     CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
  0x800'2704: 0xb16a          CBZ      R2, __tx_timer_skip_time_slice
                                                              ; 0x800'2722
  //     BL      _tx_thread_time_slice                   // Call time-slice processing
  0x800'2706: 0xf7ff 0xfe39   BL       _tx_thread_time_slice  ; 0x800'237c
  //     LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
  0x800'270a: 0x480f          LDR.N    R0, [PC, #0x3c]        ; _tx_thread_preempt_disable
  //     LDR     r1, [r0]                                // Is the preempt disable flag set?
  0x800'270c: 0x6801          LDR      R1, [R0]
  //     CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
  0x800'270e: 0xb941          CBNZ     R1, __tx_timer_skip_time_slice
                                                              ; 0x800'2722
  //     LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
  0x800'2710: 0x480e          LDR.N    R0, [PC, #0x38]        ; _tx_thread_current_ptr
  //     LDR     r1, [r0]                                // Pickup the current thread pointer
  0x800'2712: 0x6801          LDR      R1, [R0]
  //     LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
  0x800'2714: 0x4a0e          LDR.N    R2, [PC, #0x38]        ; _tx_thread_execute_ptr
  //     LDR     r3, [r2]                                // Pickup the execute thread pointer
  0x800'2716: 0x6813          LDR      R3, [R2]
  //     LDR     r0, =0xE000ED04                         // Build address of control register
  0x800'2718: 0x480e          LDR.N    R0, [PC, #0x38]        ; 0xe000'ed04
  //     LDR     r2, =0x10000000                         // Build value for PendSV bit
  0x800'271a: 0x4a0f          LDR.N    R2, [PC, #0x3c]        ; 0x1000'0000
  //     CMP     r1, r3                                  // Are they the same?
  0x800'271c: 0x4299          CMP      R1, R3
  //     BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
  0x800'271e: 0xd000          BEQ.N    __tx_timer_skip_time_slice
                                                              ; 0x800'2722
  //     STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
  0x800'2720: 0x6002          STR      R2, [R0]
                __tx_timer_not_ts_expiration:
                __tx_timer_skip_time_slice:
  //     LDMIA   sp!, {r0, lr}                           // Recover lr register (r0 is just there for
  0x800'2722: 0xe8bd 0x4001   POP.W    {R0, LR}
                __tx_timer_nothing_expired:
  //     DSB                                             // Complete all memory access
  0x800'2726: 0xf3bf 0x8f4f   DSB
  //     BX      lr                                      // Return to caller
  0x800'272a: 0x4770          BX       LR
                `$d.32`:
  //     END
  0x800'272c: 0x2000'0264     DC32     _tx_timer_system_clock
  //     END
  0x800'2730: 0x2000'027c     DC32     _tx_timer_time_slice
  //     END
  0x800'2734: 0x2000'0268     DC32     _tx_timer_expired_time_slice
  //     END
  0x800'2738: 0x2000'0274     DC32     _tx_timer_current_ptr
  //     END
  0x800'273c: 0x2000'0278     DC32     _tx_timer_expired
  //     END
  0x800'2740: 0x2000'0270     DC32     _tx_timer_list_end
  //     END
  0x800'2744: 0x2000'026c     DC32     _tx_timer_list_start
  //     END
  0x800'2748: 0x2000'0244     DC32     _tx_thread_preempt_disable
  //     END
  0x800'274c: 0x2000'0234     DC32     _tx_thread_current_ptr
  //     END
  0x800'2750: 0x2000'0238     DC32     _tx_thread_execute_ptr
  //     END
  0x800'2754: 0xe000'ed04     DC32     0xe000'ed04            ; '....'
  //     END
  0x800'2758: 0x1000'0000     DC32     0x1000'0000            ; '....'
                $t:
                `.text8`:
                _tx_timer_expiration_process:
  // VOID  _tx_timer_expiration_process(VOID)
  // {
  0x800'275c: 0xb510          PUSH     {R4, LR}
  //     __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
  0x800'275e: 0xf3ef 0x8410   MRS      R4, PRIMASK
  //     return(posture);
  0x800'2762: 0xb672          CPSID    i
  //     return(int_posture);
  0x800'2764: 0x4803          LDR.N    R0, ??_tx_timer_expiration_process_0
                                                              ; _tx_timer_thread
  0x800'2766: 0xf7ff 0xfbd1   BL       _tx_thread_system_ni_resume
                                                              ; 0x800'1f0c
  //     TX_RESTORE
  0x800'276a: 0x0020          MOVS     R0, R4
  //     __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
  0x800'276c: 0xf380 0x8810   MSR      PRIMASK, R0
  // }
  0x800'2770: 0xbd10          POP      {R4, PC}
  0x800'2772: 0xbf00          NOP
                `$d.32`:
                ??_tx_timer_expiration_process_0:
  0x800'2774: 0x2000'0010     DC32     _tx_timer_thread
                $t:
                `.text7`:
                _tx_initialize_low_level:
  //     CPSID   i                                       ; Disable interrupts
  0x800'2778: 0xb672          CPSID    i
  //     LDR     r0, =__tx_free_memory_start             ; Get end of non-initialized RAM area
  0x800'277a: 0x4814          LDR.N    R0, [PC, #0x50]        ; __tx_free_memory_start
  //     LDR     r2, =_tx_initialize_unused_memory       ; Build address of unused memory pointer
  0x800'277c: 0x4a14          LDR.N    R2, [PC, #0x50]        ; _tx_initialize_unused_memory
  //     STR     r0, [r2, #0]                            ; Save first free memory address
  0x800'277e: 0x6010          STR      R0, [R2]
  //     LDR     r0, =0xE0001000                         ; Build address of DWT register
  0x800'2780: 0x4814          LDR.N    R0, [PC, #0x50]        ; 0xe000'1000
  //     LDR     r1, [r0]                                ; Pickup the current value
  0x800'2782: 0x6801          LDR      R1, [R0]
  //     ORR     r1, r1, #1                              ; Set the CYCCNTENA bit
  0x800'2784: 0xf041 0x0101   ORR.W    R1, R1, #1
  //     STR     r1, [r0]                                ; Enable the cycle count register
  0x800'2788: 0x6001          STR      R1, [R0]
  //     MOV     r0, #0xE000E000                         ; Build address of NVIC registers
  0x800'278a: 0xf04f 0x20e0   MOV.W    R0, #-536813568        ; 0xe000'e000
  //     LDR     r1, =__vector_table                     ; Pickup address of vector table
  0x800'278e: 0x4912          LDR.N    R1, [PC, #0x48]        ; __vector_table
  //     STR     r1, [r0, #0xD08]                        ; Set vector table address
  0x800'2790: 0xf8c0 0x1d08   STR.W    R1, [R0, #0xd08]
  //     LDR     r0, =_tx_thread_system_stack_ptr        ; Build address of system stack pointer
  0x800'2794: 0x4811          LDR.N    R0, [PC, #0x44]        ; _tx_thread_system_stack_ptr
  //     LDR     r1, =__vector_table                     ; Pickup address of vector table
  0x800'2796: 0x4910          LDR.N    R1, [PC, #0x40]        ; __vector_table
  //     LDR     r1, [r1]                                ; Pickup reset stack pointer
  0x800'2798: 0x6809          LDR      R1, [R1]
  //     STR     r1, [r0]                                ; Save system stack pointer
  0x800'279a: 0x6001          STR      R1, [R0]
  //     MOV     r0, #0xE000E000                         ; Build address of NVIC registers
  0x800'279c: 0xf04f 0x20e0   MOV.W    R0, #-536813568        ; 0xe000'e000
  //     LDR     r1, =SYSTICK_CYCLES
  0x800'27a0: 0x490f          LDR.N    R1, [PC, #0x3c]        ; SYSTICK_CYCLES
  //     STR     r1, [r0, #0x14]                         ; Setup SysTick Reload Value
  0x800'27a2: 0x6141          STR      R1, [R0, #0x14]
  //     MOV     r1, #0x7                                ; Build SysTick Control Enable Value
  0x800'27a4: 0xf04f 0x0107   MOV.W    R1, #7
  //     STR     r1, [r0, #0x10]                         ; Setup SysTick Control
  0x800'27a8: 0x6101          STR      R1, [R0, #0x10]
  //     LDR     r1, =0x00000000                         ; Rsrv, UsgF, BusF, MemM
  0x800'27aa: 0x2100          MOVS     R1, #0
  //     STR     r1, [r0, #0xD18]                        ; Setup System Handlers 4-7 Priority Registers
  0x800'27ac: 0xf8c0 0x1d18   STR.W    R1, [R0, #0xd18]
  //     LDR     r1, =0xFF000000                         ; SVCl, Rsrv, Rsrv, Rsrv
  0x800'27b0: 0x490c          LDR.N    R1, [PC, #0x30]        ; 0xff00'0000
  //     STR     r1, [r0, #0xD1C]                        ; Setup System Handlers 8-11 Priority Registers
  0x800'27b2: 0xf8c0 0x1d1c   STR.W    R1, [R0, #0xd1c]
  //     LDR     r1, =0x40FF0000                         ; SysT, PnSV, Rsrv, DbgM
  0x800'27b6: 0x490c          LDR.N    R1, [PC, #0x30]        ; 0x40ff'0000
  //     STR     r1, [r0, #0xD20]                        ; Setup System Handlers 12-15 Priority Registers
  0x800'27b8: 0xf8c0 0x1d20   STR.W    R1, [R0, #0xd20]
  //     BX      lr
  0x800'27bc: 0x4770          BX       LR
                SysTick_Handler:
                __tx_SysTickHandler:
  //     PUSH    {r0, lr}
  0x800'27be: 0xb501          PUSH     {R0, LR}
  //     BL      _tx_timer_interrupt
  0x800'27c0: 0xf7ff 0xff70   BL       _tx_timer_interrupt    ; 0x800'26a4
  //     POP     {r0, lr}
  0x800'27c4: 0xe8bd 0x4001   POP.W    {R0, LR}
  //     BX      LR
  0x800'27c8: 0x4770          BX       LR
  0x800'27ca: 0x0000          MOVS     R0, R0
                `$d.32`:
  //     END
  0x800'27cc: 0x2000'0218     DC32     __tx_free_memory_start
  //     END
  0x800'27d0: 0x2000'022c     DC32     _tx_initialize_unused_memory
  //     END
  0x800'27d4: 0xe000'1000     DC32     0xe000'1000            ; '....'
  //     END
  0x800'27d8: 0x0800'0000     DC32     __vector_table
  //     END
  0x800'27dc: 0x2000'0230     DC32     _tx_thread_system_stack_ptr
  //     END
  0x800'27e0: 0x0003'd08f     DC32     SYSTICK_CYCLES
  //     END
  0x800'27e4: 0xff00'0000     DC32     0xff00'0000            ; '....'
  //     END
  0x800'27e8: 0x40ff'0000     DC32     0x40ff'0000            ; '...@'
                $t:
                `.text8`:
                MX_GPIO_Init:
  // void MX_GPIO_Init(void)
  // {
  0x800'27ec: 0xb081          SUB      SP, SP, #0x4
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'27ee: 0x2000          MOVS     R0, #0
  0x800'27f0: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'27f2: 0x4811          LDR.N    R0, ??MX_GPIO_Init_0   ; 0x4002'3830
  0x800'27f4: 0x6801          LDR      R1, [R0]
  0x800'27f6: 0xf051 0x0104   ORRS.W   R1, R1, #4
  0x800'27fa: 0x6001          STR      R1, [R0]
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'27fc: 0x6801          LDR      R1, [R0]
  0x800'27fe: 0xf011 0x0104   ANDS.W   R1, R1, #4
  0x800'2802: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOC_CLK_ENABLE();
  0x800'2804: 0x9900          LDR      R1, [SP]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'2806: 0x2100          MOVS     R1, #0
  0x800'2808: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'280a: 0x6801          LDR      R1, [R0]
  0x800'280c: 0xf051 0x0180   ORRS.W   R1, R1, #128           ; 0x80
  0x800'2810: 0x6001          STR      R1, [R0]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'2812: 0x6801          LDR      R1, [R0]
  0x800'2814: 0xf011 0x0180   ANDS.W   R1, R1, #128           ; 0x80
  0x800'2818: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOH_CLK_ENABLE();
  0x800'281a: 0x9900          LDR      R1, [SP]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'281c: 0x2100          MOVS     R1, #0
  0x800'281e: 0x9100          STR      R1, [SP]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'2820: 0x6801          LDR      R1, [R0]
  0x800'2822: 0xf051 0x0101   ORRS.W   R1, R1, #1
  0x800'2826: 0x6001          STR      R1, [R0]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'2828: 0x6800          LDR      R0, [R0]
  0x800'282a: 0xf010 0x0001   ANDS.W   R0, R0, #1
  0x800'282e: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_GPIOA_CLK_ENABLE();
  0x800'2830: 0x9800          LDR      R0, [SP]
  // }
  0x800'2832: 0xb001          ADD      SP, SP, #0x4
  0x800'2834: 0x4770          BX       LR
  0x800'2836: 0xbf00          NOP
                `$d.32`:
                ??MX_GPIO_Init_0:
  0x800'2838: 0x4002'3830     DC32     0x4002'3830            ; '08.@'
                $t:
                `.text8`:
                __write:
  // size_t __write(int handle, const unsigned char * buffer, size_t size) {
  0x800'283c: 0xb570          PUSH     {R4-R6, LR}
  0x800'283e: 0x0006          MOVS     R6, R0
  0x800'2840: 0x000c          MOVS     R4, R1
  0x800'2842: 0x0015          MOVS     R5, R2
  //     if(HAL_UART_Transmit(&huart1, (uint8_t *)buffer, size, 0xFFFF) == HAL_OK) {
  0x800'2844: 0xf64f 0x73ff   MOVW     R3, #65535             ; 0xffff
  0x800'2848: 0x002a          MOVS     R2, R5
  0x800'284a: 0xb292          UXTH     R2, R2
  0x800'284c: 0x0021          MOVS     R1, R4
  0x800'284e: 0x480c          LDR.N    R0, ??DataTable8       ; huart1
  0x800'2850: 0xf7fd 0xfd45   BL       HAL_UART_Transmit      ; 0x800'02de
  0x800'2854: 0x2800          CMP      R0, #0
  0x800'2856: 0xd101          BNE.N    ??__write_0            ; 0x800'285c
  //         return size;
  0x800'2858: 0x0028          MOVS     R0, R5
  0x800'285a: 0xe001          B.N      ??__write_1            ; 0x800'2860
                ??__write_0:
  //         return _LLIO_ERROR;
  0x800'285c: 0xf05f 0x30ff   MOVS.W   R0, #-1                ; 0xffff'ffff
                ??__write_1:
  0x800'2860: 0xbd70          POP      {R4-R6, PC}
                `.text_18`:
                main:
  // int main(void) {
  0x800'2862: 0xb580          PUSH     {R7, LR}
  //     HAL_Init();
  0x800'2864: 0xf000 0xf810   BL       HAL_Init               ; 0x800'2888
  //     MX_GPIO_Init();
  0x800'2868: 0xf7ff 0xffc0   BL       MX_GPIO_Init           ; 0x800'27ec
  //     MX_USART1_UART_Init();
  0x800'286c: 0xf7fe 0xfa86   BL       MX_USART1_UART_Init    ; 0x800'0d7c
                ??main_0:
  //         printf("hello qemu.\r\n");
  0x800'2870: 0x4804          LDR.N    R0, ??DataTable8_8     ; ?_1
  0x800'2872: 0xf7fe 0xfca5   BL       printf                 ; 0x800'11c0
  //         HAL_Delay(1000);
  0x800'2876: 0xf44f 0x707a   MOV.W    R0, #1000              ; 0x3e8
  0x800'287a: 0xf000 0xf81f   BL       HAL_Delay              ; 0x800'28bc
  0x800'287e: 0xe7f7          B.N      ??main_0               ; 0x800'2870
                `$d.32`:
                ??DataTable8:
  0x800'2880: 0x2000'0168     DC32     huart1
                ??DataTable8_8:
  0x800'2884: 0x0800'2b94     DC32     ?_1
                $t:
                `.text11`:
                HAL_Init:
  // HAL_StatusTypeDef HAL_Init(void)
  // {
  0x800'2888: 0xb580          PUSH     {R7, LR}
  //   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
  0x800'288a: 0x480b          LDR.N    R0, ??DataTable18      ; 0x4002'3c00
  0x800'288c: 0x6801          LDR      R1, [R0]
  0x800'288e: 0xf451 0x7100   ORRS.W   R1, R1, #512           ; 0x200
  0x800'2892: 0x6001          STR      R1, [R0]
  //   __HAL_FLASH_DATA_CACHE_ENABLE();
  0x800'2894: 0x6801          LDR      R1, [R0]
  0x800'2896: 0xf451 0x6180   ORRS.W   R1, R1, #1024          ; 0x400
  0x800'289a: 0x6001          STR      R1, [R0]
  //   __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  0x800'289c: 0x6801          LDR      R1, [R0]
  0x800'289e: 0xf451 0x7180   ORRS.W   R1, R1, #256           ; 0x100
  0x800'28a2: 0x6001          STR      R1, [R0]
  //   HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  0x800'28a4: 0x2003          MOVS     R0, #3
  0x800'28a6: 0xf7ff 0xfa1b   BL       HAL_NVIC_SetPriorityGrouping
                                                              ; 0x800'1ce0
  //   HAL_InitTick(TICK_INT_PRIORITY);
  0x800'28aa: 0x200f          MOVS     R0, #15                ; 0xf
  0x800'28ac: 0xf7ff 0xfe34   BL       HAL_InitTick           ; 0x800'2518
  //   HAL_MspInit();
  0x800'28b0: 0xf000 0xf818   BL       HAL_MspInit            ; 0x800'28e4
  //   return HAL_OK;
  0x800'28b4: 0x2000          MOVS     R0, #0
  0x800'28b6: 0xbd02          POP      {R1, PC}
                `$d.32`:
                ??DataTable18:
  0x800'28b8: 0x4002'3c00     DC32     0x4002'3c00            ; '.<.@'
                $t:
                `.text23`:
                HAL_Delay:
  // __weak void HAL_Delay(uint32_t Delay)
  // {
  0x800'28bc: 0xb570          PUSH     {R4-R6, LR}
  0x800'28be: 0x0004          MOVS     R4, R0
  //   uint32_t tickstart = HAL_GetTick();
  0x800'28c0: 0xf7fe 0xfabe   BL       HAL_GetTick            ; 0x800'0e40
  0x800'28c4: 0x0005          MOVS     R5, R0
  //   uint32_t wait = Delay;
  0x800'28c6: 0x0026          MOVS     R6, R4
  //   if (wait < HAL_MAX_DELAY)
  0x800'28c8: 0xf116 0x0f01   CMN.W    R6, #1
  0x800'28cc: 0xd002          BEQ.N    ??HAL_Delay_1          ; 0x800'28d4
  //     wait += (uint32_t)(uwTickFreq);
  0x800'28ce: 0x4804          LDR.N    R0, ??HAL_Delay_0      ; uwTickFreq
  0x800'28d0: 0x7800          LDRB     R0, [R0]
  0x800'28d2: 0x1836          ADDS     R6, R6, R0
                ??HAL_Delay_1:
  //   while((HAL_GetTick() - tickstart) < wait)
  0x800'28d4: 0xf7fe 0xfab4   BL       HAL_GetTick            ; 0x800'0e40
  0x800'28d8: 0x1b40          SUBS     R0, R0, R5
  0x800'28da: 0x42b0          CMP      R0, R6
  0x800'28dc: 0xd3fa          BCC.N    ??HAL_Delay_1          ; 0x800'28d4
  // }
  0x800'28de: 0xbd70          POP      {R4-R6, PC}
                `$d.32`:
                ??HAL_Delay_0:
  0x800'28e0: 0x2000'000c     DC32     uwTickFreq
                $t:
                `.text8`:
                HAL_MspInit:
  // void HAL_MspInit(void)
  // {
  0x800'28e4: 0xb081          SUB      SP, SP, #0x4
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'28e6: 0x2000          MOVS     R0, #0
  0x800'28e8: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'28ea: 0x490c          LDR.N    R1, ??HAL_MspInit_0    ; 0x4002'3844
  0x800'28ec: 0x6808          LDR      R0, [R1]
  0x800'28ee: 0xf450 0x4080   ORRS.W   R0, R0, #16384         ; 0x4000
  0x800'28f2: 0x6008          STR      R0, [R1]
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'28f4: 0x6808          LDR      R0, [R1]
  0x800'28f6: 0xf410 0x4080   ANDS.W   R0, R0, #16384         ; 0x4000
  0x800'28fa: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_SYSCFG_CLK_ENABLE();
  0x800'28fc: 0x9800          LDR      R0, [SP]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'28fe: 0x2000          MOVS     R0, #0
  0x800'2900: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'2902: 0x4907          LDR.N    R1, [PC, #0x1c]        ; 0x4002'3840
  0x800'2904: 0x6808          LDR      R0, [R1]
  0x800'2906: 0xf050 0x5080   ORRS.W   R0, R0, #268435456     ; 0x1000'0000
  0x800'290a: 0x6008          STR      R0, [R1]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'290c: 0x6808          LDR      R0, [R1]
  0x800'290e: 0xf010 0x5080   ANDS.W   R0, R0, #268435456     ; 0x1000'0000
  0x800'2912: 0x9000          STR      R0, [SP]
  //   __HAL_RCC_PWR_CLK_ENABLE();
  0x800'2914: 0x9800          LDR      R0, [SP]
  // }
  0x800'2916: 0xb001          ADD      SP, SP, #0x4
  0x800'2918: 0x4770          BX       LR
  0x800'291a: 0xbf00          NOP
                `$d.32`:
                ??HAL_MspInit_0:
  0x800'291c: 0x4002'3844     DC32     0x4002'3844            ; 'D8.@'
  0x800'2920: 0x4002'3840     DC32     0x4002'3840            ; '@8.@'
                `$d.8`:
                ?_0:
  0x800'2924: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'2938: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'294c: 0x32 0x66 0x34  DC8      "2f4xx_hal_uart.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x75 0x61
              0x72 0x74 0x2e
              0x63 0x00
                $d:
  0x800'295d: 0x00            DC8      0                      ; '.'
  0x800'295e: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                ?_0:
  0x800'2960: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'2974: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'2988: 0x32 0x66 0x34  DC8      "2f4xx_hal_gpio.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x67 0x70
              0x69 0x6f 0x2e
              0x63 0x00
                $d:
  0x800'2999: 0x00            DC8      0                      ; '.'
  0x800'299a: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                ?_0:
  0x800'299c: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'29b0: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'29c4: 0x32 0x66 0x34  DC8      "2f4xx_hal_cortex.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x63 0x6f
              0x72 0x74 0x65
              0x78 0x2e 0x63
              0x00
  0x800'29d7: 0x00            DC8      0                      ; '.'
                ?_0:
  0x800'29d8: 0x2e 0x2e 0x5c  DC8      '..\Drivers\STM32F4xx'
              0x44 0x72 0x69
              0x76 0x65 0x72
              0x73 0x5c 0x53
              0x54 0x4d 0x33
              0x32 0x46 0x34
              0x78 0x78
  0x800'29ec: 0x5f 0x48 0x41  DC8      '_HAL_Driver\Src\stm3'
              0x4c 0x5f 0x44
              0x72 0x69 0x76
              0x65 0x72 0x5c
              0x53 0x72 0x63
              0x5c 0x73 0x74
              0x6d 0x33
  0x800'2a00: 0x32 0x66 0x34  DC8      "2f4xx_hal_tim.c"
              0x78 0x78 0x5f
              0x68 0x61 0x6c
              0x5f 0x74 0x69
              0x6d 0x2e 0x63
              0x00
                $t:
                `.text7`:
                __iar_zero_init3:
  0x800'2a10: 0xb430          PUSH     {R4, R5}
  0x800'2a12: 0x2400          MOVS     R4, #0
  0x800'2a14: 0xe012          B.N      ??__iar_zero_init3_1   ; 0x800'2a3c
                ??__iar_zero_init3_3:
  0x800'2a16: 0xf850 0x3b04   LDR.W    R3, [R0], #0x4
  0x800'2a1a: 0x07da          LSLS     R2, R3, #31
  0x800'2a1c: 0xbf44          ITT      MI
  0x800'2a1e: 0x444b          ADDMI    R3, R3, R9
  0x800'2a20: 0x1e5b          SUBMI    R3, R3, #1
                ??__iar_zero_init3_2:
  0x800'2a22: 0x1f09          SUBS     R1, R1, #4
  0x800'2a24: 0x2904          CMP      R1, #4
  0x800'2a26: 0xf843 0x4b04   STR.W    R4, [R3], #0x4
  0x800'2a2a: 0xd2fa          BCS.N    ??__iar_zero_init3_2   ; 0x800'2a22
  0x800'2a2c: 0x461a          MOV      R2, R3
  0x800'2a2e: 0x078d          LSLS     R5, R1, #30
  0x800'2a30: 0xbf44          ITT      MI
  0x800'2a32: 0x801c          STRHMI   R4, [R3]
  0x800'2a34: 0x1c92          ADDMI    R2, R2, #2
  0x800'2a36: 0x07cb          LSLS     R3, R1, #31
  0x800'2a38: 0xbf48          IT       MI
  0x800'2a3a: 0x7014          STRBMI   R4, [R2]
                ??__iar_zero_init3_1:
  0x800'2a3c: 0xf850 0x1b04   LDR.W    R1, [R0], #0x4
  0x800'2a40: 0x2900          CMP      R1, #0
  0x800'2a42: 0xd1e8          BNE.N    ??__iar_zero_init3_3   ; 0x800'2a16
  0x800'2a44: 0xbc30          POP      {R4, R5}
  0x800'2a46: 0x4770          BX       LR
                `.text6`:
                __iar_data_init3:
  0x800'2a48: 0xb510          PUSH     {R4, LR}
  0x800'2a4a: 0x4a03          LDR.N    R2, ??__iar_data_init3_0
                                                              ; 0x40 (64)
  0x800'2a4c: 0x447a          ADD      R2, R2, PC
  0x800'2a4e: 0x3208          ADDS     R2, R2, #8
  0x800'2a50: 0x4c02          LDR.N    R4, [PC, #0x8]         ; 0x60 (96)
  0x800'2a52: 0x447c          ADD      R4, R4, PC
  0x800'2a54: 0x1da4          ADDS     R4, R4, #6
  0x800'2a56: 0xe003          B.N      ?Subroutine0           ; 0x800'2a60
                `$d.32`:
                ??__iar_data_init3_0:
  0x800'2a58: 0x0000'0040     DC32     64                     ; '@...'
  0x800'2a5c: 0x0000'0060     DC32     96                     ; '`...'
                $t:
                `.text_4`:
                ?Subroutine0:
  0x800'2a60: 0xe004          B.N      ??Subroutine0_0        ; 0x800'2a6c
                ??Subroutine0_1:
  0x800'2a62: 0x6811          LDR      R1, [R2]
  0x800'2a64: 0x1d10          ADDS     R0, R2, #4
  0x800'2a66: 0x4411          ADD      R1, R1, R2
  0x800'2a68: 0x4788          BLX      R1
  0x800'2a6a: 0x4602          MOV      R2, R0
                ??Subroutine0_0:
  0x800'2a6c: 0x42a2          CMP      R2, R4
  0x800'2a6e: 0xd1f8          BNE.N    ??Subroutine0_1        ; 0x800'2a62
  0x800'2a70: 0xbd10          POP      {R4, PC}
  0x800'2a72: 0x0000          MOVS     R0, R0
                `.text6`:
                __iar_init_vfp:
  0x800'2a74: 0xf64e 0x5188   MOVW     R1, #60808             ; 0xed88
  0x800'2a78: 0xf2ce 0x0100   MOVT     R1, #57344             ; 0xe000
  0x800'2a7c: 0x6808          LDR      R0, [R1]
  0x800'2a7e: 0xf440 0x0070   ORR.W    R0, R0, #15728640      ; 0xf0'0000
  0x800'2a82: 0x6008          STR      R0, [R1]
  0x800'2a84: 0xf3bf 0x8f4f   DSB
  0x800'2a88: 0xf3bf 0x8f6f   ISB
  0x800'2a8c: 0xf04f 0x7001   MOV.W    R0, #33816576          ; 0x204'0000
  0x800'2a90: 0xeee1 0x0a10   VMSR     FPSCR, R0
  0x800'2a94: 0x4770          BX       LR
  0x800'2a96: 0x0000          MOVS     R0, R0
                $d:
                Region$$Table$$Base:
                `.iar.init_table$$Base`:
  0x800'2a98: 0xffff'ff79     DC32     -135                   ; 'y...'
  0x800'2a9c: 0x0000'0270     DC32     624                    ; 'p...'
  0x800'2aa0: 0x2000'0010     DC32     _tx_timer_thread
  0x800'2aa4: 0x0000'0000     DC32     0                      ; '....'
  0x800'2aa8: 0xffff'ed1b     DC32     -4837                  ; '....'
  0x800'2aac: 0x0000'0010     DC32     16                     ; '....'
  0x800'2ab0: 0x0000'0144     DC32     324                    ; 'D...'
  0x800'2ab4: 0x2000'0000     DC32     uwTickPrio
  0x800'2ab8: 0x0000'0000     DC32     0                      ; '....'
                $t:
                `.text6`:
                Region$$Table$$Limit:
                `.iar.init_table$$Limit`:
                putchar:
  0x800'2abc: 0xb580          PUSH     {R7, LR}
  0x800'2abe: 0xf88d 0x0000   STRB.W   R0, [SP]
  0x800'2ac2: 0x2201          MOVS     R2, #1
  0x800'2ac4: 0x4669          MOV      R1, SP
  0x800'2ac6: 0x2001          MOVS     R0, #1
  0x800'2ac8: 0xf7ff 0xfeb8   BL       __write                ; 0x800'283c
  0x800'2acc: 0x2801          CMP      R0, #1
  0x800'2ace: 0xd102          BNE.N    ??putchar_0            ; 0x800'2ad6
  0x800'2ad0: 0xf89d 0x0000   LDRB.W   R0, [SP]
  0x800'2ad4: 0xbd02          POP      {R1, PC}
                ??putchar_0:
  0x800'2ad6: 0xf04f 0x30ff   MOV.W    R0, #-1                ; 0xffff'ffff
  0x800'2ada: 0xbd02          POP      {R1, PC}
                `.text8`:
                __cmain:
                ?main:
  0x800'2adc: 0xf000 0xf80d   BL       __low_level_init       ; 0x800'2afa
  0x800'2ae0: 0x2800          CMP      R0, #0
  0x800'2ae2: 0xd001          BEQ.N    _call_main             ; 0x800'2ae8
  0x800'2ae4: 0xf7ff 0xffb0   BL       __iar_data_init3       ; 0x800'2a48
                `.text_3`:
                _call_main:
  0x800'2ae8: 0xf3af 0x8000   NOP.W
  0x800'2aec: 0x2000          MOVS     R0, #0
  0x800'2aee: 0xf3af 0x8000   NOP.W
  0x800'2af2: 0xf7ff 0xfeb6   BL       main                   ; 0x800'2862
  0x800'2af6: 0xf000 0xf802   BL       exit                   ; 0x800'2afe
                `.text6`:
                __low_level_init:
  0x800'2afa: 0x2001          MOVS     R0, #1
  0x800'2afc: 0x4770          BX       LR
                `.text6`:
                exit:
  0x800'2afe: 0xf000 0xb801   B.W      _exit                  ; 0x800'2b04
  0x800'2b02: 0x0000          MOVS     R0, R0
                `.text6`:
                _exit:
  0x800'2b04: 0x4607          MOV      R7, R0
                `.text_4`:
                @8002b06:
  0x800'2b06: 0x4638          MOV      R0, R7
  0x800'2b08: 0xf000 0xf802   BL       __exit                 ; 0x800'2b10
  0x800'2b0c: 0xe7fb          B.N      @8002b06
  0x800'2b0e: 0x0000          MOVS     R0, R0
                `.text6`:
                __exit:
  0x800'2b10: 0xb580          PUSH     {R7, LR}
  0x800'2b12: 0xf3af 0x8000   NOP.W
  0x800'2b16: 0x4a02          LDR.N    R2, ??__exit_1         ; 0x2'0026
                ??__exit_0:
  0x800'2b18: 0x0011          MOVS     R1, R2
  0x800'2b1a: 0x2018          MOVS     R0, #24                ; 0x18
  0x800'2b1c: 0xbeab          BKPT     #0xab
  0x800'2b1e: 0xe7fb          B.N      ??__exit_0             ; 0x800'2b18
                `$d.32`:
                ??__exit_1:
  0x800'2b20: 0x0002'0026     DC32     0x2'0026               ; '&...'
                $t:
                `.text6`:
                __iar_program_start:
  0x800'2b24: 0x4805          LDR.N    R0, [PC, #0x14]        ; 0xfef5'eda5
  0x800'2b26: 0x4601          MOV      R1, R0
  0x800'2b28: 0xb403          PUSH     {R0, R1}
  0x800'2b2a: 0x4668          MOV      R0, SP
  0x800'2b2c: 0xf380 0x8809   MSR      PSP, R0
  0x800'2b30: 0xf3af 0x8000   NOP.W
  0x800'2b34: 0xf7ff 0xff9e   BL       __iar_init_vfp         ; 0x800'2a74
  0x800'2b38: 0xf7ff 0xffd0   BL       ?main                  ; 0x800'2adc
                `$d.32`:
  0x800'2b3c: 0xfef5'eda5     DC32     0xfef5'eda5            ; '....'
                $t:
                `.text6`:
                _Prout:
  0x800'2b40: 0xb538          PUSH     {R3-R5, LR}
  0x800'2b42: 0x4605          MOV      R5, R0
  0x800'2b44: 0x460c          MOV      R4, R1
  0x800'2b46: 0x4620          MOV      R0, R4
  0x800'2b48: 0xf7ff 0xffb8   BL       putchar                ; 0x800'2abc
  0x800'2b4c: 0x42a0          CMP      R0, R4
  0x800'2b4e: 0xbf18          IT       NE
  0x800'2b50: 0x2500          MOVNE    R5, #0
  0x800'2b52: 0x4628          MOV      R0, R5
  0x800'2b54: 0xbd32          POP      {R1, R4, R5, PC}
  0x800'2b56: 0x0000          MOVS     R0, R0
                `$d.8`:
                `MemManage_Handler::__func__`:
  0x800'2b58: 0x4d 0x65 0x6d  DC8      "MemManage_Handler"
              0x4d 0x61 0x6e
              0x61 0x67 0x65
              0x5f 0x48 0x61
              0x6e 0x64 0x6c
              0x65 0x72 0x00
                `$d.16`:
  0x800'2b6a: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `BusFault_Handler::__func__`:
  0x800'2b6c: 0x42 0x75 0x73  DC8      "BusFault_Handler"
              0x46 0x61 0x75
              0x6c 0x74 0x5f
              0x48 0x61 0x6e
              0x64 0x6c 0x65
              0x72 0x00
                $d:
  0x800'2b7d: 0x00            DC8      0                      ; '.'
  0x800'2b7e: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `UsageFault_Handler::__func__`:
  0x800'2b80: 0x55 0x73 0x61  DC8      "UsageFault_Handler"
              0x67 0x65 0x46
              0x61 0x75 0x6c
              0x74 0x5f 0x48
              0x61 0x6e 0x64
              0x6c 0x65 0x72
              0x00
  0x800'2b93: 0x00            DC8      0                      ; '.'
                ?_1:
  0x800'2b94: 0x68 0x65 0x6c  DC8      "hello qemu.\r\n"
              0x6c 0x6f 0x20
              0x71 0x65 0x6d
              0x75 0x2e 0x0d
              0x0a 0x00
                `$d.16`:
  0x800'2ba2: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                ?_0:
  0x800'2ba4: 0x74 0x68 0x69  DC8      "this is %s.\r\n"
              0x73 0x20 0x69
              0x73 0x20 0x25
              0x73 0x2e 0x0d
              0x0a 0x00
                `$d.16`:
  0x800'2bb2: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `Error_Handler::__func__`:
  0x800'2bb4: 0x45 0x72 0x72  DC8      "Error_Handler"
              0x6f 0x72 0x5f
              0x48 0x61 0x6e
              0x64 0x6c 0x65
              0x72 0x00
                `$d.16`:
  0x800'2bc2: 0x0000          DC16     0                      ; '..'
                `$d.8`:
                `assert_failed::__func__`:
  0x800'2bc4: 0x61 0x73 0x73  DC8      "assert_failed"
              0x65 0x72 0x74
              0x5f 0x66 0x61
              0x69 0x6c 0x65
              0x64 0x00
                `$d.16`:
  0x800'2bd2: 0x0000          DC16     0                      ; '..'
                $t:
                `.text11`:
                SystemInit:
  //     SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  0x800'2bd4: 0x4902          LDR.N    R1, ??DataTable1       ; 0xe000'ed88
  0x800'2bd6: 0x6808          LDR      R0, [R1]
  0x800'2bd8: 0xf450 0x0070   ORRS.W   R0, R0, #15728640      ; 0xf0'0000
  0x800'2bdc: 0x6008          STR      R0, [R1]
  // }
  0x800'2bde: 0x4770          BX       LR
                `$d.32`:
                ??DataTable1:
  0x800'2be0: 0xe000'ed88     DC32     0xe000'ed88            ; '....'
                $t:
                `.text8`:
                Reset_Handler:
  //         LDR     R0, =SystemInit
  0x800'2be4: 0x4801          LDR.N    R0, [PC, #0x4]         ; SystemInit
  //         BLX     R0
  0x800'2be6: 0x4780          BLX      R0
  //         LDR     R0, =__iar_program_start
  0x800'2be8: 0x4801          LDR.N    R0, [PC, #0x4]         ; __iar_program_start
  //         BX      R0
  0x800'2bea: 0x4700          BX       R0
                `$d.32`:
  //         SECTION .text:CODE:REORDER:NOROOT(1)
  0x800'2bec: 0x0800'2bd5     DC32     SystemInit
  //         SECTION .text:CODE:REORDER:NOROOT(1)
  0x800'2bf0: 0x0800'2b25     DC32     __iar_program_start
                $d:
  0x800'2bf4: 0x0000'0010     DC32     16                     ; '....'
  0x800'2bf8: 0x00f4'2400     DC32     0xf4'2400              ; '.$..'
  0x800'2bfc: 0xf0f0'f0f0     DC32     0xf0f0'f0f0            ; '....'
  0x800'2c00: 0x0000'0001     DC32     1                      ; '....'
                `$d.8`:
                `NMI_Handler::__func__`:
  0x800'2c04: 0x4e 0x4d 0x49  DC8      "NMI_Handler"
              0x5f 0x48 0x61
              0x6e 0x64 0x6c
              0x65 0x72 0x00
                `.rodata10`:
                APBPrescTable:
  0x800'2c10: 0x00 0x00 0x00  DC8      0, 0, 0, 0, 1, 2, 3, 4 ; '........'
              0x00 0x01 0x02
              0x03 0x04
                $t:
                `.text10`:
                HardFault_Handler:
  //         B HardFault_Handler
  0x800'2c18: 0xf7ff 0xbffe   B.W      HardFault_Handler      ; 0x800'2c18
                `.text18`:
                WWDG_IRQHandler:
  //         B WWDG_IRQHandler
  0x800'2c1c: 0xf7ff 0xbffe   B.W      WWDG_IRQHandler        ; 0x800'2c1c
                `.text19`:
                PVD_IRQHandler:
  //         B PVD_IRQHandler
  0x800'2c20: 0xf7ff 0xbffe   B.W      PVD_IRQHandler         ; 0x800'2c20
                `.text20`:
                TAMP_STAMP_IRQHandler:
  //         B TAMP_STAMP_IRQHandler
  0x800'2c24: 0xf7ff 0xbffe   B.W      TAMP_STAMP_IRQHandler  ; 0x800'2c24
                `.text21`:
                RTC_WKUP_IRQHandler:
  //         B RTC_WKUP_IRQHandler
  0x800'2c28: 0xf7ff 0xbffe   B.W      RTC_WKUP_IRQHandler    ; 0x800'2c28
                `.text22`:
                FLASH_IRQHandler:
  //         B FLASH_IRQHandler
  0x800'2c2c: 0xf7ff 0xbffe   B.W      FLASH_IRQHandler       ; 0x800'2c2c
                `.text23`:
                RCC_IRQHandler:
  //         B RCC_IRQHandler
  0x800'2c30: 0xf7ff 0xbffe   B.W      RCC_IRQHandler         ; 0x800'2c30
                `.text24`:
                EXTI0_IRQHandler:
  //         B EXTI0_IRQHandler
  0x800'2c34: 0xf7ff 0xbffe   B.W      EXTI0_IRQHandler       ; 0x800'2c34
                `.text25`:
                EXTI1_IRQHandler:
  //         B EXTI1_IRQHandler
  0x800'2c38: 0xf7ff 0xbffe   B.W      EXTI1_IRQHandler       ; 0x800'2c38
                `.text26`:
                EXTI2_IRQHandler:
  //         B EXTI2_IRQHandler
  0x800'2c3c: 0xf7ff 0xbffe   B.W      EXTI2_IRQHandler       ; 0x800'2c3c
                `.text27`:
                EXTI3_IRQHandler:
  //         B EXTI3_IRQHandler
  0x800'2c40: 0xf7ff 0xbffe   B.W      EXTI3_IRQHandler       ; 0x800'2c40
                `.text28`:
                EXTI4_IRQHandler:
  //         B EXTI4_IRQHandler
  0x800'2c44: 0xf7ff 0xbffe   B.W      EXTI4_IRQHandler       ; 0x800'2c44
                `.text29`:
                DMA1_Stream0_IRQHandler:
  //         B DMA1_Stream0_IRQHandler
  0x800'2c48: 0xf7ff 0xbffe   B.W      DMA1_Stream0_IRQHandler
                                                              ; 0x800'2c48
                `.text30`:
                DMA1_Stream1_IRQHandler:
  //         B DMA1_Stream1_IRQHandler
  0x800'2c4c: 0xf7ff 0xbffe   B.W      DMA1_Stream1_IRQHandler
                                                              ; 0x800'2c4c
                `.text31`:
                DMA1_Stream2_IRQHandler:
  //         B DMA1_Stream2_IRQHandler
  0x800'2c50: 0xf7ff 0xbffe   B.W      DMA1_Stream2_IRQHandler
                                                              ; 0x800'2c50
                `.text32`:
                DMA1_Stream3_IRQHandler:
  //         B DMA1_Stream3_IRQHandler
  0x800'2c54: 0xf7ff 0xbffe   B.W      DMA1_Stream3_IRQHandler
                                                              ; 0x800'2c54
                `.text33`:
                DMA1_Stream4_IRQHandler:
  //         B DMA1_Stream4_IRQHandler
  0x800'2c58: 0xf7ff 0xbffe   B.W      DMA1_Stream4_IRQHandler
                                                              ; 0x800'2c58
                `.text34`:
                DMA1_Stream5_IRQHandler:
  //         B DMA1_Stream5_IRQHandler
  0x800'2c5c: 0xf7ff 0xbffe   B.W      DMA1_Stream5_IRQHandler
                                                              ; 0x800'2c5c
                `.text35`:
                DMA1_Stream6_IRQHandler:
  //         B DMA1_Stream6_IRQHandler
  0x800'2c60: 0xf7ff 0xbffe   B.W      DMA1_Stream6_IRQHandler
                                                              ; 0x800'2c60
                `.text36`:
                ADC_IRQHandler:
  //         B ADC_IRQHandler
  0x800'2c64: 0xf7ff 0xbffe   B.W      ADC_IRQHandler         ; 0x800'2c64
                `.text37`:
                CAN1_TX_IRQHandler:
  //         B CAN1_TX_IRQHandler
  0x800'2c68: 0xf7ff 0xbffe   B.W      CAN1_TX_IRQHandler     ; 0x800'2c68
                `.text38`:
                CAN1_RX0_IRQHandler:
  //         B CAN1_RX0_IRQHandler
  0x800'2c6c: 0xf7ff 0xbffe   B.W      CAN1_RX0_IRQHandler    ; 0x800'2c6c
                `.text39`:
                CAN1_RX1_IRQHandler:
  //         B CAN1_RX1_IRQHandler
  0x800'2c70: 0xf7ff 0xbffe   B.W      CAN1_RX1_IRQHandler    ; 0x800'2c70
                `.text40`:
                CAN1_SCE_IRQHandler:
  //         B CAN1_SCE_IRQHandler
  0x800'2c74: 0xf7ff 0xbffe   B.W      CAN1_SCE_IRQHandler    ; 0x800'2c74
                `.text41`:
                EXTI9_5_IRQHandler:
  //         B EXTI9_5_IRQHandler
  0x800'2c78: 0xf7ff 0xbffe   B.W      EXTI9_5_IRQHandler     ; 0x800'2c78
                `.text42`:
                TIM1_BRK_TIM9_IRQHandler:
  //         B TIM1_BRK_TIM9_IRQHandler
  0x800'2c7c: 0xf7ff 0xbffe   B.W      TIM1_BRK_TIM9_IRQHandler
                                                              ; 0x800'2c7c
                `.text43`:
                TIM1_UP_TIM10_IRQHandler:
  //         B TIM1_UP_TIM10_IRQHandler
  0x800'2c80: 0xf7ff 0xbffe   B.W      TIM1_UP_TIM10_IRQHandler
                                                              ; 0x800'2c80
                `.text44`:
                TIM1_TRG_COM_TIM11_IRQHandler:
  //         B TIM1_TRG_COM_TIM11_IRQHandler
  0x800'2c84: 0xf7ff 0xbffe   B.W      TIM1_TRG_COM_TIM11_IRQHandler
                                                              ; 0x800'2c84
                `.text45`:
                TIM1_CC_IRQHandler:
  //         B TIM1_CC_IRQHandler
  0x800'2c88: 0xf7ff 0xbffe   B.W      TIM1_CC_IRQHandler     ; 0x800'2c88
                `.text47`:
                TIM3_IRQHandler:
  //         B TIM3_IRQHandler
  0x800'2c8c: 0xf7ff 0xbffe   B.W      TIM3_IRQHandler        ; 0x800'2c8c
                `.text48`:
                TIM4_IRQHandler:
  //         B TIM4_IRQHandler
  0x800'2c90: 0xf7ff 0xbffe   B.W      TIM4_IRQHandler        ; 0x800'2c90
                `.text49`:
                I2C1_EV_IRQHandler:
  //         B I2C1_EV_IRQHandler
  0x800'2c94: 0xf7ff 0xbffe   B.W      I2C1_EV_IRQHandler     ; 0x800'2c94
                `.text50`:
                I2C1_ER_IRQHandler:
  //         B I2C1_ER_IRQHandler
  0x800'2c98: 0xf7ff 0xbffe   B.W      I2C1_ER_IRQHandler     ; 0x800'2c98
                `.text51`:
                I2C2_EV_IRQHandler:
  //         B I2C2_EV_IRQHandler
  0x800'2c9c: 0xf7ff 0xbffe   B.W      I2C2_EV_IRQHandler     ; 0x800'2c9c
                `.text52`:
                I2C2_ER_IRQHandler:
  //         B I2C2_ER_IRQHandler
  0x800'2ca0: 0xf7ff 0xbffe   B.W      I2C2_ER_IRQHandler     ; 0x800'2ca0
                `.text53`:
                SPI1_IRQHandler:
  //         B SPI1_IRQHandler
  0x800'2ca4: 0xf7ff 0xbffe   B.W      SPI1_IRQHandler        ; 0x800'2ca4
                `.text54`:
                SPI2_IRQHandler:
  //         B SPI2_IRQHandler
  0x800'2ca8: 0xf7ff 0xbffe   B.W      SPI2_IRQHandler        ; 0x800'2ca8
                `.text56`:
                USART2_IRQHandler:
  //         B USART2_IRQHandler
  0x800'2cac: 0xf7ff 0xbffe   B.W      USART2_IRQHandler      ; 0x800'2cac
                `.text57`:
                USART3_IRQHandler:
  //         B USART3_IRQHandler
  0x800'2cb0: 0xf7ff 0xbffe   B.W      USART3_IRQHandler      ; 0x800'2cb0
                `.text58`:
                EXTI15_10_IRQHandler:
  //         B EXTI15_10_IRQHandler
  0x800'2cb4: 0xf7ff 0xbffe   B.W      EXTI15_10_IRQHandler   ; 0x800'2cb4
                `.text59`:
                RTC_Alarm_IRQHandler:
  //         B RTC_Alarm_IRQHandler
  0x800'2cb8: 0xf7ff 0xbffe   B.W      RTC_Alarm_IRQHandler   ; 0x800'2cb8
                `.text60`:
                OTG_FS_WKUP_IRQHandler:
  //         B OTG_FS_WKUP_IRQHandler
  0x800'2cbc: 0xf7ff 0xbffe   B.W      OTG_FS_WKUP_IRQHandler ; 0x800'2cbc
                `.text61`:
                TIM8_BRK_TIM12_IRQHandler:
  //         B TIM8_BRK_TIM12_IRQHandler
  0x800'2cc0: 0xf7ff 0xbffe   B.W      TIM8_BRK_TIM12_IRQHandler
                                                              ; 0x800'2cc0
                `.text62`:
                TIM8_UP_TIM13_IRQHandler:
  //         B TIM8_UP_TIM13_IRQHandler
  0x800'2cc4: 0xf7ff 0xbffe   B.W      TIM8_UP_TIM13_IRQHandler
                                                              ; 0x800'2cc4
                `.text63`:
                TIM8_TRG_COM_TIM14_IRQHandler:
  //         B TIM8_TRG_COM_TIM14_IRQHandler
  0x800'2cc8: 0xf7ff 0xbffe   B.W      TIM8_TRG_COM_TIM14_IRQHandler
                                                              ; 0x800'2cc8
                `.text64`:
                TIM8_CC_IRQHandler:
  //         B TIM8_CC_IRQHandler
  0x800'2ccc: 0xf7ff 0xbffe   B.W      TIM8_CC_IRQHandler     ; 0x800'2ccc
                `.text65`:
                DMA1_Stream7_IRQHandler:
  //         B DMA1_Stream7_IRQHandler
  0x800'2cd0: 0xf7ff 0xbffe   B.W      DMA1_Stream7_IRQHandler
                                                              ; 0x800'2cd0
                `.text66`:
                FSMC_IRQHandler:
  //         B FSMC_IRQHandler
  0x800'2cd4: 0xf7ff 0xbffe   B.W      FSMC_IRQHandler        ; 0x800'2cd4
                `.text67`:
                SDIO_IRQHandler:
  //         B SDIO_IRQHandler
  0x800'2cd8: 0xf7ff 0xbffe   B.W      SDIO_IRQHandler        ; 0x800'2cd8
                `.text68`:
                TIM5_IRQHandler:
  //         B TIM5_IRQHandler
  0x800'2cdc: 0xf7ff 0xbffe   B.W      TIM5_IRQHandler        ; 0x800'2cdc
                `.text69`:
                SPI3_IRQHandler:
  //         B SPI3_IRQHandler
  0x800'2ce0: 0xf7ff 0xbffe   B.W      SPI3_IRQHandler        ; 0x800'2ce0
                `.text70`:
                UART4_IRQHandler:
  //         B UART4_IRQHandler
  0x800'2ce4: 0xf7ff 0xbffe   B.W      UART4_IRQHandler       ; 0x800'2ce4
                `.text71`:
                UART5_IRQHandler:
  //         B UART5_IRQHandler
  0x800'2ce8: 0xf7ff 0xbffe   B.W      UART5_IRQHandler       ; 0x800'2ce8
                `.text72`:
                TIM6_DAC_IRQHandler:
  //         B TIM6_DAC_IRQHandler
  0x800'2cec: 0xf7ff 0xbffe   B.W      TIM6_DAC_IRQHandler    ; 0x800'2cec
                `.text73`:
                TIM7_IRQHandler:
  //         B TIM7_IRQHandler
  0x800'2cf0: 0xf7ff 0xbffe   B.W      TIM7_IRQHandler        ; 0x800'2cf0
                `.text74`:
                DMA2_Stream0_IRQHandler:
  //         B DMA2_Stream0_IRQHandler
  0x800'2cf4: 0xf7ff 0xbffe   B.W      DMA2_Stream0_IRQHandler
                                                              ; 0x800'2cf4
                `.text75`:
                DMA2_Stream1_IRQHandler:
  //         B DMA2_Stream1_IRQHandler
  0x800'2cf8: 0xf7ff 0xbffe   B.W      DMA2_Stream1_IRQHandler
                                                              ; 0x800'2cf8
                `.text76`:
                DMA2_Stream2_IRQHandler:
  //         B DMA2_Stream2_IRQHandler
  0x800'2cfc: 0xf7ff 0xbffe   B.W      DMA2_Stream2_IRQHandler
                                                              ; 0x800'2cfc
                `.text77`:
                DMA2_Stream3_IRQHandler:
  //         B DMA2_Stream3_IRQHandler
  0x800'2d00: 0xf7ff 0xbffe   B.W      DMA2_Stream3_IRQHandler
                                                              ; 0x800'2d00
                `.text78`:
                DMA2_Stream4_IRQHandler:
  //         B DMA2_Stream4_IRQHandler
  0x800'2d04: 0xf7ff 0xbffe   B.W      DMA2_Stream4_IRQHandler
                                                              ; 0x800'2d04
                `.text79`:
                CAN2_TX_IRQHandler:
  //         B CAN2_TX_IRQHandler
  0x800'2d08: 0xf7ff 0xbffe   B.W      CAN2_TX_IRQHandler     ; 0x800'2d08
                `.text80`:
                CAN2_RX0_IRQHandler:
  //         B CAN2_RX0_IRQHandler
  0x800'2d0c: 0xf7ff 0xbffe   B.W      CAN2_RX0_IRQHandler    ; 0x800'2d0c
                `.text81`:
                CAN2_RX1_IRQHandler:
  //         B CAN2_RX1_IRQHandler
  0x800'2d10: 0xf7ff 0xbffe   B.W      CAN2_RX1_IRQHandler    ; 0x800'2d10
                `.text82`:
                CAN2_SCE_IRQHandler:
  //         B CAN2_SCE_IRQHandler
  0x800'2d14: 0xf7ff 0xbffe   B.W      CAN2_SCE_IRQHandler    ; 0x800'2d14
                `.text83`:
                OTG_FS_IRQHandler:
  //         B OTG_FS_IRQHandler
  0x800'2d18: 0xf7ff 0xbffe   B.W      OTG_FS_IRQHandler      ; 0x800'2d18
                `.text84`:
                DMA2_Stream5_IRQHandler:
  //         B DMA2_Stream5_IRQHandler
  0x800'2d1c: 0xf7ff 0xbffe   B.W      DMA2_Stream5_IRQHandler
                                                              ; 0x800'2d1c
                `.text85`:
                DMA2_Stream6_IRQHandler:
  //         B DMA2_Stream6_IRQHandler
  0x800'2d20: 0xf7ff 0xbffe   B.W      DMA2_Stream6_IRQHandler
                                                              ; 0x800'2d20
                `.text86`:
                DMA2_Stream7_IRQHandler:
  //         B DMA2_Stream7_IRQHandler
  0x800'2d24: 0xf7ff 0xbffe   B.W      DMA2_Stream7_IRQHandler
                                                              ; 0x800'2d24
                `.text87`:
                USART6_IRQHandler:
  //         B USART6_IRQHandler
  0x800'2d28: 0xf7ff 0xbffe   B.W      USART6_IRQHandler      ; 0x800'2d28
                `.text88`:
                I2C3_EV_IRQHandler:
  //         B I2C3_EV_IRQHandler
  0x800'2d2c: 0xf7ff 0xbffe   B.W      I2C3_EV_IRQHandler     ; 0x800'2d2c
                `.text89`:
                I2C3_ER_IRQHandler:
  //         B I2C3_ER_IRQHandler
  0x800'2d30: 0xf7ff 0xbffe   B.W      I2C3_ER_IRQHandler     ; 0x800'2d30
                `.text90`:
                OTG_HS_EP1_OUT_IRQHandler:
  //         B OTG_HS_EP1_OUT_IRQHandler
  0x800'2d34: 0xf7ff 0xbffe   B.W      OTG_HS_EP1_OUT_IRQHandler
                                                              ; 0x800'2d34
                `.text91`:
                OTG_HS_EP1_IN_IRQHandler:
  //         B OTG_HS_EP1_IN_IRQHandler
  0x800'2d38: 0xf7ff 0xbffe   B.W      OTG_HS_EP1_IN_IRQHandler
                                                              ; 0x800'2d38
                `.text92`:
                OTG_HS_WKUP_IRQHandler:
  //         B OTG_HS_WKUP_IRQHandler
  0x800'2d3c: 0xf7ff 0xbffe   B.W      OTG_HS_WKUP_IRQHandler ; 0x800'2d3c
                `.text93`:
                OTG_HS_IRQHandler:
  //         B OTG_HS_IRQHandler
  0x800'2d40: 0xf7ff 0xbffe   B.W      OTG_HS_IRQHandler      ; 0x800'2d40
                `.text94`:
                HASH_RNG_IRQHandler:
  //         B HASH_RNG_IRQHandler
  0x800'2d44: 0xf7ff 0xbffe   B.W      HASH_RNG_IRQHandler    ; 0x800'2d44
                `.text95`:
                FPU_IRQHandler:
  //         B FPU_IRQHandler
  0x800'2d48: 0xf7ff 0xbffe   B.W      FPU_IRQHandler         ; 0x800'2d48
                __iar_SB:

Errors: none
Warnings: none
